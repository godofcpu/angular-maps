(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('async'), require('@angular/core'), require('rxjs'), require('@angular/common'), require('bingmaps')) :
    typeof define === 'function' && define.amd ? define('angular-maps', ['exports', 'async', '@angular/core', 'rxjs', '@angular/common', 'bingmaps'], factory) :
    (factory((global['angular-maps'] = {}),null,global.ng.core,global.rxjs,global.ng.common));
}(this, (function (exports,async,core,rxjs,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ InfoWindow = (function () {
        function InfoWindow() {
        }
        return InfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var MarkerTypeId = {
        None: 0,
        FontMarker: 1,
        CanvasMarker: 2,
        DynamicCircleMarker: 3,
        RotatedImageMarker: 4,
        RoundedImageMarker: 5,
        ScaledImageMarker: 6,
        Custom: 7,
    };
    MarkerTypeId[MarkerTypeId.None] = 'None';
    MarkerTypeId[MarkerTypeId.FontMarker] = 'FontMarker';
    MarkerTypeId[MarkerTypeId.CanvasMarker] = 'CanvasMarker';
    MarkerTypeId[MarkerTypeId.DynamicCircleMarker] = 'DynamicCircleMarker';
    MarkerTypeId[MarkerTypeId.RotatedImageMarker] = 'RotatedImageMarker';
    MarkerTypeId[MarkerTypeId.RoundedImageMarker] = 'RoundedImageMarker';
    MarkerTypeId[MarkerTypeId.ScaledImageMarker] = 'ScaledImageMarker';
    MarkerTypeId[MarkerTypeId.Custom] = 'Custom';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This class defines the contract for a marker.
     *
     * @export
     * @abstract
     * @abstract
     */
    var Marker = (function () {
        function Marker() {
        }
        /**
         * Creates a marker based on the marker info. In turn calls a number of internal members to
         * create the actual marker.
         *
         * \@memberof Marker
         * @param {?} iconInfo - icon information. Depending on the marker type, various properties
         * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate
         * reuse.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image.
         */
        Marker.CreateMarker = /**
         * Creates a marker based on the marker info. In turn calls a number of internal members to
         * create the actual marker.
         *
         * \@memberof Marker
         * @param {?} iconInfo - icon information. Depending on the marker type, various properties
         * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate
         * reuse.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image.
         */
            function (iconInfo) {
                switch (iconInfo.markerType) {
                    case MarkerTypeId.CanvasMarker: return Marker.CreateCanvasMarker(iconInfo);
                    case MarkerTypeId.DynamicCircleMarker: return Marker.CreateDynamicCircleMarker(iconInfo);
                    case MarkerTypeId.FontMarker: return Marker.CreateFontBasedMarker(iconInfo);
                    case MarkerTypeId.RotatedImageMarker: return Marker.CreateRotatedImageMarker(iconInfo);
                    case MarkerTypeId.RoundedImageMarker: return Marker.CreateRoundedImageMarker(iconInfo);
                    case MarkerTypeId.ScaledImageMarker: return Marker.CreateScaledImageMarker(iconInfo);
                    case MarkerTypeId.Custom: throw Error('Custom Marker Creators are not currently supported.');
                }
                throw Error('Unsupported marker type: ' + iconInfo.markerType);
            };
        /**
         * Obtains a shared img element for a marker icon to prevent unecessary creation of
         * DOM items. This has sped up large scale makers on Bing Maps by about 70%
         * \@memberof Marker
         * @param {?} icon - The icon string (url, data url, svg) for which to obtain the image.
         * @return {?} - The obtained image element.
         */
        Marker.GetImageForMarker = /**
         * Obtains a shared img element for a marker icon to prevent unecessary creation of
         * DOM items. This has sped up large scale makers on Bing Maps by about 70%
         * \@memberof Marker
         * @param {?} icon - The icon string (url, data url, svg) for which to obtain the image.
         * @return {?} - The obtained image element.
         */
            function (icon) {
                if (icon == null || icon === '') {
                    return null;
                }
                /** @type {?} */
                var img = null;
                img = Marker.ImageElementCache.get(icon);
                if (img != null) {
                    return img;
                }
                if (typeof (document) !== 'undefined' && document != null) {
                    img = document.createElement('img');
                    img.src = icon;
                    Marker.ImageElementCache.set(icon, img);
                }
                return img;
            };
        /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateCanvasMarker = /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for canvas markers.');
                }
                if (iconInfo == null || iconInfo.size == null || iconInfo.points == null) {
                    throw Error('IMarkerIconInfo.size, and IMarkerIConInfo.points are required for canvas markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    /** @type {?} */
                    var mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                /** @type {?} */
                var c = document.createElement('canvas');
                /** @type {?} */
                var ctx = c.getContext('2d');
                c.width = iconInfo.size.width;
                c.height = iconInfo.size.height;
                if (iconInfo.rotation) {
                    // Offset the canvas such that we will rotate around the center of our arrow
                    ctx.translate(c.width * 0.5, c.height * 0.5);
                    // Rotate the canvas by the desired heading
                    ctx.rotate(iconInfo.rotation * Math.PI / 180);
                    // Return the canvas offset back to it's original position
                    ctx.translate(-c.width * 0.5, -c.height * 0.5);
                }
                ctx.fillStyle = iconInfo.color || 'red';
                // Draw a path in the shape of an arrow.
                ctx.beginPath();
                if (iconInfo.drawingOffset) {
                    ctx.moveTo(iconInfo.drawingOffset.x, iconInfo.drawingOffset.y);
                }
                iconInfo.points.forEach(function (p) { ctx.lineTo(p.x, p.y); });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                /** @type {?} */
                var s = c.toDataURL();
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateDynamicCircleMarker = /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for dynamic circle markers.');
                }
                if (iconInfo == null || iconInfo.size == null) {
                    throw Error('IMarkerIconInfo.size is required for dynamic circle markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    /** @type {?} */
                    var mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                /** @type {?} */
                var strokeWidth = iconInfo.strokeWidth || 0;
                /** @type {?} */
                var svg = [
                    '<svg xmlns="http://www.w3.org/2000/svg" width="',
                    iconInfo.size.width.toString(),
                    '" height="',
                    iconInfo.size.width.toString(),
                    '"><circle cx="',
                    (iconInfo.size.width / 2).toString(),
                    '" cy="',
                    (iconInfo.size.width / 2).toString(),
                    '" r="',
                    ((iconInfo.size.width / 2) - strokeWidth).toString(),
                    '" stroke="',
                    iconInfo.color || 'red',
                    '" stroke-width="',
                    strokeWidth.toString(),
                    '" fill="',
                    iconInfo.color || 'red',
                    '"/></svg>'
                ];
                /** @type {?} */
                var s = svg.join('');
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateFontBasedMarker = /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for font based markers');
                }
                if (iconInfo == null || iconInfo.fontName == null || iconInfo.fontSize == null) {
                    throw Error('IMarkerIconInfo.fontName, IMarkerIconInfo.fontSize and IMarkerIConInfo.text are required for font based markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    /** @type {?} */
                    var mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                /** @type {?} */
                var c = document.createElement('canvas');
                /** @type {?} */
                var ctx = c.getContext('2d');
                /** @type {?} */
                var font = iconInfo.fontSize + 'px ' + iconInfo.fontName;
                ctx.font = font;
                /** @type {?} */
                var size = ctx.measureText(iconInfo.text);
                c.width = size.width;
                c.height = iconInfo.fontSize;
                if (iconInfo.rotation) {
                    // Offset the canvas such that we will rotate around the center of our arrow
                    ctx.translate(c.width * 0.5, c.height * 0.5);
                    // Rotate the canvas by the desired heading
                    ctx.rotate(iconInfo.rotation * Math.PI / 180);
                    // Return the canvas offset back to it's original position
                    ctx.translate(-c.width * 0.5, -c.height * 0.5);
                }
                // Reset font as it will be cleared by the resize.
                ctx.font = font;
                ctx.textBaseline = 'top';
                ctx.fillStyle = iconInfo.color || 'red';
                ctx.fillText(iconInfo.text, 0, 0);
                iconInfo.size = { width: c.width, height: c.height };
                /** @type {?} */
                var s = c.toDataURL();
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateRotatedImageMarker = /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for rotated image markers');
                }
                if (iconInfo == null || iconInfo.rotation == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.rotation, IMarkerIconInfo.url are required for rotated image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    /** @type {?} */
                    var mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                /** @type {?} */
                var image = new Image();
                /** @type {?} */
                var promise = new Promise(function (resolve, reject) {
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    if (iconInfo.size) {
                        image.width = iconInfo.size.width;
                        image.height = iconInfo.size.height;
                    }
                    image.onload = function () {
                        /** @type {?} */
                        var c = document.createElement('canvas');
                        /** @type {?} */
                        var ctx = c.getContext('2d');
                        /** @type {?} */
                        var rads = iconInfo.rotation * Math.PI / 180;
                        // Calculate rotated image size.
                        c.width = Math.ceil(Math.abs(image.width * Math.cos(rads)) + Math.abs(image.height * Math.sin(rads)));
                        c.height = Math.ceil(Math.abs(image.width * Math.sin(rads)) + Math.abs(image.height * Math.cos(rads)));
                        // Move to the center of the canvas.
                        ctx.translate(c.width / 2, c.height / 2);
                        // Rotate the canvas to the specified angle in degrees.
                        ctx.rotate(rads);
                        // Draw the image, since the context is rotated, the image will be rotated also.
                        ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
                        iconInfo.size = { width: c.width, height: c.height };
                        /** @type {?} */
                        var s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @param iconInfo - Callback invoked once marker generation is complete. The callback
         * parameters are the data uri and the IMarkerIconInfo.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateRoundedImageMarker = /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for rounded image markers');
                }
                if (iconInfo == null || iconInfo.size == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.size, IMarkerIconInfo.url are required for rounded image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    /** @type {?} */
                    var mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                /** @type {?} */
                var promise = new Promise(function (resolve, reject) {
                    /** @type {?} */
                    var radius = iconInfo.size.width / 2;
                    /** @type {?} */
                    var image = new Image();
                    /** @type {?} */
                    var offset = iconInfo.drawingOffset || { x: 0, y: 0 };
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    image.onload = function () {
                        /** @type {?} */
                        var c = document.createElement('canvas');
                        /** @type {?} */
                        var ctx = c.getContext('2d');
                        c.width = iconInfo.size.width;
                        c.height = iconInfo.size.width;
                        // Draw a circle which can be used to clip the image, then draw the image.
                        ctx.beginPath();
                        ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);
                        ctx.fill();
                        ctx.clip();
                        ctx.drawImage(image, offset.x, offset.y, iconInfo.size.width, iconInfo.size.width);
                        iconInfo.size = { width: c.width, height: c.height };
                        /** @type {?} */
                        var s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @param iconInfo - Callback invoked once marker generation is complete. The callback
         * parameters are the data uri and the IMarkerIconInfo.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateScaledImageMarker = /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for scaled image markers');
                }
                if (iconInfo == null || iconInfo.scale == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.scale, IMarkerIconInfo.url are required for scaled image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    /** @type {?} */
                    var mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                /** @type {?} */
                var promise = new Promise(function (resolve, reject) {
                    /** @type {?} */
                    var image = new Image();
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    image.onload = function () {
                        /** @type {?} */
                        var c = document.createElement('canvas');
                        /** @type {?} */
                        var ctx = c.getContext('2d');
                        c.width = image.width * iconInfo.scale;
                        c.height = image.height * iconInfo.scale;
                        // Draw a circle which can be used to clip the image, then draw the image.
                        ctx.drawImage(image, 0, 0, c.width, c.height);
                        iconInfo.size = { width: c.width, height: c.height };
                        /** @type {?} */
                        var s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Caches concrete img elements for marker icons to accelerate patining.
         *
         * \@memberof Marker
         */
        Marker.ImageElementCache = new Map();
        /**
         * Used to cache generated markers for performance and reusability.
         *
         * \@memberof Marker
         */
        Marker.MarkerCache = new Map();
        return Marker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var MapTypeId = {
        /** The aerial map type which uses top-down satellite & airplane imagery. */
        aerial: 0,
        /** A darker version of the road maps. */
        canvasDark: 1,
        /** A lighter version of the road maps which also has some of the details such as hill shading disabled. */
        canvasLight: 2,
        /** A grayscale version of the road maps. */
        grayscale: 3,
        /** The aerial map type including lables */
        hybrid: 4,
        /** Displays a blank canvas that uses the mercator map project. It basically removed the base maps layer. */
        mercator: 5,
        /** Ordnance survey map type (en-gb only). */
        ordnanceSurvey: 6,
        /** Road map type. */
        road: 7,
        /** Provides streetside panoramas from the street level. */
        streetside: 8,
    };
    MapTypeId[MapTypeId.aerial] = 'aerial';
    MapTypeId[MapTypeId.canvasDark] = 'canvasDark';
    MapTypeId[MapTypeId.canvasLight] = 'canvasLight';
    MapTypeId[MapTypeId.grayscale] = 'grayscale';
    MapTypeId[MapTypeId.hybrid] = 'hybrid';
    MapTypeId[MapTypeId.mercator] = 'mercator';
    MapTypeId[MapTypeId.ordnanceSurvey] = 'ordnanceSurvey';
    MapTypeId[MapTypeId.road] = 'road';
    MapTypeId[MapTypeId.streetside] = 'streetside';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Defines the contract for a map layer implementation. Deriving providers should implements this abstract
     * to provide concrete layer functionality for the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Defines the contract for a map layer implementation. Deriving providers should implements this abstract
     * to provide concrete layer functionality for the map.
     *
     * @export
     * @abstract
     * @abstract
     */ Layer = (function () {
        function Layer() {
        }
        return Layer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract class defining the contract for a polygon in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract class defining the contract for a polygon in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */ Polygon = (function () {
        function Polygon() {
        }
        Object.defineProperty(Polygon.prototype, "Center", {
            get: /**
             * Gets the polygon's center.
             * \@readonly
             * \@memberof Polygon
             * @return {?}
             */ function () {
                if (this._center == null) {
                    this._center = this.GetBoundingCenter();
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Polygon.prototype, "Centroid", {
            get: /**
             * Gets the polygon's centroid.
             * \@readonly
             * \@memberof Polygon
             * @return {?}
             */ function () {
                if (this._centroid == null) {
                    this._centroid = this.GetPolygonCentroid();
                }
                return this._centroid;
            },
            enumerable: true,
            configurable: true
        });
        ///
        /// Protected methods
        ///
        /**
         * Gets the center of the polygons' bounding box.
         *
         * @returns - ILatLong object containing the center of the bounding box.
         * @memberof Polygon
         * @method
         * @protected
         */
        /**
         * Gets the center of the polygons' bounding box.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - ILatLong object containing the center of the bounding box.
         */
        Polygon.prototype.GetBoundingCenter = /**
         * Gets the center of the polygons' bounding box.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - ILatLong object containing the center of the bounding box.
         */
            function () {
                /** @type {?} */
                var c = { latitude: 0, longitude: 0 };
                /** @type {?} */
                var x1 = 90;
                /** @type {?} */
                var x2 = -90;
                /** @type {?} */
                var y1 = 180;
                /** @type {?} */
                var y2 = -180;
                /** @type {?} */
                var path = this.GetPaths();
                if (path) {
                    path.forEach(function (inner) {
                        return inner.forEach(function (p) {
                            if (p.latitude < x1) {
                                x1 = p.latitude;
                            }
                            if (p.latitude > x2) {
                                x2 = p.latitude;
                            }
                            if (p.longitude < y1) {
                                y1 = p.longitude;
                            }
                            if (p.longitude > y2) {
                                y2 = p.longitude;
                            }
                        });
                    });
                    c.latitude = x1 + (x2 - x1) / 2;
                    c.longitude = y1 + (y2 - y1) / 2;
                }
                else {
                    c = null;
                }
                return c;
            };
        /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * @returns - The centroid coordinates of the polygon.
         * @memberof Polygon
         * @method
         * @protected
         */
        /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polygon.
         */
        Polygon.prototype.GetPolygonCentroid = /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polygon.
         */
            function () {
                /** @type {?} */
                var c = { latitude: 0, longitude: 0 };
                /** @type {?} */
                var path = this.GetPaths();
                /** @type {?} */
                var off = path[0][0];
                if (off != null) {
                    /** @type {?} */
                    var twicearea = 0;
                    /** @type {?} */
                    var x = 0;
                    /** @type {?} */
                    var y = 0;
                    /** @type {?} */
                    var p1 = void 0;
                    /** @type {?} */
                    var p2 = void 0;
                    /** @type {?} */
                    var f = void 0;
                    for (var k = 0; k < path.length; k++) {
                        for (var i = 0, j = path[k].length - 1; i < path[k].length; j = i++) {
                            p1 = path[k][i];
                            p2 = path[k][j];
                            f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                                (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
                            twicearea += f;
                            x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
                            y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
                        }
                    }
                    if (twicearea !== 0) {
                        f = twicearea * 3;
                        c.latitude = x / f + off.latitude;
                        c.longitude = y / f + off.longitude;
                    }
                    else {
                        c.latitude = off.latitude;
                        c.longitude = off.longitude;
                    }
                }
                else {
                    c = null;
                }
                return c;
            };
        return Polygon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract class defining the contract for a polyline in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract class defining the contract for a polyline in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */ Polyline = (function () {
        function Polyline() {
        }
        Object.defineProperty(Polyline.prototype, "Center", {
            get: /**
             * Gets the polyline's center.
             * \@readonly
             * \@memberof Polyline
             * @return {?}
             */ function () {
                if (this._center == null) {
                    this._center = this.GetBoundingCenter();
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Polyline.prototype, "Centroid", {
            get: /**
             * Gets the polyline's centroid.
             * \@readonly
             * \@memberof Polyline
             * @return {?}
             */ function () {
                if (this._centroid == null) {
                    this._centroid = this.GetPolylineCentroid();
                }
                return this._centroid;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get the centroid of the polyline based on the a path.
         *
         * \@memberof Polyline
         * \@method
         * @param {?} path - the path for which to generate the centroid
         * @return {?} - The centroid coordinates of the polyline.
         */
        Polyline.GetPolylineCentroid = /**
         * Get the centroid of the polyline based on the a path.
         *
         * \@memberof Polyline
         * \@method
         * @param {?} path - the path for which to generate the centroid
         * @return {?} - The centroid coordinates of the polyline.
         */
            function (path) {
                /** @type {?} */
                var c = { latitude: 0, longitude: 0 };
                /** @type {?} */
                var off = path[0];
                if (off != null) {
                    /** @type {?} */
                    var twicearea = 0;
                    /** @type {?} */
                    var x = 0;
                    /** @type {?} */
                    var y = 0;
                    /** @type {?} */
                    var p1 = void 0;
                    /** @type {?} */
                    var p2 = void 0;
                    /** @type {?} */
                    var f = void 0;
                    for (var i = 0, j = path.length - 1; i < path.length; j = i++) {
                        p1 = path[i];
                        p2 = path[j];
                        f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                            (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
                        twicearea += f;
                        x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
                        y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
                    }
                    if (twicearea !== 0) {
                        f = twicearea * 3;
                        c.latitude = x / f + off.latitude;
                        c.longitude = y / f + off.longitude;
                    }
                    else {
                        c.latitude = off.latitude;
                        c.longitude = off.longitude;
                    }
                }
                else {
                    c = null;
                }
                return c;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the center of the polyline' bounding box.
         *
         * @returns - {@link ILatLong} object containing the center of the bounding box.
         * @memberof Polyline
         * @method
         * @protected
         */
        /**
         * Gets the center of the polyline' bounding box.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - {\@link ILatLong} object containing the center of the bounding box.
         */
        Polyline.prototype.GetBoundingCenter = /**
         * Gets the center of the polyline' bounding box.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - {\@link ILatLong} object containing the center of the bounding box.
         */
            function () {
                /** @type {?} */
                var c = { latitude: 0, longitude: 0 };
                /** @type {?} */
                var x1 = 90;
                /** @type {?} */
                var x2 = -90;
                /** @type {?} */
                var y1 = 180;
                /** @type {?} */
                var y2 = -180;
                /** @type {?} */
                var path = this.GetPath();
                if (path) {
                    path.forEach(function (p) {
                        if (p.latitude < x1) {
                            x1 = p.latitude;
                        }
                        if (p.latitude > x2) {
                            x2 = p.latitude;
                        }
                        if (p.longitude < y1) {
                            y1 = p.longitude;
                        }
                        if (p.longitude > y2) {
                            y2 = p.longitude;
                        }
                    });
                    c.latitude = x1 + (x2 - x1) / 2;
                    c.longitude = y1 + (y2 - y1) / 2;
                }
                else {
                    c = null;
                }
                return c;
            };
        /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * @returns - The centroid coordinates of the polyline.
         * @memberof Polyline
         * @method
         * @protected
         */
        /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polyline.
         */
        Polyline.prototype.GetPolylineCentroid = /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polyline.
         */
            function () {
                /** @type {?} */
                var path = this.GetPath();
                /** @type {?} */
                var c = Polyline.GetPolylineCentroid(path);
                return c;
            };
        return Polyline;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ SpiderClusterMarker = (function (_super) {
        __extends(SpiderClusterMarker, _super);
        function SpiderClusterMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SpiderClusterMarker;
    }(Marker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var ClusterPlacementMode = {
        None: 0,
        MeanValue: 1,
        FirstPin: 2,
    };
    ClusterPlacementMode[ClusterPlacementMode.None] = 'None';
    ClusterPlacementMode[ClusterPlacementMode.MeanValue] = 'MeanValue';
    ClusterPlacementMode[ClusterPlacementMode.FirstPin] = 'FirstPin';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var ClusterClickAction = {
        None: 0,
        ZoomIntoCluster: 1,
        Spider: 2,
    };
    ClusterClickAction[ClusterClickAction.None] = 'None';
    ClusterClickAction[ClusterClickAction.ZoomIntoCluster] = 'ZoomIntoCluster';
    ClusterClickAction[ClusterClickAction.Spider] = 'Spider';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var id = 0;
    /**
     * Abstract base implementing a canvas overlay to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract base implementing a canvas overlay to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */ CanvasOverlay = (function () {
        /**
         * Creates a new instance of the CanvasOverlay class.
         */
        function CanvasOverlay(drawCallback) {
            var _this = this;
            this._canvasReady = new Promise(function (resolve, reject) { _this._readyResolver = resolve; });
            this._drawCallback = drawCallback;
            id++;
        }
        Object.defineProperty(CanvasOverlay.prototype, "CanvasReady", {
            get: /**
             * Returns a promise that gets resolved when the canvas overlay is ready for interaction.
             * @return {?}
             */ function () { return this._canvasReady; },
            enumerable: true,
            configurable: true
        });
        /**
         * Deletes the canvas overlay.
         * @return {?}
         */
        CanvasOverlay.prototype.Delete = /**
         * Deletes the canvas overlay.
         * @return {?}
         */
            function () {
                this.SetMap(null);
            };
        /**
         * CanvasOverlay added to map, load canvas.
         * @return {?}
         */
        CanvasOverlay.prototype.OnAdd = /**
         * CanvasOverlay added to map, load canvas.
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                this._canvas.style.position = 'absolute';
                this._canvas.style.left = '0px';
                this._canvas.style.top = '0px';
                this._canvas.id = "xMapOverlay" + id;
                // Add the canvas to the overlay.
                this.SetCanvasElement(this._canvas);
            };
        /**
         * When the CanvasLayer is removed from the map, release resources.
         * \@memberof CanvasOverlay
         * \@method
         * @return {?}
         */
        CanvasOverlay.prototype.OnRemove = /**
         * When the CanvasLayer is removed from the map, release resources.
         * \@memberof CanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                this.SetCanvasElement(null);
                this.RemoveEventHandlers();
                this._canvas = null;
            };
        /**
         * Redraws the canvas for the current map view.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} clear - True to clear the canvas before drawing.
         * @return {?}
         */
        CanvasOverlay.prototype.Redraw = /**
         * Redraws the canvas for the current map view.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} clear - True to clear the canvas before drawing.
         * @return {?}
         */
            function (clear) {
                if (this._canvas == null) {
                    return;
                }
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                if (clear) {
                    this.Resize();
                }
                // Call the drawing callback function if specified.
                if (this._drawCallback) {
                    this._drawCallback(this._canvas);
                }
            };
        /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * @param x The horizontal offset position of the canvas.
         * @param y The vertical offset position of the canvas.
         * @param w The width of the canvas.
         * @param h The height of the canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @param {?} x The horizontal offset position of the canvas.
         * @param {?} y The vertical offset position of the canvas.
         * @param {?} w The width of the canvas.
         * @param {?} h The height of the canvas.
         * @return {?}
         */
        CanvasOverlay.prototype.UpdatePosition = /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @param {?} x The horizontal offset position of the canvas.
         * @param {?} y The vertical offset position of the canvas.
         * @param {?} w The width of the canvas.
         * @param {?} h The height of the canvas.
         * @return {?}
         */
            function (x, y, w, h) {
                // Update CSS position.
                this._canvas.style.left = x + 'px';
                this._canvas.style.top = y + 'px';
                // Update CSS dimensions.
                this._canvas.style.width = w + 'px';
                this._canvas.style.height = h + 'px';
            };
        return CanvasOverlay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of a map layer for the Bing Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a map layer for the Bing Map Provider.
     *
     * @export
     */ BingLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the BingClusterLayer class.
         *
         * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof BingLayer
         */
        function BingLayer(_layer, _maps) {
            this._layer = _layer;
            this._maps = _maps;
            this._pendingEntities = new Array();
        }
        Object.defineProperty(BingLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof BingLayer
             * @return {?} Microsoft.Maps.Layer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        BingLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._layer, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Adds an entity to the layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.AddEntity = /**
         * Adds an entity to the layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity && entity.NativePrimitve) {
                    if (this.GetVisible()) {
                        this._layer.add(entity.NativePrimitve);
                    }
                    else {
                        this._pendingEntities.push(entity);
                    }
                }
            };
        /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.AddEntities = /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                //
                // use eachSeries as opposed to _layer.add([]) to provide a non-blocking experience for larger data sets.
                //
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    async.eachSeries(__spread(entities), function (e, next) {
                        if (_this.GetVisible()) {
                            _this._layer.add(e.NativePrimitve);
                        }
                        else {
                            _this._pendingEntities.push(e);
                        }
                        async.nextTick(function () { return next(); });
                    });
                }
            };
        /**
         * Deletes the layer.
         *
         * \@memberof BingLayer
         * @return {?}
         */
        BingLayer.prototype.Delete = /**
         * Deletes the layer.
         *
         * \@memberof BingLayer
         * @return {?}
         */
            function () {
                this._maps.DeleteLayer(this);
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        BingLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                /** @type {?} */
                var o = {
                    id: Number(this._layer.getId())
                };
                return o;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        BingLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._layer.getVisible();
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    this._layer.remove(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.
         * This replaces any existing entities.
         *
         * @return {?}
         */
        BingLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.
         * This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                //
                // we are using removal and add as opposed to set as for large number of objects it yields a non-blocking, smoother performance...
                //
                this._layer.setPrimitives([]);
                this.AddEntities(entities);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                this._layer.metadata.id = options.id.toString();
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                this._layer.setVisible(visible);
                if (visible && this._pendingEntities.length > 0) {
                    this.AddEntities(this._pendingEntities.splice(0));
                }
            };
        return BingLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This class contains helperfunctions to map various interfaces used to represent options and structures into the
     * corresponding Bing Maps V8 specific implementations.
     *
     * @export
     */
    var BingConversions = (function () {
        function BingConversions() {
        }
        /**
         * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} action - Object to be mapped.
         * @return {?} - Navtive mapped object.
         *
         */
        BingConversions.TranslateAction = /**
         * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} action - Object to be mapped.
         * @return {?} - Navtive mapped object.
         *
         */
            function (action) {
                /** @type {?} */
                var a = {
                    eventHandler: action.eventHandler,
                    label: action.label
                };
                return a;
            };
        /**
         * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} actions - Array of objects to be mapped.
         * @return {?} - Array of mapped objects.
         *
         */
        BingConversions.TranslateActions = /**
         * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} actions - Array of objects to be mapped.
         * @return {?} - Array of mapped objects.
         *
         */
            function (actions) {
                /** @type {?} */
                var a = new Array();
                actions.forEach(function (x) { return a.push(BingConversions.TranslateAction(x)); });
                return a;
            };
        /**
         * Maps an IBox object to a Microsoft.Maps.LocationRect object.
         *
         * \@memberof BingConversions
         * @param {?} box - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateBounds = /**
         * Maps an IBox object to a Microsoft.Maps.LocationRect object.
         *
         * \@memberof BingConversions
         * @param {?} box - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (box) {
                /** @type {?} */
                var r = Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);
                return r;
            };
        /**
         * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateClusterOptions = /**
         * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._clusterOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'layerOffset') {
                        o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);
                    }
                    if (k === 'placementMode') {
                        if (options.placementMode === ClusterPlacementMode.FirstPin) {
                            o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;
                        }
                        else {
                            o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;
                        }
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateInfoBoxOptions = /**
         * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'pixelOffset') {
                        o.offset = BingConversions.TranslatePoint(options.pixelOffset);
                    }
                    else if (k === 'position') {
                        o.location = BingConversions.TranslateLocation(options.position);
                    }
                    else if (k === 'actions') {
                        o.actions = BingConversions.TranslateActions(options.actions);
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateLoadOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) {
                    return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;
                })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        if (options.mapTypeId === MapTypeId.hybrid) {
                            o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                            o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;
                        }
                        else if (options.mapTypeId === MapTypeId.aerial) {
                            o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                            o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;
                        }
                        else {
                            o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                        }
                    }
                    else if (k === 'bounds') {
                        o.bounds = BingConversions.TranslateBounds(options.bounds);
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an ILatLong object to a Microsoft.Maps.Location object.
         *
         * \@memberof BingConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateLocation = /**
         * Maps an ILatLong object to a Microsoft.Maps.Location object.
         *
         * \@memberof BingConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                /** @type {?} */
                var l = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);
                return l;
            };
        /**
         * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - The mapped object.
         *
         */
        BingConversions.TranslateMarkerOptions = /**
         * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - The mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'anchor') {
                        o.anchor = BingConversions.TranslatePoint(options.anchor);
                    }
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._mapOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof BingConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
        BingConversions.TranslatePaths = /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof BingConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
            function (paths) {
                /** @type {?} */
                var p = new Array();
                if (paths == null || !Array.isArray(paths) || paths.length === 0) {
                    p.push(new Array());
                }
                else if (Array.isArray(paths[0])) {
                    /** @type {?} */
                    var p1 = (paths);
                    for (var i = 0; i < p1.length; i++) {
                        /** @type {?} */
                        var _p = new Array();
                        for (var j = 0; j < p1[i].length; j++) {
                            _p.push(new Microsoft.Maps.Location(p1[i][j].latitude, p1[i][j].longitude));
                        }
                        p.push(_p);
                    }
                }
                else {
                    /** @type {?} */
                    var y = new Array();
                    /** @type {?} */
                    var p1 = (paths);
                    for (var i = 0; i < p1.length; i++) {
                        y.push(new Microsoft.Maps.Location(p1[i].latitude, p1[i].longitude));
                    }
                    p.push(y);
                }
                return p;
            };
        /**
         *  Maps an IPoint object to a Microsoft.Maps.Point object.
         *
         * \@memberof BingConversions
         * @param {?} point - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePoint = /**
         *  Maps an IPoint object to a Microsoft.Maps.Point object.
         *
         * \@memberof BingConversions
         * @param {?} point - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (point) {
                /** @type {?} */
                var p = new Microsoft.Maps.Point(point.x, point.y);
                return p;
            };
        /**
         *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePolygonOptions = /**
         *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                /** @type {?} */
                var f = function (s, a) {
                    /** @type {?} */
                    var m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
                    if (m && m.length > 3) {
                        a = a > 1 ? (a / 100) : a;
                        return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
                    }
                    else if (s[0] === '#') {
                        /** @type {?} */
                        var z = s.substr(1);
                        /** @type {?} */
                        var r = parseInt(z.substr(0, 2), 16);
                        /** @type {?} */
                        var g = parseInt(z.substr(2, 2), 16);
                        /** @type {?} */
                        var b = parseInt(z.substr(4, 2), 16);
                        return 'rgba(' + [r, g, b, a].join(',') + ')';
                    }
                    else {
                        return s;
                    }
                };
                Object.keys(options)
                    .filter(function (k) { return BingConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'strokeWeight') {
                        o.strokeThickness = options.strokeWeight;
                    }
                    else if (k === 'strokeColor') {
                        if (options.strokeOpacity) {
                            o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                        }
                        else {
                            o.strokeColor = options.strokeColor;
                        }
                    }
                    else if (k === 'strokeOpacity') ;
                    else if (k === 'fillColor') {
                        if (options.fillOpacity) {
                            o.fillColor = f(options.fillColor, options.fillOpacity);
                        }
                        else {
                            o.fillColor = options.fillColor;
                        }
                    }
                    else if (k === 'fillOpacity') ;
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePolylineOptions = /**
         *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                /** @type {?} */
                var f = function (s, a) {
                    /** @type {?} */
                    var m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
                    if (m && m.length > 3) {
                        a = a > 1 ? (a / 100) : a;
                        return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
                    }
                    else if (s[0] === '#') {
                        /** @type {?} */
                        var z = s.substr(1);
                        /** @type {?} */
                        var r = parseInt(z.substr(0, 2), 16);
                        /** @type {?} */
                        var g = parseInt(z.substr(2, 2), 16);
                        /** @type {?} */
                        var b = parseInt(z.substr(4, 2), 16);
                        return 'rgba(' + [r, g, b, a].join(',') + ')';
                    }
                    else {
                        return s;
                    }
                };
                Object.keys(options)
                    .filter(function (k) { return BingConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'strokeWeight') {
                        o.strokeThickness = options.strokeWeight;
                    }
                    else if (k === 'strokeColor') {
                        if (options.strokeOpacity) {
                            o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                        }
                        else {
                            o.strokeColor = options.strokeColor;
                        }
                    }
                    else if (k === 'strokeOpacity') ;
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateViewOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._viewOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'bounds') {
                        o.bounds = BingConversions.TranslateBounds(options.bounds);
                    }
                    else if (k === 'centerOffset') {
                        o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Map option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._mapOptionsAttributes = [
            'backgroundColor',
            'credentials',
            'customizeOverlays',
            'customMapStyle',
            'disableBirdseye',
            'disableKeyboardInput',
            'disableMouseInput',
            'disablePanning',
            'disableTouchInput',
            'disableUserInput',
            'disableZooming',
            'disableStreetside',
            'enableClickableLogo',
            'enableSearchLogo',
            'fixedMapPosition',
            'height',
            'inertiaIntensity',
            'navigationBarMode',
            'showBreadcrumb',
            'showCopyright',
            'showDashboard',
            'showMapTypeSelector',
            'showScalebar',
            'theme',
            'tileBuffer',
            'useInertia',
            'width',
            'center',
            'zoom',
            'mapTypeId',
            'liteMode'
        ];
        /**
         * View option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._viewOptionsAttributes = [
            'animate',
            'bounds',
            'center',
            'centerOffset',
            'heading',
            'labelOverlay',
            'mapTypeId',
            'padding',
            'zoom'
        ];
        /**
         * InfoWindow option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._infoWindowOptionsAttributes = [
            'actions',
            'description',
            'htmlContent',
            'id',
            'position',
            'pixelOffset',
            'showCloseButton',
            'showPointer',
            'pushpin',
            'title',
            'titleClickHandler',
            'typeName',
            'visible',
            'width',
            'height'
        ];
        /**
         * Marker option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._markerOptionsAttributes = [
            'anchor',
            'draggable',
            'height',
            'htmlContent',
            'icon',
            'infobox',
            'state',
            'title',
            'textOffset',
            'typeName',
            'visible',
            'width',
            'zIndex'
        ];
        /**
         * Polygon option attributes that are supported for conversion to Bing Map Polygon properties
         *
         * \@memberof BingConversions
         */
        BingConversions._polygonOptionsAttributes = [
            'cursor',
            'fillColor',
            'fillOpacity',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible'
        ];
        /**
         * Polyline option attributes that are supported for conversion to Bing Map Polyline properties
         *
         * \@memberof BingConversions
         */
        BingConversions._polylineOptionsAttributes = [
            'cursor',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible'
        ];
        /**
         * Cluster option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._clusterOptionsAttributes = [
            'callback',
            'clusteredPinCallback',
            'clusteringEnabled',
            'gridSize',
            'layerOffset',
            'placementMode',
            'visible',
            'zIndex'
        ];
        return BingConversions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link Marker} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link Marker} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */ BingMarker = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMarker.
         * @param _pushpin - The {@link Microsoft.Maps.Pushpin} underlying the model.
         * @param _map - The context map.
         * @param _layer - The context layer.
         *
         * @memberof BingMarker
         */
        function BingMarker(_pushpin, _map, _layer) {
            this._pushpin = _pushpin;
            this._map = _map;
            this._layer = _layer;
            this._metadata = new Map();
            this._isFirst = false;
            this._isLast = true;
        }
        Object.defineProperty(BingMarker.prototype, "IsFirst", {
            get: /**
             * Indicates that the marker is the first marker in a set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isFirst; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isFirst = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "IsLast", {
            get: /**
             * Indicates that the marker is the last marker in the set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isLast; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isLast = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "Location", {
            get: /**
             * Gets the Location of the marker
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () {
                /** @type {?} */
                var l = this._pushpin.getLocation();
                return {
                    latitude: l.latitude,
                    longitude: l.longitude
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "Metadata", {
            get: /**
             * Gets the marker metadata.
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link Microsoft.Maps.Pushpin}
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._pushpin; },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        BingMarker.prototype.AddListener = /**
         * Adds an event listener to the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._pushpin, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Deletes the marker.
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
        BingMarker.prototype.DeleteMarker = /**
         * Deletes the marker.
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
            function () {
                if (!this._map && !this._layer) {
                    return;
                }
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
            };
        /**
         * Gets the marker label
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
        BingMarker.prototype.GetLabel = /**
         * Gets the marker label
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
            function () {
                return this._pushpin.getText();
            };
        /**
         * Gets whether the marker is visible.
         *
         * \@memberof BingMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
        BingMarker.prototype.GetVisible = /**
         * Gets whether the marker is visible.
         *
         * \@memberof BingMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
            function () {
                return this._pushpin.getVisible();
            };
        /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
        BingMarker.prototype.SetAnchor = /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
            function (anchor) {
                /** @type {?} */
                var o = {};
                o.anchor = new Microsoft.Maps.Point(anchor.x, anchor.y);
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the draggability of a marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
        BingMarker.prototype.SetDraggable = /**
         * Sets the draggability of a marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                /** @type {?} */
                var o = {};
                o.draggable = draggable;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the icon for the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
        BingMarker.prototype.SetIcon = /**
         * Sets the icon for the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
            function (icon) {
                /** @type {?} */
                var o = {};
                o.icon = icon;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker label.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
        BingMarker.prototype.SetLabel = /**
         * Sets the marker label.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
            function (label) {
                /** @type {?} */
                var o = {};
                o.text = label;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker position.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
        BingMarker.prototype.SetPosition = /**
         * Sets the marker position.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
            function (latLng) {
                /** @type {?} */
                var p = BingConversions.TranslateLocation(latLng);
                this._pushpin.setLocation(p);
            };
        /**
         * Sets the marker title.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
        BingMarker.prototype.SetTitle = /**
         * Sets the marker title.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
            function (title) {
                /** @type {?} */
                var o = {};
                o.title = title;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker options.
         *
         * @abstract
         * \@memberof Marker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         * @return {?}
         */
        BingMarker.prototype.SetOptions = /**
         * Sets the marker options.
         *
         * @abstract
         * \@memberof Marker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = BingConversions.TranslateMarkerOptions(options);
                this._pushpin.setOptions(o);
            };
        /**
         * Sets whether the marker is visible.
         *
         * \@memberof Marker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
        BingMarker.prototype.SetVisible = /**
         * Sets whether the marker is visible.
         *
         * \@memberof Marker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                /** @type {?} */
                var o = {};
                o.visible = visible;
                this._pushpin.setOptions(o);
            };
        return BingMarker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var BingSpiderClusterMarker = (function (_super) {
        __extends(BingSpiderClusterMarker, _super);
        function BingSpiderClusterMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BingSpiderClusterMarker;
    }(BingMarker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of a clustering layer for the Bing Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a clustering layer for the Bing Map Provider.
     *
     * @export
     */ BingClusterLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the BingClusterLayer class.
         *
         * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof BingClusterLayer
         */
        function BingClusterLayer(_layer, _maps) {
            this._layer = _layer;
            this._maps = _maps;
            this._isClustering = true;
            this._markers = new Array();
            this._markerLookup = new Map();
            this._pendingMarkers = new Array();
            this._spiderMarkers = new Array();
            this._spiderMarkerLookup = new Map();
            this._useSpiderCluster = false;
            this._mapclicks = 0;
            this._events = new Array();
            this._currentZoom = 0;
            this._spiderOptions = {
                circleSpiralSwitchover: 9,
                collapseClusterOnMapChange: false,
                collapseClusterOnNthClick: 1,
                invokeClickOnHover: true,
                minCircleLength: 60,
                minSpiralAngleSeperation: 25,
                spiralDistanceFactor: 5,
                stickStyle: {
                    strokeColor: 'black',
                    strokeThickness: 2
                },
                stickHoverStyle: { strokeColor: 'red' },
                markerSelected: null,
                markerUnSelected: null
            };
            this._currentCluster = null;
        }
        Object.defineProperty(BingClusterLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof BingClusterLayer
             * @return {?} Microsoft.Maps.ClusterLayer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._layer, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                /** @type {?} */
                var isMarker = entity instanceof Marker;
                isMarker = entity instanceof BingMarker || isMarker;
                if (isMarker) {
                    if (entity.IsFirst) {
                        this.StopClustering();
                    }
                }
                if (entity.NativePrimitve && entity.Location) {
                    if (this._isClustering) {
                        /** @type {?} */
                        var p = this._layer.getPushpins();
                        p.push(entity.NativePrimitve);
                        this._layer.setPushpins(p);
                        this._markers.push(entity);
                    }
                    else {
                        this._pendingMarkers.push(entity);
                    }
                    this._markerLookup.set(entity.NativePrimitve, entity);
                }
                if (isMarker) {
                    if (entity.IsLast) {
                        this.StartClustering();
                    }
                }
            };
        /**
         * Adds a number of markers to the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddEntities = /**
         * Adds a number of markers to the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    /** @type {?} */
                    var e = entities.map(function (p) {
                        _this._markerLookup.set(p.NativePrimitve, p);
                        return p.NativePrimitve;
                    });
                    if (this._isClustering) {
                        /** @type {?} */
                        var p = this._layer.getPushpins();
                        p.push.apply(p, __spread(e));
                        this._layer.setPushpins(p);
                        (_a = this._markers).push.apply(_a, __spread(entities));
                    }
                    else {
                        (_b = this._pendingMarkers).push.apply(_b, __spread(entities));
                    }
                }
                var _a, _b;
            };
        /**
         * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the
         * individual underlying pins.
         *
         * \@memberof BingClusterLayer
         * @param {?=} options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.InitializeSpiderClusterSupport = /**
         * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the
         * individual underlying pins.
         *
         * \@memberof BingClusterLayer
         * @param {?=} options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.
         *
         * @return {?}
         */
            function (options) {
                var _this = this;
                if (this._useSpiderCluster) {
                    return;
                }
                /** @type {?} */
                var m = ((this._maps)).MapInstance;
                this._useSpiderCluster = true;
                this._spiderLayer = new Microsoft.Maps.Layer();
                this._currentZoom = m.getZoom();
                this.SetSpiderOptions(options);
                m.layers.insert(this._spiderLayer);
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'click', function (e) { return _this.OnMapClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangestart', function (e) { return _this.OnMapViewChangeStart(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) { return _this.OnMapViewChangeEnd(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._layer, 'click', function (e) { return _this.OnLayerClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'click', function (e) { return _this.OnLayerClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseover', function (e) { return _this.OnSpiderMouseOver(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseout', function (e) { return _this.OnSpiderMouseOut(e); }));
            };
        /**
         * Deletes the clustering layer.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.Delete = /**
         * Deletes the clustering layer.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._useSpiderCluster) {
                    this._spiderLayer.clear();
                    ((this._maps)).MapPromise.then(function (m) {
                        m.layers.remove(_this._spiderLayer);
                        _this._spiderLayer = null;
                    });
                    this._events.forEach(function (e) { return Microsoft.Maps.Events.removeHandler(e); });
                    this._events.splice(0);
                    this._useSpiderCluster = false;
                }
                this._markers.splice(0);
                this._spiderMarkers.splice(0);
                this._pendingMarkers.splice(0);
                this._markerLookup.clear();
                this._maps.DeleteLayer(this);
            };
        /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
        BingClusterLayer.prototype.GetMarkerFromBingMarker = /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                /** @type {?} */
                var m = this._markerLookup.get(pin);
                return m;
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        BingClusterLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                /** @type {?} */
                var o = this._layer.getOptions();
                /** @type {?} */
                var options = {
                    id: 0,
                    gridSize: o.gridSize,
                    layerOffset: o.layerOffset,
                    clusteringEnabled: o.clusteringEnabled,
                    callback: o.callback,
                    clusteredPinCallback: o.clusteredPinCallback,
                    visible: o.visible,
                    zIndex: o.zIndex
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        BingClusterLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._layer.getOptions().visible;
            };
        /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} - The abstract marker object representing the pushpin.
         *
         */
        BingClusterLayer.prototype.GetSpiderMarkerFromBingMarker = /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} - The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                /** @type {?} */
                var m = this._spiderMarkerLookup.get(pin);
                return m;
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker - Entity to be removed from the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker - Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve && entity.Location) {
                    /** @type {?} */
                    var j = this._markers.indexOf(entity);
                    /** @type {?} */
                    var k = this._pendingMarkers.indexOf(entity);
                    if (j > -1) {
                        this._markers.splice(j, 1);
                    }
                    if (k > -1) {
                        this._pendingMarkers.splice(k, 1);
                    }
                    if (this._isClustering) {
                        /** @type {?} */
                        var p = this._layer.getPushpins();
                        /** @type {?} */
                        var i = p.indexOf(entity.NativePrimitve);
                        if (i > -1) {
                            p.splice(i, 1);
                            this._layer.setPushpins(p);
                        }
                    }
                    this._markerLookup.delete(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                /** @type {?} */
                var p = new Array();
                this._markers.splice(0);
                this._markerLookup.clear();
                entities.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        _this._markers.push(e);
                        _this._markerLookup.set(e.NativePrimitve, e);
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._layer.setPushpins(p);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = BingConversions.TranslateClusterOptions(options);
                this._layer.setOptions(o);
                if (options.spiderClusterOptions) {
                    this.SetSpiderOptions(options.spiderClusterOptions);
                }
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingClusterLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingClusterLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                /** @type {?} */
                var o = this._layer.getOptions();
                o.visible = visible;
                this._layer.setOptions(o);
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                if (this._isClustering) {
                    return;
                }
                /** @type {?} */
                var p = new Array();
                this._markers.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._pendingMarkers.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._layer.setPushpins(p);
                this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                this._isClustering = true;
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                if (!this._isClustering) {
                    return;
                }
                this._isClustering = false;
            };
        /**
         * Creates a copy of a pushpins basic options.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin Pushpin to copy options from.
         * @return {?} - A copy of a pushpins basic options.
         *
         */
        BingClusterLayer.prototype.GetBasicPushpinOptions = /**
         * Creates a copy of a pushpins basic options.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin Pushpin to copy options from.
         * @return {?} - A copy of a pushpins basic options.
         *
         */
            function (pin) {
                return /** @type {?} */ ({
                    anchor: pin.getAnchor(),
                    color: pin.getColor(),
                    cursor: pin.getCursor(),
                    icon: pin.getIcon(),
                    roundClickableArea: pin.getRoundClickableArea(),
                    subTitle: pin.getSubTitle(),
                    text: pin.getText(),
                    textOffset: pin.getTextOffset(),
                    title: pin.getTitle()
                });
            };
        /**
         * Hides the spider cluster and resotres the original pin.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.HideSpiderCluster = /**
         * Hides the spider cluster and resotres the original pin.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                this._mapclicks = 0;
                if (this._currentCluster) {
                    this._spiderLayer.clear();
                    this._spiderMarkers.splice(0);
                    this._spiderMarkerLookup.clear();
                    this._currentCluster = null;
                    this._mapclicks = -1;
                    if (this._spiderOptions.markerUnSelected) {
                        this._spiderOptions.markerUnSelected();
                    }
                }
            };
        /**
         * Click event handler for when a shape in the cluster layer is clicked.
         *
         * \@memberof BingClusterLayer
         * @param {?} e The mouse event argurment from the click event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnLayerClick = /**
         * Click event handler for when a shape in the cluster layer is clicked.
         *
         * \@memberof BingClusterLayer
         * @param {?} e The mouse event argurment from the click event.
         *
         * @return {?}
         */
            function (e) {
                if (e.primitive instanceof Microsoft.Maps.ClusterPushpin) {
                    /** @type {?} */
                    var cp = (e.primitive);
                    /** @type {?} */
                    var showNewCluster = cp !== this._currentCluster;
                    this.HideSpiderCluster();
                    if (showNewCluster) {
                        this.ShowSpiderCluster(/** @type {?} */ (e.primitive));
                    }
                }
                else {
                    /** @type {?} */
                    var pin = (e.primitive);
                    if (pin.metadata && pin.metadata.isClusterMarker) {
                        /** @type {?} */
                        var m = this.GetSpiderMarkerFromBingMarker(pin);
                        /** @type {?} */
                        var p = m.ParentMarker;
                        /** @type {?} */
                        var ppin = p.NativePrimitve;
                        if (this._spiderOptions.markerSelected) {
                            this._spiderOptions.markerSelected(p, new BingMarker(this._currentCluster, null, null));
                        }
                        if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) {
                            Microsoft.Maps.Events.invoke(ppin, 'click', e);
                        }
                        this._mapclicks = 0;
                    }
                    else {
                        if (this._spiderOptions.markerSelected) {
                            this._spiderOptions.markerSelected(this.GetMarkerFromBingMarker(pin), null);
                        }
                        if (Microsoft.Maps.Events.hasHandler(pin, 'click')) {
                            Microsoft.Maps.Events.invoke(pin, 'click', e);
                        }
                    }
                }
            };
        /**
         * Delegate handling the click event on the map (outside a spider cluster). Depending on the
         * spider options, closes the cluster or increments the click counter.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapClick = /**
         * Delegate handling the click event on the map (outside a spider cluster). Depending on the
         * spider options, closes the cluster or increments the click counter.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event
         *
         * @return {?}
         */
            function (e) {
                if (this._mapclicks === -1) {
                    return;
                }
                else if (++this._mapclicks >= this._spiderOptions.collapseClusterOnNthClick) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapViewChangeEnd = /**
         * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
            function (e) {
                /** @type {?} */
                var z = ((e.target)).getZoom();
                /** @type {?} */
                var hasZoomChanged = (z !== this._currentZoom);
                this._currentZoom = z;
                if (hasZoomChanged) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate handling the map view change start event. Depending on the spider options, hides the
         * the exploded spider or does nothing.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapViewChangeStart = /**
         * Delegate handling the map view change start event. Depending on the spider options, hides the
         * the exploded spider or does nothing.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
            function (e) {
                if (this._spiderOptions.collapseClusterOnMapChange) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
        BingClusterLayer.prototype.OnSpiderMouseOut = /**
         * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
            function (e) {
                /** @type {?} */
                var pin = (e.primitive);
                if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {
                    /** @type {?} */
                    var m = this.GetSpiderMarkerFromBingMarker(pin);
                    m.Stick.setOptions(this._spiderOptions.stickStyle);
                }
            };
        /**
         * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event
         * on the underlying original marker dependent on the spider options.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
        BingClusterLayer.prototype.OnSpiderMouseOver = /**
         * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event
         * on the underlying original marker dependent on the spider options.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
            function (e) {
                /** @type {?} */
                var pin = (e.primitive);
                if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {
                    /** @type {?} */
                    var m = this.GetSpiderMarkerFromBingMarker(pin);
                    m.Stick.setOptions(this._spiderOptions.stickHoverStyle);
                    if (this._spiderOptions.invokeClickOnHover) {
                        /** @type {?} */
                        var p = m.ParentMarker;
                        /** @type {?} */
                        var ppin = p.NativePrimitve;
                        if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) {
                            Microsoft.Maps.Events.invoke(ppin, 'click', e);
                        }
                    }
                }
            };
        /**
         * Sets the options for spider behavior.
         *
         * \@memberof BingClusterLayer
         * @param {?} options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetSpiderOptions = /**
         * Sets the options for spider behavior.
         *
         * \@memberof BingClusterLayer
         * @param {?} options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                if (options) {
                    if (typeof options.circleSpiralSwitchover === 'number') {
                        this._spiderOptions.circleSpiralSwitchover = options.circleSpiralSwitchover;
                    }
                    if (typeof options.collapseClusterOnMapChange === 'boolean') {
                        this._spiderOptions.collapseClusterOnMapChange = options.collapseClusterOnMapChange;
                    }
                    if (typeof options.collapseClusterOnNthClick === 'number') {
                        this._spiderOptions.collapseClusterOnNthClick = options.collapseClusterOnNthClick;
                    }
                    if (typeof options.invokeClickOnHover === 'boolean') {
                        this._spiderOptions.invokeClickOnHover = options.invokeClickOnHover;
                    }
                    if (typeof options.minSpiralAngleSeperation === 'number') {
                        this._spiderOptions.minSpiralAngleSeperation = options.minSpiralAngleSeperation;
                    }
                    if (typeof options.spiralDistanceFactor === 'number') {
                        this._spiderOptions.spiralDistanceFactor = options.spiralDistanceFactor;
                    }
                    if (typeof options.minCircleLength === 'number') {
                        this._spiderOptions.minCircleLength = options.minCircleLength;
                    }
                    if (options.stickHoverStyle) {
                        this._spiderOptions.stickHoverStyle = options.stickHoverStyle;
                    }
                    if (options.stickStyle) {
                        this._spiderOptions.stickStyle = options.stickStyle;
                    }
                    if (options.markerSelected) {
                        this._spiderOptions.markerSelected = options.markerSelected;
                    }
                    if (options.markerUnSelected) {
                        this._spiderOptions.markerUnSelected = options.markerUnSelected;
                    }
                    if (typeof options.visible === 'boolean') {
                        this._spiderOptions.visible = options.visible;
                    }
                    this.SetOptions(/** @type {?} */ (options));
                }
            };
        /**
         * Expands a cluster into it's open spider layout.
         *
         * \@memberof BingClusterLayer
         * @param {?} cluster The cluster to show in it's open spider layout..
         *
         * @return {?}
         */
        BingClusterLayer.prototype.ShowSpiderCluster = /**
         * Expands a cluster into it's open spider layout.
         *
         * \@memberof BingClusterLayer
         * @param {?} cluster The cluster to show in it's open spider layout..
         *
         * @return {?}
         */
            function (cluster) {
                this.HideSpiderCluster();
                this._currentCluster = cluster;
                if (cluster && cluster.containedPushpins) {
                    /** @type {?} */
                    var m = ((this._maps)).MapInstance;
                    /** @type {?} */
                    var pins = cluster.containedPushpins;
                    /** @type {?} */
                    var center = cluster.getLocation();
                    /** @type {?} */
                    var centerPoint = (m.tryLocationToPixel(center, Microsoft.Maps.PixelReference.control));
                    /** @type {?} */
                    var stick = void 0;
                    /** @type {?} */
                    var angle = 0;
                    /** @type {?} */
                    var makeSpiral = pins.length > this._spiderOptions.circleSpiralSwitchover;
                    /** @type {?} */
                    var legPixelLength = void 0;
                    /** @type {?} */
                    var stepAngle = void 0;
                    /** @type {?} */
                    var stepLength = void 0;
                    if (makeSpiral) {
                        legPixelLength = this._spiderOptions.minCircleLength / Math.PI;
                        stepLength = 2 * Math.PI * this._spiderOptions.spiralDistanceFactor;
                    }
                    else {
                        stepAngle = 2 * Math.PI / pins.length;
                        legPixelLength = (this._spiderOptions.spiralDistanceFactor / stepAngle / Math.PI / 2) * pins.length;
                        if (legPixelLength < this._spiderOptions.minCircleLength) {
                            legPixelLength = this._spiderOptions.minCircleLength;
                        }
                    }
                    for (var i = 0, len = pins.length; i < len; i++) {
                        // Calculate spider pin location.
                        if (!makeSpiral) {
                            angle = stepAngle * i;
                        }
                        else {
                            angle += this._spiderOptions.minSpiralAngleSeperation / legPixelLength + i * 0.0005;
                            legPixelLength += stepLength / angle;
                        }
                        /** @type {?} */
                        var point = new Microsoft.Maps.Point(centerPoint.x + legPixelLength * Math.cos(angle), centerPoint.y + legPixelLength * Math.sin(angle));
                        /** @type {?} */
                        var loc = (m.tryPixelToLocation(point, Microsoft.Maps.PixelReference.control));
                        // Create stick to pin.
                        stick = new Microsoft.Maps.Polyline([center, loc], this._spiderOptions.stickStyle);
                        this._spiderLayer.add(stick);
                        /** @type {?} */
                        var pin = new Microsoft.Maps.Pushpin(loc);
                        pin.metadata = pins[i].metadata || {};
                        pin.metadata.isClusterMarker = true;
                        pin.setOptions(this.GetBasicPushpinOptions(pins[i]));
                        this._spiderLayer.add(pin);
                        /** @type {?} */
                        var spiderMarker = new BingSpiderClusterMarker(pin, null, this._spiderLayer);
                        spiderMarker.Stick = stick;
                        spiderMarker.ParentMarker = /** @type {?} */ (this.GetMarkerFromBingMarker(pins[i]));
                        this._spiderMarkers.push(spiderMarker);
                        this._spiderMarkerLookup.set(pin, spiderMarker);
                    }
                    this._mapclicks = 0;
                }
            };
        return BingClusterLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link InfoWindow} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link InfoWindow} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */ BingInfoWindow = (function () {
        /**
         * Creates an instance of BingInfoWindow.
         * @param _infoBox - A {@link Microsoft.Maps.Infobox} instance underlying the model
         * @memberof BingInfoWindow
         */
        function BingInfoWindow(_infoBox) {
            this._infoBox = _infoBox;
            this._isOpen = false;
        }
        Object.defineProperty(BingInfoWindow.prototype, "IsOpen", {
            get: /**
             * Gets whether the info box is currently open.
             *
             * \@readonly
             * \@memberof BingInfoWindow
             * @return {?}
             */ function () {
                if (this._infoBox && this._infoBox.getOptions().visible === true) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingInfoWindow.prototype, "NativePrimitve", {
            get: /**
             * Gets native primitve underlying the model.
             *
             * \@memberof BingInfoWindow
             * \@property
             * \@readonly
             * @return {?}
             */ function () {
                return this._infoBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.AddListener = /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this._infoBox, eventType, function (e) {
                    if (e.eventName === 'infoboxChanged') {
                        if (_this._infoBox.getOptions().visible === true) {
                            _this._isOpen = true;
                        }
                        else {
                            if (_this._infoBox.getOptions().visible === false && _this._isOpen === true) {
                                _this._isOpen = false;
                                fn(e);
                            }
                        }
                    }
                    else {
                        fn(e);
                    }
                });
            };
        /**
         * Closes the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
        BingInfoWindow.prototype.Close = /**
         * Closes the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                /** @type {?} */
                var o = {};
                o.visible = false;
                this._infoBox.setOptions(o);
            };
        /**
         * Gets the position of the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?} - Returns the geo coordinates of the info window.
         */
        BingInfoWindow.prototype.GetPosition = /**
         * Gets the position of the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?} - Returns the geo coordinates of the info window.
         */
            function () {
                /** @type {?} */
                var p = {
                    latitude: this._infoBox.getLocation().latitude,
                    longitude: this._infoBox.getLocation().longitude
                };
                return p;
            };
        /**
         * Opens the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
        BingInfoWindow.prototype.Open = /**
         * Opens the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                /** @type {?} */
                var o = {};
                o.visible = true;
                this._infoBox.setOptions(o);
            };
        /**
         * Sets the info window options.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} options - Info window options to set. The options will be merged with any existing options.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.SetOptions = /**
         * Sets the info window options.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} options - Info window options to set. The options will be merged with any existing options.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = BingConversions.TranslateInfoBoxOptions(options);
                this._infoBox.setOptions(o);
            };
        /**
         * Sets the info window position.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} position - Geo coordinates to move the anchor of the info window to.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.SetPosition = /**
         * Sets the info window position.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} position - Geo coordinates to move the anchor of the info window to.
         *
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var l = BingConversions.TranslateLocation(position);
                this._infoBox.setLocation(l);
            };
        return BingInfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract base implementing a label to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract base implementing a label to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */ MapLabel = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function MapLabel(options) {
            this.Set('fontFamily', 'sans-serif');
            this.Set('fontSize', 12);
            this.Set('fontColor', '#ffffff');
            this.Set('strokeWeight', 4);
            this.Set('strokeColor', '#000000');
            this.Set('align', 'center');
            this.SetValues(options);
        }
        /**
         * Deletes the label from the map. This method does not atually delete the label itself, so
         * it can be readded to map later.
         * \@memberof MapLabel
         * \@method
         * @return {?}
         */
        MapLabel.prototype.Delete = /**
         * Deletes the label from the map. This method does not atually delete the label itself, so
         * it can be readded to map later.
         * \@memberof MapLabel
         * \@method
         * @return {?}
         */
            function () {
                this.SetMap(null);
            };
        /**
         * Delegate called when underlying properties change.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} prop - The property or properties that have changed.
         * @return {?}
         */
        MapLabel.prototype.Changed = /**
         * Delegate called when underlying properties change.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} prop - The property or properties that have changed.
         * @return {?}
         */
            function (prop) {
                /** @type {?} */
                var shouldRunDrawCanvas = false;
                /** @type {?} */
                var shouldRunDraw = false;
                if (!Array.isArray(prop)) {
                    prop = [prop];
                }
                prop.forEach(function (p) {
                    switch (p) {
                        case 'fontFamily':
                        case 'fontSize':
                        case 'fontColor':
                        case 'strokeWeight':
                        case 'strokeColor':
                        case 'align':
                        case 'text':
                            shouldRunDrawCanvas = true;
                            break;
                        case 'maxZoom':
                        case 'minZoom':
                        case 'offset':
                        case 'hidden':
                        case 'position':
                            shouldRunDraw = true;
                            break;
                    }
                });
                if (shouldRunDrawCanvas) {
                    this.DrawCanvas();
                }
                if (shouldRunDraw) {
                    this.Draw();
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @returns - blank string if visible, 'hidden' if invisible.
         * @protected
         */
        /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @protected
         * @return {?} - blank string if visible, 'hidden' if invisible.
         */
        MapLabel.prototype.GetVisible = /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @protected
         * @return {?} - blank string if visible, 'hidden' if invisible.
         */
            function () {
                /** @type {?} */
                var minZoom = this.Get('minZoom');
                /** @type {?} */
                var maxZoom = this.Get('maxZoom');
                /** @type {?} */
                var hidden = this.Get('hidden');
                if (hidden) {
                    return 'hidden';
                }
                if (minZoom === undefined && maxZoom === undefined) {
                    return '';
                }
                if (!this.GetMap()) {
                    return '';
                }
                /** @type {?} */
                var mapZoom = this.GetMap().getZoom();
                if (mapZoom < minZoom || mapZoom > maxZoom) {
                    return 'hidden';
                }
                return '';
            };
        /**
         * Draws the label to the canvas 2d context.
         * @memberof MapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label to the canvas 2d context.
         * \@memberof MapLabel
         * \@method
         * @protected
         * @return {?}
         */
        MapLabel.prototype.DrawCanvas = /**
         * Draws the label to the canvas 2d context.
         * \@memberof MapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                if (!this._canvas) {
                    return;
                }
                /** @type {?} */
                var style = this._canvas.style;
                style.zIndex = this.Get('zIndex');
                /** @type {?} */
                var ctx = this._canvas.getContext('2d');
                ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
                ctx.strokeStyle = this.Get('strokeColor');
                ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');
                /** @type {?} */
                var backgroundColor = this.Get('backgroundColor');
                /** @type {?} */
                var strokeWeight = Number(this.Get('strokeWeight'));
                /** @type {?} */
                var text = this.Get('text');
                /** @type {?} */
                var textMeasure = ctx.measureText(text);
                /** @type {?} */
                var textWidth = textMeasure.width;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, 4, 4);
                }
                if (backgroundColor && backgroundColor !== '') {
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(0, 0, textWidth + 8, (parseInt(ctx.font, 10) * 2) - 2);
                }
                ctx.fillStyle = this.Get('fontColor');
                ctx.fillText(text, 4, 4);
                style.marginLeft = this.GetMarginLeft(textWidth) + 'px';
                style.marginTop = '-0.4em';
                style.pointerEvents = 'none';
                // Bring actual text top in line with desired latitude.
                // Cheaper than calculating height of text.
            };
        /**
         * Gets the appropriate margin-left for the canvas.
         * @param textWidth  - The width of the text, in pixels.
         * @returns - The margin-left, in pixels.
         * @protected
         * @method
         * @memberof MapLabel
         */
        /**
         * Gets the appropriate margin-left for the canvas.
         * @protected
         * \@method
         * \@memberof MapLabel
         * @param {?} textWidth  - The width of the text, in pixels.
         * @return {?} - The margin-left, in pixels.
         */
        MapLabel.prototype.GetMarginLeft = /**
         * Gets the appropriate margin-left for the canvas.
         * @protected
         * \@method
         * \@memberof MapLabel
         * @param {?} textWidth  - The width of the text, in pixels.
         * @return {?} - The margin-left, in pixels.
         */
            function (textWidth) {
                switch (this.Get('align')) {
                    case 'left': return 0;
                    case 'right': return -textWidth;
                }
                return textWidth / -2;
            };
        /**
         * Called when the label is removed from the map.
         * @method
         * @protected
         * @memberof MapLabel
         */
        /**
         * Called when the label is removed from the map.
         * \@method
         * @protected
         * \@memberof MapLabel
         * @return {?}
         */
        MapLabel.prototype.OnRemove = /**
         * Called when the label is removed from the map.
         * \@method
         * @protected
         * \@memberof MapLabel
         * @return {?}
         */
            function () {
                if (this._canvas && this._canvas.parentNode) {
                    this._canvas.parentNode.removeChild(this._canvas);
                }
            };
        return MapLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Extender = (function () {
        function Extender(obj) {
            this._obj = obj;
            this._proto = obj.prototype;
        }
        /**
         * @param {?} newObj
         * @return {?}
         */
        Extender.prototype.Extend = /**
         * @param {?} newObj
         * @return {?}
         */
            function (newObj) {
                this.Set('prototype', newObj, this._obj);
                for (var y in this._proto) {
                    if (((this._proto))[y] != null) {
                        this.Set(y, (this._proto)[y], ((this._obj.prototype))[y]);
                    }
                }
                return this;
            };
        /**
         * @param {?} property
         * @param {?} newObj
         * @param {?=} obj
         * @return {?}
         */
        Extender.prototype.Set = /**
         * @param {?} property
         * @param {?} newObj
         * @param {?=} obj
         * @return {?}
         */
            function (property, newObj, obj) {
                if (typeof newObj === 'undefined') {
                    return this;
                }
                if (typeof obj === 'undefined') {
                    obj = this._proto;
                }
                Object.defineProperty(obj, property, newObj);
            };
        /**
         * @param {?} property
         * @param {?} newProperty
         * @return {?}
         */
        Extender.prototype.Map = /**
         * @param {?} property
         * @param {?} newProperty
         * @return {?}
         */
            function (property, newProperty) {
                this.Set(property, this._proto[newProperty], this._obj.prototype);
                return this;
            };
        return Extender;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var id$1 = 0;
    /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */
    var /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */ BingMapLabel = (function (_super) {
        __extends(BingMapLabel, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function BingMapLabel(options) {
            var _this = this;
            options["fontSize"] = options["fontSize"] || 12;
            options["fontColor"] = options["fontColor"] || '#ffffff';
            options["strokeWeight"] = options["strokeWeight"] || 2;
            options["strokeColor"] = options["strokeColor"] || '#000000';
            _this = _super.call(this, options) || this;
            ((_this))._options.beneathLabels = false;
            return _this;
        }
        Object.defineProperty(BingMapLabel.prototype, "DefaultLabelStyle", {
            get: /**
             * Returns the default label style for the platform
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapLabel
             * @return {?}
             */ function () {
                return {
                    fontSize: 12,
                    fontFamily: 'sans-serif',
                    fontColor: '#ffffff',
                    strokeWeight: 2,
                    strokeColor: '#000000'
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
        BingMapLabel.prototype.Get = /**
         * Gets the value of a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
            function (key) {
                return ((this))[key];
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
        BingMapLabel.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
            function () {
                if (typeof ((this)).getMap === 'function') {
                    return ((this)).getMap();
                }
                return null;
            };
        /**
         * Set the value for a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
        BingMapLabel.prototype.Set = /**
         * Set the value for a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
            function (key, val) {
                if (key === 'position' && !val.hasOwnProperty('altitude') && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {
                    val = new Microsoft.Maps.Location(val.latitude, val.longitude);
                }
                if (this.Get(key) !== val) {
                    ((this))[key] = val;
                    this.Changed(key);
                }
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        BingMapLabel.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                /** @type {?} */
                var m = this.GetMap();
                if (map === m) {
                    return;
                }
                if (m) {
                    m.layers.remove(this);
                }
                if (map != null) {
                    map.layers.insert(this);
                }
            };
        /**
         * Applies settings to the object
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
        BingMapLabel.prototype.SetValues = /**
         * Applies settings to the object
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var p = new Array();
                for (var key in options) {
                    if (key !== '') {
                        if (key === 'position' && !options[key].hasOwnProperty('altitude') &&
                            options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {
                            options[key] = new Microsoft.Maps.Location(options[key].latitude, options[key].longitude);
                        }
                        if (this.Get(key) !== options[key]) {
                            ((this))[key] = options[key];
                            p.push(key);
                        }
                    }
                }
                if (p.length > 0) {
                    this.Changed(p);
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Draws the label on the map.
         * @memberof BingMapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label on the map.
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        BingMapLabel.prototype.Draw = /**
         * Draws the label on the map.
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var visibility = this.GetVisible();
                /** @type {?} */
                var m = this.GetMap();
                if (!this._canvas) {
                    return;
                }
                if (!m) {
                    return;
                }
                /** @type {?} */
                var style = this._canvas.style;
                if (visibility !== '') {
                    // label is not visible, don't calculate positions etc.
                    style['visibility'] = visibility;
                    return;
                }
                /** @type {?} */
                var offset = this.Get('offset');
                /** @type {?} */
                var latLng = this.Get('position');
                if (!latLng) {
                    return;
                }
                if (!offset) {
                    offset = new Microsoft.Maps.Point(0, 0);
                }
                /** @type {?} */
                var pos = (m.tryLocationToPixel(latLng, Microsoft.Maps.PixelReference.control));
                style['top'] = (pos.y + offset.y) + 'px';
                style['left'] = (pos.x + offset.x) + 'px';
                style['visibility'] = visibility;
            };
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * @memberof BingMapLabel
         * @method
         * @protected
         */
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        BingMapLabel.prototype.OnAdd = /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                this._canvas.id = "xMapLabel" + id$1++;
                /** @type {?} */
                var style = this._canvas.style;
                style.position = 'absolute';
                /** @type {?} */
                var ctx = this._canvas.getContext('2d');
                ctx.lineJoin = 'round';
                ctx.textBaseline = 'top';
                ((this)).setHtmlElement(this._canvas);
            };
        /**
         * Delegate callled when the label is loaded
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
        BingMapLabel.prototype.OnLoad = /**
         * Delegate callled when the label is loaded
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this.GetMap(), 'viewchange', function () {
                    _this.Changed('position');
                });
                this.DrawCanvas();
                this.Draw();
            };
        return BingMapLabel;
    }(MapLabel));
    /**
     * Helper function to extend the CustomOverlay into the MapLabel
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinMapLabelWithOverlayView() {
        new Extender(BingMapLabel)
            .Extend(new Microsoft.Maps.CustomOverlay())
            .Map('onAdd', 'OnAdd')
            .Map('onLoad', 'OnLoad')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation for a polygon model for Bing Maps V8.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polygon model for Bing Maps V8.
     *
     * @export
     */ BingPolygon = (function (_super) {
        __extends(BingPolygon, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of BingPolygon.
         * @param _polygon - The {@link Microsoft.Maps.Polygon} underlying the model.
         * @param _mapService Instance of the Map Service.
         * @param _layer - The context layer.
         * @memberof BingPolygon
         */
        function BingPolygon(_polygon, _mapService, _layer) {
            var _this = _super.call(this) || this;
            _this._polygon = _polygon;
            _this._mapService = _mapService;
            _this._layer = _layer;
            _this._map = null;
            _this._isEditable = false;
            _this._title = '';
            _this._maxZoom = -1;
            _this._minZoom = -1;
            _this._showLabel = false;
            _this._showTooltip = false;
            _this._label = null;
            _this._tooltip = null;
            _this._hasToolTipReceiver = false;
            _this._tooltipVisible = false;
            _this._metadata = new Map();
            _this._map = _this._mapService.MapInstance;
            _this._originalPath = _this.GetPaths();
            return _this;
        }
        Object.defineProperty(BingPolygon.prototype, "LabelMaxZoom", {
            get: /**
             * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._maxZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._maxZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "LabelMinZoom", {
            get: /**
             * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._minZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._minZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "Metadata", {
            get: /**
             * Gets the polygon metadata.
             *
             * \@readonly
             * \@memberof BingPolygon
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the polygon, in this case {\@link Microsoft.Maps.Polygon}
             *
             * \@readonly
             * \@memberof BingPolygon
             * @return {?}
             */ function () { return this._polygon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "ShowLabel", {
            get: /**
             * Gets or sets whether to show the label
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._showLabel; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showLabel = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageLabel();
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        BingPolygon.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                /** @type {?} */
                var supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    Microsoft.Maps.Events.addHandler(this._polygon, eventType, function (e) {
                        fn(e);
                    });
                }
                if (eventType === 'mousemove') {
                    /** @type {?} */
                    var handlerId_1 = void 0;
                    Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', function (e) {
                        handlerId_1 = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) { return fn(m); });
                    });
                    Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', function (e) {
                        if (handlerId_1) {
                            Microsoft.Maps.Events.removeHandler(handlerId_1);
                        }
                    });
                }
                if (eventType === 'pathchanged') {
                    this._editingCompleteEmitter = /** @type {?} */ (fn);
                }
            };
        /**
         * Deleted the polygon.
         *
         * \@memberof BingPolygon
         * @return {?}
         */
        BingPolygon.prototype.Delete = /**
         * Deleted the polygon.
         *
         * \@memberof BingPolygon
         * @return {?}
         */
            function () {
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
                if (this._label) {
                    this._label.Delete();
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
        BingPolygon.prototype.GetDraggable = /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
            function () {
                return false;
            };
        /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        BingPolygon.prototype.GetEditable = /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._isEditable;
            };
        /**
         * Gets the polygon path.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
        BingPolygon.prototype.GetPath = /**
         * Gets the polygon path.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
            function () {
                /** @type {?} */
                var p = this._polygon.getLocations();
                /** @type {?} */
                var path = new Array();
                p.forEach(function (l) { return path.push({ latitude: l.latitude, longitude: l.longitude }); });
                return path;
            };
        /**
         * Gets the polygon paths.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
        BingPolygon.prototype.GetPaths = /**
         * Gets the polygon paths.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
            function () {
                /** @type {?} */
                var p = this._polygon.getRings();
                /** @type {?} */
                var paths = new Array();
                p.forEach(function (x) {
                    /** @type {?} */
                    var path = new Array();
                    x.forEach(function (y) { return path.push({ latitude: y.latitude, longitude: y.longitude }); });
                    paths.push(path);
                });
                return paths;
            };
        /**
         * Gets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
        BingPolygon.prototype.GetVisible = /**
         * Gets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
            function () {
                return this._polygon.getVisible();
            };
        /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof BingPolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetDraggable = /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof BingPolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                //      ?forum=bingmaps
                throw (new Error('The bing maps implementation currently does not support draggable polygons.'));
            };
        /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof BingPolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetEditable = /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof BingPolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                var _this = this;
                /** @type {?} */
                var isChanged = this._isEditable !== editable;
                this._isEditable = editable;
                if (!isChanged) {
                    return;
                }
                if (this._isEditable) {
                    this._originalPath = this.GetPaths();
                    this._mapService.GetDrawingTools().then(function (t) {
                        t.edit(_this._polygon);
                    });
                }
                else {
                    this._mapService.GetDrawingTools().then(function (t) {
                        t.finish(function (editedPolygon) {
                            if (editedPolygon !== _this._polygon || !_this._editingCompleteEmitter) {
                                return;
                            }
                            /** @type {?} */
                            var newPath = _this.GetPaths();
                            /** @type {?} */
                            var originalPath = _this._originalPath;
                            _this.SetPaths(newPath);
                            // this is necessary for the new path to persist it appears.
                            // this is necessary for the new path to persist it appears.
                            _this._editingCompleteEmitter({
                                Click: null,
                                Polygon: _this,
                                OriginalPath: originalPath,
                                NewPath: newPath
                            });
                        });
                    });
                }
            };
        /**
         * Sets the polygon options
         *
         * \@memberof Polygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetOptions = /**
         * Sets the polygon options
         *
         * \@memberof Polygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = BingConversions.TranslatePolygonOptions(options);
                this._polygon.setOptions(o);
                if (options.visible != null && this._showLabel && this._label) {
                    this._label.Set('hidden', !options.visible);
                }
                if (typeof options.editable !== 'undefined') {
                    this.SetEditable(options.editable);
                }
            };
        /**
         * Sets the polygon path.
         *
         * \@memberof BingPolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetPath = /**
         * Sets the polygon path.
         *
         * \@memberof BingPolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
            function (path) {
                /** @type {?} */
                var p = new Array();
                path.forEach(function (x) { return p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                this._originalPath = [path];
                this._polygon.setLocations(p);
                if (this._label) {
                    this._centroid = null;
                    this.ManageLabel();
                }
            };
        /**
         * Set the polygon path or paths.
         *
         * \@memberof BingPolygon
         * @param {?} paths
         * An Array of {\@link ILatLong} (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
        BingPolygon.prototype.SetPaths = /**
         * Set the polygon path or paths.
         *
         * \@memberof BingPolygon
         * @param {?} paths
         * An Array of {\@link ILatLong} (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
            function (paths) {
                if (paths == null) {
                    return;
                }
                if (!Array.isArray(paths)) {
                    return;
                }
                if (paths.length === 0) {
                    this._polygon.setRings(new Array());
                    if (this._label) {
                        this._label.Delete();
                        this._label = null;
                    }
                    return;
                }
                if (Array.isArray(paths[0])) {
                    /** @type {?} */
                    var p_1 = new Array();
                    ((paths)).forEach(function (path) {
                        /** @type {?} */
                        var _p = new Array();
                        path.forEach(function (x) { return _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                        p_1.push(_p);
                    });
                    this._originalPath = /** @type {?} */ (paths);
                    this._polygon.setRings(p_1);
                    if (this._label) {
                        this._centroid = null;
                        this.ManageLabel();
                    }
                }
                else {
                    // parameter is a simple array....
                    this.SetPath(/** @type {?} */ (paths));
                }
            };
        /**
         * Sets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetVisible = /**
         * Sets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polygon.setOptions(/** @type {?} */ ({ visible: visible }));
                if (this._showLabel && this._label) {
                    this._label.Set('hidden', !visible);
                }
            };
        /**
         * Configures the label for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolygon.prototype.ManageLabel = /**
         * Configures the label for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                if (this.GetPath == null || this.GetPath().length === 0) {
                    return;
                }
                if (this._showLabel && this._title != null && this._title !== '') {
                    /** @type {?} */
                    var o = {
                        text: this._title,
                        position: BingConversions.TranslateLocation(this.Centroid)
                    };
                    if (o["position"] == null) {
                        return;
                    }
                    if (this._minZoom !== -1) {
                        o["minZoom"] = this._minZoom;
                    }
                    if (this._maxZoom !== -1) {
                        o["maxZoom"] = this._maxZoom;
                    }
                    if (this._label == null) {
                        this._label = new BingMapLabel(o);
                        this._label.SetMap(this._map);
                    }
                    else {
                        this._label.SetValues(o);
                    }
                    this._label.Set('hidden', !this.GetVisible());
                }
                else {
                    if (this._label) {
                        this._label.SetMap(null);
                        this._label = null;
                    }
                }
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolygon.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    /** @type {?} */
                    var o = {
                        text: this._title,
                        align: 'left',
                        offset: new Microsoft.Maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        this._tooltip = new BingMapLabel(o);
                        this._tooltip.SetMap(this._map);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', function (e) {
                            _this._tooltip.Set('position', e.location);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                            _this._mouseMoveListener = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) {
                                if (_this._tooltipVisible && m.location && m.primitive === _this._polygon) {
                                    _this._tooltip.Set('position', m.location);
                                }
                            });
                        });
                        this._mouseOutListener = Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                            if (_this._mouseMoveListener) {
                                Microsoft.Maps.Events.removeHandler(_this._mouseMoveListener);
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return BingPolygon;
    }(Polygon));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation for a polyline model for Bing Maps V8.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polyline model for Bing Maps V8.
     *
     * @export
     */ BingPolyline = (function (_super) {
        __extends(BingPolyline, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of BingPolygon.
         * @param _polyline - The {@link Microsoft.Maps.Polyline} underlying the model.
         * @param _map - The context map.
         * @param _layer - The context layer.
         * @memberof BingPolyline
         */
        function BingPolyline(_polyline, _map, _layer) {
            var _this = _super.call(this) || this;
            _this._polyline = _polyline;
            _this._map = _map;
            _this._layer = _layer;
            _this._isEditable = true;
            _this._title = '';
            _this._showTooltip = false;
            _this._tooltip = null;
            _this._hasToolTipReceiver = false;
            _this._tooltipVisible = false;
            _this._metadata = new Map();
            return _this;
        }
        Object.defineProperty(BingPolyline.prototype, "Metadata", {
            get: /**
             * Gets the polyline metadata.
             *
             * \@readonly
             * \@memberof BingPolyline
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "NativePrimitve", {
            get: /**
             * Gets the Navitve Polyline underlying the model
             *
             * \@readonly
             * \@memberof BingPolyline
             * @return {?}
             */ function () { return this._polyline; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof BingPolyline
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polyline
             *
             * @abstract
             * \@memberof BingPolyline
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        BingPolyline.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                /** @type {?} */
                var supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    Microsoft.Maps.Events.addHandler(this._polyline, eventType, function (e) {
                        fn(e);
                    });
                }
                if (eventType === 'mousemove') {
                    /** @type {?} */
                    var handlerId_1 = void 0;
                    Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', function (e) {
                        handlerId_1 = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) { return fn(m); });
                    });
                    Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', function (e) {
                        if (handlerId_1) {
                            Microsoft.Maps.Events.removeHandler(handlerId_1);
                        }
                    });
                }
            };
        /**
         * Deleted the polyline.
         *
         * \@memberof BingPolyline
         * @return {?}
         */
        BingPolyline.prototype.Delete = /**
         * Deleted the polyline.
         *
         * \@memberof BingPolyline
         * @return {?}
         */
            function () {
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
        BingPolyline.prototype.GetDraggable = /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
            function () {
                return false;
            };
        /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        BingPolyline.prototype.GetEditable = /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._isEditable;
            };
        /**
         * Gets the polyline path.
         *
         * \@memberof BingPolyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
        BingPolyline.prototype.GetPath = /**
         * Gets the polyline path.
         *
         * \@memberof BingPolyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
            function () {
                /** @type {?} */
                var p = this._polyline.getLocations();
                /** @type {?} */
                var path = new Array();
                p.forEach(function (l) { return path.push({ latitude: l.latitude, longitude: l.longitude }); });
                return path;
            };
        /**
         * Gets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
        BingPolyline.prototype.GetVisible = /**
         * Gets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
            function () {
                return this._polyline.getVisible();
            };
        /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof BingPolyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetDraggable = /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof BingPolyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                throw (new Error('The bing maps implementation currently does not support draggable polylines.'));
            };
        /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof BingPolyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetEditable = /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof BingPolyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                this._isEditable = editable;
            };
        /**
         * Sets the polyline options
         *
         * \@memberof BingPolyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetOptions = /**
         * Sets the polyline options
         *
         * \@memberof BingPolyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = BingConversions.TranslatePolylineOptions(options);
                this._polyline.setOptions(o);
                if (options.path) {
                    this.SetPath(/** @type {?} */ (options.path));
                }
            };
        /**
         * Sets the polyline path.
         *
         * \@memberof BingPolyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetPath = /**
         * Sets the polyline path.
         *
         * \@memberof BingPolyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
            function (path) {
                /** @type {?} */
                var p = new Array();
                path.forEach(function (x) { return p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                this._polyline.setLocations(p);
            };
        /**
         * Sets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetVisible = /**
         * Sets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polyline.setOptions(/** @type {?} */ ({ visible: visible }));
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolyline.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    /** @type {?} */
                    var o = {
                        text: this._title,
                        align: 'left',
                        offset: new Microsoft.Maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        this._tooltip = new BingMapLabel(o);
                        this._tooltip.SetMap(this._map);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', function (e) {
                            _this._tooltip.Set('position', e.location);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', function (e) {
                            if (_this._tooltipVisible && e.location && e.primitive === _this._polyline) {
                                _this._tooltip.Set('position', e.location);
                            }
                        });
                        this._mouseOutListener = Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return BingPolyline;
    }(Polyline));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * This contstant translates the abstract map events into their corresponding bing map
     * equivalents.
      @type {?} */
    var BingMapEventsLookup = {
        click: 'click',
        dblclick: 'dblclick',
        rightclick: 'rightclick',
        resize: 'resize',
        boundschanged: 'viewchangeend',
        centerchanged: 'viewchangeend',
        zoomchanged: 'viewchangeend',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mousemove: 'mousemove',
        infowindowclose: 'infoboxChanged'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.
     *
     * @export
     */
    var /**
     * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.
     *
     * @export
     */ BingCanvasOverlay = (function (_super) {
        __extends(BingCanvasOverlay, _super);
        /**
         * Creates a new instance of the BingCanvasOverlay class.
         * @param drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @memberof BingCanvasOverlay
         */
        function BingCanvasOverlay(drawCallback) {
            return _super.call(this, drawCallback) || this;
        }
        /**
         * Obtains geo coordinates for the click location
         *
         * @abstract
         * \@memberof BingCanvasOverlay
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        BingCanvasOverlay.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the click location
         *
         * @abstract
         * \@memberof BingCanvasOverlay
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                return { latitude: e.location.latitude, longitude: e.location.longitude };
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?}
         */
        BingCanvasOverlay.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller. Note that this method returns null until OnLoad has been called.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
        BingCanvasOverlay.prototype.GetToolTipOverlay = /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller. Note that this method returns null until OnLoad has been called.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
            function () {
                /** @type {?} */
                var o = {
                    align: 'left',
                    offset: new Microsoft.Maps.Point(0, 25),
                    backgroundColor: 'bisque',
                    hidden: true,
                    fontSize: 12,
                    fontColor: '#000000',
                    strokeWeight: 0
                };
                /** @type {?} */
                var label = new BingMapLabel(o);
                label.SetMap(this.GetMap());
                return label;
            };
        /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * @abstract
         * \@method
         * \@memberof BingCanvasOverlay
         * @return {?}
         */
        BingCanvasOverlay.prototype.OnLoad = /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * @abstract
         * \@method
         * \@memberof BingCanvasOverlay
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var map = ((this)).getMap();
                // Get the current map view information.
                this._zoomStart = map.getZoom();
                this._centerStart = /** @type {?} */ (map.getCenter());
                // Redraw the canvas.
                this.Redraw(true);
                // When the map moves, move the canvas accordingly.
                this._viewChangeEvent = Microsoft.Maps.Events.addHandler(map, 'viewchange', function (e) {
                    if (map.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside) {
                        // Don't show the canvas if the map is in Streetside mode.
                        // Don't show the canvas if the map is in Streetside mode.
                        _this._canvas.style.display = 'none';
                    }
                    else {
                        /** @type {?} */
                        var zoomCurrent = map.getZoom();
                        /** @type {?} */
                        var centerCurrent = map.getCenter();
                        /** @type {?} */
                        var scale = Math.pow(2, zoomCurrent - _this._zoomStart);
                        /** @type {?} */
                        var newWidth = map.getWidth() * scale;
                        /** @type {?} */
                        var newHeight = map.getHeight() * scale;
                        /** @type {?} */
                        var pixelPoints = (map.tryLocationToPixel([
                            BingConversions.TranslateLocation(_this._centerStart),
                            centerCurrent
                        ], Microsoft.Maps.PixelReference.control));
                        /** @type {?} */
                        var centerOffsetX = pixelPoints[1].x - pixelPoints[0].x;
                        /** @type {?} */
                        var centerOffsetY = pixelPoints[1].y - pixelPoints[0].y;
                        /** @type {?} */
                        var x = (-(newWidth - map.getWidth()) / 2) - centerOffsetX;
                        /** @type {?} */
                        var y = (-(newHeight - map.getHeight()) / 2) - centerOffsetY;
                        // Update the canvas CSS position and dimensions.
                        // Update the canvas CSS position and dimensions.
                        _this.UpdatePosition(x, y, newWidth, newHeight);
                    }
                });
                // When the map stops moving, render new data on the canvas.
                this._viewChangeEndEvent = Microsoft.Maps.Events.addHandler(map, 'viewchangeend', function (e) {
                    _this.UpdateCanvas();
                });
                // Update the position of the overlay when the map is resized.
                this._mapResizeEvent = Microsoft.Maps.Events.addHandler(map, 'mapresize', function (e) {
                    _this.UpdateCanvas();
                });
                // set the overlay to ready state
                this._readyResolver(true);
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        BingCanvasOverlay.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                /** @type {?} */
                var m = this.GetMap();
                if (map === m) {
                    return;
                }
                if (m) {
                    m.layers.remove(this);
                }
                if (map != null) {
                    map.layers.insert(this);
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Attaches the canvas to the map.
         * @memberof CanvasOverlay
         * @method
         */
        /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
        BingCanvasOverlay.prototype.SetCanvasElement = /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
            function (el) {
                ((this)).setHtmlElement(el);
            };
        /**
         * Remove the map event handlers.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.RemoveEventHandlers = /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                // Remove all event handlers from the map.
                Microsoft.Maps.Events.removeHandler(this._viewChangeEvent);
                Microsoft.Maps.Events.removeHandler(this._viewChangeEndEvent);
                Microsoft.Maps.Events.removeHandler(this._mapResizeEvent);
            };
        /**
         * Updates the Canvas size based on the map size.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.Resize = /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var map = ((this)).getMap();
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                this._canvas.width = map.getWidth();
                this._canvas.height = map.getHeight();
            };
        /**
         * Updates the Canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.UpdateCanvas = /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var map = ((this)).getMap();
                // Only render the canvas if it isn't in streetside mode.
                if (map.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside) {
                    this._canvas.style.display = '';
                    // Reset CSS position and dimensions of canvas.
                    this.UpdatePosition(0, 0, map.getWidth(), map.getHeight());
                    // Redraw the canvas.
                    this.Redraw(true);
                    // Get the current map view information.
                    this._zoomStart = map.getZoom();
                    this._centerStart = /** @type {?} */ (map.getCenter());
                }
            };
        return BingCanvasOverlay;
    }(CanvasOverlay));
    /**
     * Helper function to extend the OverlayView into the CanvasOverlay
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinCanvasOverlay() {
        new Extender(BingCanvasOverlay)
            .Extend(new Microsoft.Maps.CustomOverlay())
            .Map('onAdd', 'OnAdd')
            .Map('onLoad', 'OnLoad')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var MapTypeId$1 = {
        /** This map type displays a transparent layer of major streets on satellite images. */
        hybrid: 0,
        /** This map type displays a normal street map. */
        roadmap: 1,
        /** This map type displays satellite images. */
        satellite: 2,
        /** This map type displays maps with physical features such as terrain and vegetation. */
        terrain: 3,
    };
    MapTypeId$1[MapTypeId$1.hybrid] = 'hybrid';
    MapTypeId$1[MapTypeId$1.roadmap] = 'roadmap';
    MapTypeId$1[MapTypeId$1.satellite] = 'satellite';
    MapTypeId$1[MapTypeId$1.terrain] = 'terrain';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This class contains helperfunctions to map various interfaces used to represent options and structures into the
     * corresponding Google Maps specific implementations.
     *
     * @export
     */
    var GoogleConversions = (function () {
        function GoogleConversions() {
        }
        /**
         * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} bounds - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateBounds = /**
         * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} bounds - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (bounds) {
                /** @type {?} */
                var b = {
                    east: bounds.maxLongitude,
                    north: bounds.maxLatitude,
                    south: bounds.minLatitude,
                    west: bounds.minLongitude,
                };
                return b;
            };
        /**
         * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateInfoWindowOptions = /**
         * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'htmlContent') {
                        o.content = ((options))[k];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                if (o.content == null || o.content === '') {
                    if (options.title !== '' && options.description !== '') {
                        o.content = options.title + ": " + options.description;
                    }
                    else if (options.description !== '') {
                        o.content = options.description;
                    }
                    else {
                        o.content = options.title;
                    }
                }
                return o;
            };
        /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocation = /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                /** @type {?} */
                var l = { lat: latlong.latitude, lng: latlong.longitude };
                return l;
            };
        /**
         * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLatLng = /**
         * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlng) {
                /** @type {?} */
                var l = { latitude: latlng.lat, longitude: latlng.lng };
                return l;
            };
        /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocationObject = /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                /** @type {?} */
                var l = new google.maps.LatLng(latlong.latitude, latlong.longitude);
                return l;
            };
        /**
         * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLatLngObject = /**
         * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlng) {
                /** @type {?} */
                var l = { latitude: latlng.lat(), longitude: latlng.lng() };
                return l;
            };
        /**
         * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlongArray - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocationObjectArray = /**
         * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlongArray - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlongArray) {
                /** @type {?} */
                var p = new Array();
                for (var i = 0; i < latlongArray.length; i++) {
                    p.push(GoogleConversions.TranslateLocationObject(latlongArray[i]));
                }
                return p;
            };
        /**
         * Maps a MapTypeId object to a Google maptype string.
         *
         * \@memberof GoogleConversions
         * @param {?} mapTypeId - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateMapTypeId = /**
         * Maps a MapTypeId object to a Google maptype string.
         *
         * \@memberof GoogleConversions
         * @param {?} mapTypeId - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (mapTypeId) {
                switch (mapTypeId) {
                    case MapTypeId.road: return MapTypeId$1[MapTypeId$1.roadmap];
                    case MapTypeId.grayscale: return MapTypeId$1[MapTypeId$1.terrain];
                    case MapTypeId.hybrid: return MapTypeId$1[MapTypeId$1.hybrid];
                    case MapTypeId.ordnanceSurvey: return MapTypeId$1[MapTypeId$1.terrain];
                    default: return MapTypeId$1[MapTypeId$1.satellite];
                }
            };
        /**
         * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Promise that when resolved contains the mapped object.
         *
         */
        GoogleConversions.TranslateMarkerOptions = /**
         * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Promise that when resolved contains the mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'position') {
                        /** @type {?} */
                        var latlng = GoogleConversions.TranslateLocationObject(options[k]);
                        o.position = latlng;
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateOptions = /**
         * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = GoogleConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);
                    }
                    else if (k === 'disableZooming') {
                        o.gestureHandling = 'none';
                        o.zoomControl = false;
                    }
                    else if (k === 'showMapTypeSelector') {
                        o.mapTypeControl = false;
                    }
                    else if (k === 'customMapStyleGoogle') {
                        o.styles = /** @type {?} */ ((options.customMapStyleGoogle));
                    }
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof GoogleConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
        GoogleConversions.TranslatePaths = /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof GoogleConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
            function (paths) {
                /** @type {?} */
                var p = new Array();
                if (paths == null || !Array.isArray(paths) || paths.length === 0) {
                    p.push(new Array());
                }
                else if (Array.isArray(paths[0])) {
                    /** @type {?} */
                    var p1 = (paths);
                    for (var i = 0; i < p1.length; i++) {
                        p.push(GoogleConversions.TranslateLocationObjectArray(p1[i]));
                    }
                }
                else {
                    // parameter is a simple array....
                    p.push(GoogleConversions.TranslateLocationObjectArray(/** @type {?} */ (paths)));
                }
                return p;
            };
        /**
         *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslatePolygonOptions = /**
         *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'paths') {
                        if (!Array.isArray(options.paths)) {
                            return;
                        }
                        if (options.paths.length === 0) {
                            o.paths = new Array();
                        }
                        else if (Array.isArray(options.paths[0])) {
                            o.paths = new Array();
                            /** @type {?} */
                            var p1 = (options.paths);
                            for (var i = 0; i < p1.length; i++) {
                                o.paths[i] = new Array();
                                for (var j = 0; j < p1[i].length; j++) {
                                    o.paths[i][j] = { lat: p1[i][j].latitude, lng: p1[i][j].longitude };
                                }
                            }
                        }
                        else {
                            o.paths = new Array();
                            /** @type {?} */
                            var p1 = (options.paths);
                            for (var i = 0; i < p1.length; i++) {
                                o.paths[i] = { lat: p1[i].latitude, lng: p1[i].longitude };
                            }
                        }
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslatePolylineOptions = /**
         *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                /** @type {?} */
                var o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    o[k] = ((options))[k];
                });
                return o;
            };
        /**
         * Map option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._mapOptionsAttributes = [
            'backgroundColor',
            'center',
            'clickableIcons',
            'customMapStyleGoogle',
            'disableDefaultUI',
            'disableDoubleClickZoom',
            'draggable',
            'draggableCursor',
            'draggingCursor',
            'disableZooming',
            'fullscreenControl',
            'fullscreenControlOptions',
            'gestureHandling',
            'heading',
            'keyboardShortcuts',
            'mapTypeControl',
            'mapTypeControlOptions',
            'mapTypeId',
            'maxZoom',
            'minZoom',
            'noClear',
            'panControl',
            'panControlOptions',
            'rotateControl',
            'rotateControlOptions',
            'scaleControl',
            'scaleControlOptions',
            'scrollwheel',
            'showMapTypeSelector',
            'streetView',
            'streetViewControl',
            'streetViewControlOptions',
            'styles',
            'tilt',
            'zoom',
            'zoomControl',
            'zoomControlOptions'
        ];
        /**
         * InfoWindow option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._infoWindowOptionsAttributes = [
            'actions',
            'description',
            'htmlContent',
            'id',
            'position',
            'pixelOffset',
            'showCloseButton',
            'showPointer',
            'pushpin',
            'title',
            'titleClickHandler',
            'typeName',
            'visible',
            'width',
            'height'
        ];
        /**
         * Marker option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._markerOptionsAttributes = [
            'anchor',
            'position',
            'title',
            'text',
            'label',
            'draggable',
            'icon',
            'width',
            'height',
            'iconInfo',
            'metadata',
            'visible'
        ];
        /**
         * Cluster option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._clusterOptionsAttributes = [
            'callback',
            'clusteredPinCallback',
            'clusteringEnabled',
            'gridSize',
            'layerOffset',
            'placementMode',
            'visible',
            'zIndex'
        ];
        /**
         * Polygon option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._polygonOptionsAttributes = [
            'clickable',
            'draggable',
            'editable',
            'fillColor',
            'fillOpacity',
            'geodesic',
            'paths',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible',
            'zIndex'
        ];
        /**
         * Polyline option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._polylineOptionsAttributes = [
            'clickable',
            'draggable',
            'editable',
            'geodesic',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible',
            'zIndex'
        ];
        return GoogleConversions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation for a {\@link InfoWindow}} model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a {\@link InfoWindow}} model for Google Maps.
     *
     * @export
     */ GoogleInfoWindow = (function () {
        ///
        /// constructor
        ///
        /**
         * Creates an instance of GoogleInfoWindow.
         * @param _infoWindow - A {@link GoogleMapTypes.InfoWindow} instance underlying the model.
         * @param _mapService - An instance of the {@link GoogleMapService}.
         * @memberof GoogleInfoWindow
         */
        function GoogleInfoWindow(_infoWindow, _mapService) {
            this._infoWindow = _infoWindow;
            this._mapService = _mapService;
        }
        Object.defineProperty(GoogleInfoWindow.prototype, "IsOpen", {
            get: /**
             * Gets whether the info box is currently open.
             *
             * \@readonly
             * \@memberof InfoWGoogleInfoWindowindow
             * @return {?}
             */ function () {
                if (this._isOpen === true) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleInfoWindow.prototype, "NativePrimitve", {
            get: /**
             * Gets the underlying native object.
             *
             * \@property
             * \@readonly
             * @return {?}
             */ function () {
                return this._infoWindow;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.AddListener = /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                this._infoWindow.addListener(eventType, function (e) {
                    if (eventType === 'closeclick') {
                        _this._isOpen = false;
                    }
                    fn(e);
                });
            };
        /**
         *
         * Closes the info window.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?}
         */
        GoogleInfoWindow.prototype.Close = /**
         *
         * Closes the info window.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                this._isOpen = false;
                this._infoWindow.close();
            };
        /**
         * Gets the position of the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?} - The geo coordinates of the info window.
         *
         */
        GoogleInfoWindow.prototype.GetPosition = /**
         * Gets the position of the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?} - The geo coordinates of the info window.
         *
         */
            function () {
                return GoogleConversions.TranslateLatLngObject(this._infoWindow.getPosition());
            };
        /**
         * Opens the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?=} anchor
         * @return {?}
         */
        GoogleInfoWindow.prototype.Open = /**
         * Opens the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?=} anchor
         * @return {?}
         */
            function (anchor) {
                var _this = this;
                this._mapService.MapPromise.then(function (m) {
                    _this._isOpen = true;
                    _this._infoWindow.open(m, anchor);
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} options - The options to set. This object will be merged with the existing options.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.SetOptions = /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} options - The options to set. This object will be merged with the existing options.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = GoogleConversions.TranslateInfoWindowOptions(options);
                this._infoWindow.setOptions(o);
            };
        /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} position - Geo coordinates at which to anchor the info window.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.SetPosition = /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} position - Geo coordinates at which to anchor the info window.
         *
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var l = GoogleConversions.TranslateLocation(position);
                this._infoWindow.setPosition(l);
            };
        return GoogleInfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link Marker} contract for the Google Maps map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link Marker} contract for the Google Maps map architecture.
     *
     * @export
     */ GoogleMarker = (function () {
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleMarker.
         * @param _marker
         *
         * @memberof GoogleMarker
         */
        function GoogleMarker(_marker) {
            this._marker = _marker;
            this._metadata = new Map();
            this._isFirst = false;
            this._isLast = true;
        }
        Object.defineProperty(GoogleMarker.prototype, "IsFirst", {
            get: /**
             * Indicates that the marker is the first marker in a set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isFirst; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isFirst = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "IsLast", {
            get: /**
             * Indicates that the marker is the last marker in the set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isLast; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isLast = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "Metadata", {
            get: /**
             * Gets the marker metadata.
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link Microsoft.Maps.Pushpin}
             *
             * \@readonly
             * @abstract
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._marker; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "Location", {
            get: /**
             * Gets the Location of the marker
             *
             * \@readonly
             * @abstract
             * \@memberof BingMarker
             * @return {?}
             */ function () {
                /** @type {?} */
                var l = this._marker.getPosition();
                return {
                    latitude: l.lat(),
                    longitude: l.lng()
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        GoogleMarker.prototype.AddListener = /**
         * Adds an event listener to the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                this._marker.addListener(eventType, fn);
            };
        /**
         * Deletes the marker.
         *
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
        GoogleMarker.prototype.DeleteMarker = /**
         * Deletes the marker.
         *
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
            function () {
                this._marker.setMap(null);
            };
        /**
         * Gets the marker label
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
        GoogleMarker.prototype.GetLabel = /**
         * Gets the marker label
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
            function () {
                return this._marker.getLabel().text;
            };
        /**
         * Gets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
        GoogleMarker.prototype.GetVisible = /**
         * Gets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
            function () {
                return this._marker.getVisible();
            };
        /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * \@memberof GoogleMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetAnchor = /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * \@memberof GoogleMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
            function (anchor) {
                // not implemented
                // TODO: we need to switch the model to complex icons for google to
                // support anchors, sizes and origins.
                // https://developers.google.com/maps/documentation/javascript/markers
            };
        /**
         * Sets the draggability of a marker.
         *
         * \@memberof GoogleMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetDraggable = /**
         * Sets the draggability of a marker.
         *
         * \@memberof GoogleMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._marker.setDraggable(draggable);
            };
        /**
         * Sets the icon for the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetIcon = /**
         * Sets the icon for the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
            function (icon) {
                this._marker.setIcon(icon);
            };
        /**
         * Sets the marker label.
         *
         * \@memberof GoogleMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetLabel = /**
         * Sets the marker label.
         *
         * \@memberof GoogleMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
            function (label) {
                this._marker.setLabel(label);
            };
        /**
         * Sets the marker position.
         *
         * \@memberof GoogleMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetPosition = /**
         * Sets the marker position.
         *
         * \@memberof GoogleMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
            function (latLng) {
                /** @type {?} */
                var p = GoogleConversions.TranslateLocationObject(latLng);
                this._marker.setPosition(p);
            };
        /**
         * Sets the marker title.
         *
         * \@memberof GoogleMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetTitle = /**
         * Sets the marker title.
         *
         * \@memberof GoogleMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
            function (title) {
                this._marker.setTitle(title);
            };
        /**
         * Sets the marker options.
         *
         * \@memberof GoogleMarker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetOptions = /**
         * Sets the marker options.
         *
         * \@memberof GoogleMarker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = GoogleConversions.TranslateMarkerOptions(options);
                this._marker.setOptions(o);
            };
        /**
         * Sets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetVisible = /**
         * Sets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._marker.setVisible(visible);
            };
        return GoogleMarker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */
    var /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */ GoogleMapLabel = (function (_super) {
        __extends(GoogleMapLabel, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function GoogleMapLabel(options) {
            var _this = this;
            options["fontSize"] = options["fontSize"] || 12;
            options["fontColor"] = options["fontColor"] || '#ffffff';
            options["strokeWeight"] = options["strokeWeight"] || 3;
            options["strokeColor"] = options["strokeColor"] || '#000000';
            _this = _super.call(this, options) || this;
            return _this;
        }
        Object.defineProperty(GoogleMapLabel.prototype, "DefaultLabelStyle", {
            get: /**
             * Returns the default label style for the platform
             *
             * \@readonly
             * @abstract
             * \@memberof GoogleMapLabel
             * @return {?}
             */ function () {
                return {
                    fontSize: 12,
                    fontFamily: 'sans-serif',
                    fontColor: '#ffffff',
                    strokeWeight: 3,
                    strokeColor: '#000000'
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
        GoogleMapLabel.prototype.Get = /**
         * Gets the value of a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
            function (key) {
                return ((this)).get(key);
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @return {?}
         */
        GoogleMapLabel.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Set the value for a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
        GoogleMapLabel.prototype.Set = /**
         * Set the value for a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
            function (key, val) {
                if (key === 'position' && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {
                    val = new google.maps.LatLng(val.latitude, val.longitude);
                }
                if (this.Get(key) !== val) {
                    ((this)).set(key, val);
                }
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        GoogleMapLabel.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                ((this)).setMap(map);
            };
        /**
         * Applies settings to the object
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
        GoogleMapLabel.prototype.SetValues = /**
         * Applies settings to the object
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
            function (options) {
                for (var key in options) {
                    if (key !== '') {
                        if (key === 'position' && options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {
                            options[key] = new google.maps.LatLng(options[key].latitude, options[key].longitude);
                        }
                        if (this.Get(key) === options[key]) {
                            delete options[key];
                        }
                    }
                }
                ((this)).setValues(options);
            };
        ///
        /// Protected methods
        ///
        /**
         * Draws the label on the map.
         * @memberof GoogleMapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label on the map.
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        GoogleMapLabel.prototype.Draw = /**
         * Draws the label on the map.
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var projection = ((this)).getProjection();
                /** @type {?} */
                var visibility = this.GetVisible();
                if (!projection) {
                    // The map projection is not ready yet so do nothing
                    return;
                }
                if (!this._canvas) {
                    // onAdd has not been called yet.
                    return;
                }
                /** @type {?} */
                var style = this._canvas.style;
                if (visibility !== '') {
                    // label is not visible, don't calculate positions etc.
                    style['visibility'] = visibility;
                    return;
                }
                /** @type {?} */
                var offset = this.Get('offset');
                /** @type {?} */
                var latLng = this.Get('position');
                if (!latLng) {
                    return;
                }
                if (!(latLng instanceof google.maps.LatLng)) {
                    latLng = new google.maps.LatLng(latLng.lat, latLng.lng);
                }
                if (!offset) {
                    offset = new google.maps.Point(0, 0);
                }
                /** @type {?} */
                var pos = projection.fromLatLngToDivPixel(latLng);
                style['top'] = (pos.y + offset.y) + 'px';
                style['left'] = (pos.x + offset.x) + 'px';
                style['visibility'] = visibility;
            };
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * @memberof GoogleMapLabel
         * @method
         * @protected
         */
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        GoogleMapLabel.prototype.OnAdd = /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                /** @type {?} */
                var style = this._canvas.style;
                style.position = 'absolute';
                /** @type {?} */
                var ctx = this._canvas.getContext('2d');
                ctx.lineJoin = 'round';
                ctx.textBaseline = 'top';
                this.DrawCanvas();
                /** @type {?} */
                var panes = ((this)).getPanes();
                if (panes) {
                    panes.overlayLayer.appendChild(this._canvas);
                    // 4: floatPane (infowindow)
                    // 3: overlayMouseTarget (mouse events)
                    // 2: markerLayer (marker images)
                    // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)
                    // 0: mapPane (lowest pane above the map tiles)
                }
            };
        return GoogleMapLabel;
    }(MapLabel));
    /**
     * Helper function to extend the OverlayView into the MapLabel
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinMapLabelWithOverlayView$1() {
        new Extender(GoogleMapLabel)
            .Extend(new google.maps.OverlayView)
            .Map('changed', 'Changed')
            .Map('onAdd', 'OnAdd')
            .Map('draw', 'Draw')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation for a polygon model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polygon model for Google Maps.
     *
     * @export
     */ GooglePolygon = (function (_super) {
        __extends(GooglePolygon, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of GooglePolygon.
         * @param _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.
         *
         * @memberof GooglePolygon
         */
        function GooglePolygon(_polygon) {
            var _this = _super.call(this) || this;
            _this._polygon = _polygon;
            _this._title = '';
            _this._showLabel = false;
            _this._showTooltip = false;
            _this._maxZoom = -1;
            _this._minZoom = -1;
            _this._label = null;
            _this._tooltip = null;
            _this._tooltipVisible = false;
            _this._hasToolTipReceiver = false;
            _this._mouseOverListener = null;
            _this._mouseOutListener = null;
            _this._mouseMoveListener = null;
            _this._metadata = new Map();
            _this._editingCompleteEmitter = null;
            _this._originalPath = _this.GetPaths();
            return _this;
        }
        Object.defineProperty(GooglePolygon.prototype, "LabelMaxZoom", {
            get: /**
             * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._maxZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._maxZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "LabelMinZoom", {
            get: /**
             * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._minZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._minZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "Metadata", {
            get: /**
             * Gets the polygon metadata.
             *
             * \@readonly
             * \@memberof GoolePolygon
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the polygon, in this case {\@link GoogleMapTypes.Polygon}
             *
             * \@readonly
             * \@memberof GooglePolygon
             * @return {?}
             */ function () { return this._polygon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "ShowLabel", {
            get: /**
             * Gets or sets whether to show the label
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showLabel; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showLabel = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageLabel();
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof GooglePolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        GooglePolygon.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof GooglePolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                /** @type {?} */
                var supportedEvents = [
                    'click',
                    'dblclick',
                    'drag', 'dragend',
                    'dragstart',
                    'mousedown',
                    'mousemove',
                    'mouseout',
                    'mouseover',
                    'mouseup',
                    'rightclick'
                ];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    this._polygon.addListener(eventType, fn);
                }
                if (eventType === 'pathchanged') {
                    this._editingCompleteEmitter = /** @type {?} */ (fn);
                }
            };
        /**
         * Deleted the polygon.
         *
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.Delete = /**
         * Deleted the polygon.
         *
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                this._polygon.setMap(null);
                if (this._label) {
                    this._label.Delete();
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
        GooglePolygon.prototype.GetDraggable = /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
            function () {
                return this._polygon.getDraggable();
            };
        /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        GooglePolygon.prototype.GetEditable = /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._polygon.getEditable();
            };
        /**
         * Gets the polygon path.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
        GooglePolygon.prototype.GetPath = /**
         * Gets the polygon path.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
            function () {
                /** @type {?} */
                var p = this._polygon.getPath();
                /** @type {?} */
                var path = new Array();
                p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
                return path;
            };
        /**
         * Gets the polygon paths.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
        GooglePolygon.prototype.GetPaths = /**
         * Gets the polygon paths.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
            function () {
                /** @type {?} */
                var p = this._polygon.getPaths();
                /** @type {?} */
                var paths = new Array();
                p.forEach(function (x) {
                    /** @type {?} */
                    var path = new Array();
                    x.forEach(function (y) { return path.push({ latitude: y.lat(), longitude: y.lng() }); });
                    paths.push(path);
                });
                return paths;
            };
        /**
         * Gets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
        GooglePolygon.prototype.GetVisible = /**
         * Gets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
            function () {
                return this._polygon.getVisible();
            };
        /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof GooglePolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetDraggable = /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof GooglePolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._polygon.setDraggable(draggable);
            };
        /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof GooglePolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetEditable = /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof GooglePolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                /** @type {?} */
                var previous = this._polygon.getEditable();
                this._polygon.setEditable(editable);
                if (previous && !editable && this._editingCompleteEmitter) {
                    this._editingCompleteEmitter({
                        Click: null,
                        Polygon: this,
                        OriginalPath: this._originalPath,
                        NewPath: this.GetPaths()
                    });
                    this._originalPath = this.GetPaths();
                }
            };
        /**
         * Sets the polygon options
         *
         * \@memberof GooglePolygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetOptions = /**
         * Sets the polygon options
         *
         * \@memberof GooglePolygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = GoogleConversions.TranslatePolygonOptions(options);
                if (typeof o.editable !== 'undefined') {
                    this.SetEditable(o.editable);
                    delete o.editable;
                }
                this._polygon.setOptions(o);
                if (options.visible != null && this._showLabel && this._label) {
                    this._label.Set('hidden', !options.visible);
                }
            };
        /**
         * Sets the polygon path.
         *
         * \@memberof GooglePolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetPath = /**
         * Sets the polygon path.
         *
         * \@memberof GooglePolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
            function (path) {
                /** @type {?} */
                var p = new Array();
                path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                this._polygon.setPath(p);
                this._originalPath = [path];
                if (this._label) {
                    this._centroid = null;
                    this.ManageLabel();
                }
            };
        /**
         * Set the polygon path or paths.
         *
         * \@memberof GooglePolygon
         * @param {?} paths An Array of {\@link ILatLong}
         * (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetPaths = /**
         * Set the polygon path or paths.
         *
         * \@memberof GooglePolygon
         * @param {?} paths An Array of {\@link ILatLong}
         * (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
            function (paths) {
                if (paths == null) {
                    return;
                }
                if (!Array.isArray(paths)) {
                    return;
                }
                if (paths.length === 0) {
                    this._polygon.setPaths(new Array());
                    if (this._label) {
                        this._label.Delete();
                        this._label = null;
                    }
                    return;
                }
                if (Array.isArray(paths[0])) {
                    /** @type {?} */
                    var p_1 = new Array();
                    ((paths)).forEach(function (path) {
                        /** @type {?} */
                        var _p = new Array();
                        path.forEach(function (x) { return _p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                        p_1.push(_p);
                    });
                    this._polygon.setPaths(p_1);
                    this._originalPath = /** @type {?} */ (paths);
                    if (this._label) {
                        this._centroid = null;
                        this.ManageLabel();
                    }
                }
                else {
                    // parameter is a simple array....
                    this.SetPath(/** @type {?} */ (paths));
                }
            };
        /**
         * Sets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetVisible = /**
         * Sets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polygon.setVisible(visible);
                if (this._showLabel && this._label) {
                    this._label.Set('hidden', !visible);
                }
            };
        /**
         * Configures the label for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.ManageLabel = /**
         * Configures the label for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                if (this.GetPath == null || this.GetPath().length === 0) {
                    return;
                }
                if (this._showLabel && this._title != null && this._title !== '') {
                    /** @type {?} */
                    var o = {
                        text: this._title,
                        position: GoogleConversions.TranslateLocationObject(this.Centroid)
                    };
                    if (o["position"] == null) {
                        return;
                    }
                    if (this._minZoom !== -1) {
                        o["minZoom"] = this._minZoom;
                    }
                    if (this._maxZoom !== -1) {
                        o["maxZoom"] = this._maxZoom;
                    }
                    if (this._label == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;
                        this._label = new GoogleMapLabel(o);
                    }
                    else {
                        this._label.SetValues(o);
                    }
                    this._label.Set('hidden', !this.GetVisible());
                }
                else {
                    if (this._label) {
                        this._label.SetMap(null);
                        this._label = null;
                    }
                }
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    /** @type {?} */
                    var o = {
                        text: this._title,
                        align: 'left',
                        offset: new google.maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = 100000;
                        this._tooltip = new GoogleMapLabel(o);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                            _this._tooltip.Set('position', e.latLng);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('position', e.latLng);
                            }
                        });
                        this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            google.maps.event.removeListener(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            google.maps.event.removeListener(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            google.maps.event.removeListener(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return GooglePolygon;
    }(Polygon));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation for a polyline model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polyline model for Google Maps.
     *
     * @export
     */ GooglePolyline = (function (_super) {
        __extends(GooglePolyline, _super);
        ///
        /// constructor
        ///
        /**
        * Creates an instance of GooglePolygon.
        * @param _polyline - The {@link GoogleMApTypes.Polyline} underlying the model.
        *
        * @memberof GooglePolyline
        */
        function GooglePolyline(_polyline) {
            var _this = _super.call(this) || this;
            _this._polyline = _polyline;
            _this._title = '';
            _this._showTooltip = false;
            _this._tooltip = null;
            _this._tooltipVisible = false;
            _this._hasToolTipReceiver = false;
            _this._mouseOverListener = null;
            _this._mouseOutListener = null;
            _this._mouseMoveListener = null;
            _this._metadata = new Map();
            return _this;
        }
        Object.defineProperty(GooglePolyline.prototype, "Metadata", {
            get: /**
             * Gets the polyline metadata.
             *
             * \@readonly
             * \@memberof GooglePolyline
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link GoogleMApTypes.Polyline}
             *
             * \@readonly
             * \@memberof GooglePolygon
             * @return {?}
             */ function () { return this._polyline; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof Polyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        GooglePolyline.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof Polyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                /** @type {?} */
                var supportedEvents = [
                    'click',
                    'dblclick',
                    'drag', 'dragend',
                    'dragstart',
                    'mousedown',
                    'mousemove',
                    'mouseout',
                    'mouseover',
                    'mouseup',
                    'rightclick'
                ];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    this._polyline.addListener(eventType, fn);
                }
            };
        /**
         * Deleted the polyline.
         *
         *
         * \@memberof Polyline
         * @return {?}
         */
        GooglePolyline.prototype.Delete = /**
         * Deleted the polyline.
         *
         *
         * \@memberof Polyline
         * @return {?}
         */
            function () {
                this._polyline.setMap(null);
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
        GooglePolyline.prototype.GetDraggable = /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
            function () {
                return this._polyline.getDraggable();
            };
        /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof Polyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        GooglePolyline.prototype.GetEditable = /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof Polyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._polyline.getEditable();
            };
        /**
         * Gets the polyline path.
         *
         * \@memberof Polyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
        GooglePolyline.prototype.GetPath = /**
         * Gets the polyline path.
         *
         * \@memberof Polyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
            function () {
                /** @type {?} */
                var p = this._polyline.getPath();
                /** @type {?} */
                var path = new Array();
                p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
                return path;
            };
        /**
         * Gets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
        GooglePolyline.prototype.GetVisible = /**
         * Gets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
            function () {
                return this._polyline.getVisible();
            };
        /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof Polyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetDraggable = /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof Polyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._polyline.setDraggable(draggable);
            };
        /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof Polyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetEditable = /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof Polyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                this._polyline.setEditable(editable);
            };
        /**
         * Sets the polyline options
         *
         * \@memberof Polyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetOptions = /**
         * Sets the polyline options
         *
         * \@memberof Polyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                /** @type {?} */
                var o = GoogleConversions.TranslatePolylineOptions(options);
                this._polyline.setOptions(o);
                if (options.path) {
                    this.SetPath(/** @type {?} */ (options.path));
                }
            };
        /**
         * Sets the polyline path.
         *
         * \@memberof Polyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetPath = /**
         * Sets the polyline path.
         *
         * \@memberof Polyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
            function (path) {
                /** @type {?} */
                var p = new Array();
                path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                this._polyline.setPath(p);
            };
        /**
         * Sets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetVisible = /**
         * Sets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polyline.setVisible(visible);
            };
        /**
         * Configures the tooltip for the polyline
         * \@memberof GooglePolyline
         * @return {?}
         */
        GooglePolyline.prototype.ManageTooltip = /**
         * Configures the tooltip for the polyline
         * \@memberof GooglePolyline
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    /** @type {?} */
                    var o = {
                        text: this._title,
                        align: 'left',
                        offset: new google.maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = 100000;
                        this._tooltip = new GoogleMapLabel(o);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                            _this._tooltip.Set('position', e.latLng);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('position', e.latLng);
                            }
                        });
                        this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            google.maps.event.removeListener(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            google.maps.event.removeListener(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            google.maps.event.removeListener(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return GooglePolyline;
    }(Polyline));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * This contstant translates the abstract map events into their corresponding google map
     * equivalents.
      @type {?} */
    var GoogleMapEventsLookup = {
        click: 'click',
        dblclick: 'dblclick',
        rightclick: 'rightclick',
        resize: 'resize',
        boundschanged: 'bounds_changed',
        centerchanged: 'center_changed',
        zoomchanged: 'zoom_changed',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mousemove: 'mousemove',
        infowindowclose: 'closeclick'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementing a canvas overlay to be placed on the map for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementing a canvas overlay to be placed on the map for Google Maps.
     *
     * @export
     */ GoogleCanvasOverlay = (function (_super) {
        __extends(GoogleCanvasOverlay, _super);
        /**
         * Creates a new instance of the GoogleCanvasOverlay class.
         * @param drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @memberof GoogleCanvasOverlay
         */
        function GoogleCanvasOverlay(drawCallback) {
            return _super.call(this, drawCallback) || this;
        }
        /**
         * Obtains geo coordinates for the click location
         *
         * \@memberof GoogleCanvasOverlay
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        GoogleCanvasOverlay.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the click location
         *
         * \@memberof GoogleCanvasOverlay
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
        GoogleCanvasOverlay.prototype.GetToolTipOverlay = /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
            function () {
                /** @type {?} */
                var o = {
                    align: 'left',
                    offset: new google.maps.Point(0, 25),
                    backgroundColor: 'bisque',
                    hidden: true,
                    fontSize: 12,
                    fontColor: '#000000',
                    strokeWeight: 0
                };
                o["zIndex"] = 100000;
                /** @type {?} */
                var label = new GoogleMapLabel(o);
                label.SetMap(this.GetMap());
                return label;
            };
        /**
         * Called when the custom overlay is added to the map. Triggers Onload....
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnAdd = /**
         * Called when the custom overlay is added to the map. Triggers Onload....
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
            function () {
                _super.prototype.OnAdd.call(this);
                this.OnLoad();
                this._canvas.style.zIndex = '100';
                // move the canvas above primitives such as polygons.
                // set the overlay to ready state
                this._readyResolver(true);
            };
        /**
         * Called whenever the canvas needs to be redrawn. This method does not do the actual
         * update, it simply scales the canvas. The actual redraw happens once the map is idle.
         * \@memberof GoogleCanvasOverly
         * \@method
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnDraw = /**
         * Called whenever the canvas needs to be redrawn. This method does not do the actual
         * update, it simply scales the canvas. The actual redraw happens once the map is idle.
         * \@memberof GoogleCanvasOverly
         * \@method
         * @return {?}
         */
            function () {
                /** @type {?} */
                var map = this.GetMap();
                {
                    /** @type {?} */
                    var zoomCurrent = map.getZoom();
                    /** @type {?} */
                    var centerCurrent = map.getCenter();
                    /** @type {?} */
                    var scale = Math.pow(2, zoomCurrent - this._zoomStart);
                    /** @type {?} */
                    var el = map.getDiv();
                    /** @type {?} */
                    var w = el.offsetWidth;
                    /** @type {?} */
                    var h = el.offsetHeight;
                    /** @type {?} */
                    var newWidth = w * scale;
                    /** @type {?} */
                    var newHeight = h * scale;
                    /** @type {?} */
                    var projection = ((this)).getProjection();
                    /** @type {?} */
                    var cc = projection.fromLatLngToDivPixel(centerCurrent);
                    // Update the canvas CSS position and dimensions.
                    this.UpdatePosition(cc.x - newWidth / 2, cc.y - newHeight / 2, newWidth, newHeight);
                }
            };
        /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnLoad = /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var map = ((this)).getMap();
                // Get the current map view information.
                this._zoomStart = map.getZoom();
                /** @type {?} */
                var c = map.getCenter();
                this._centerStart = {
                    latitude: c.lat(),
                    longitude: c.lng()
                };
                // When the map stops moving, render new data on the canvas.
                this._viewChangeEndEvent = google.maps.event.addListener(map, 'idle', function (e) {
                    _this.UpdateCanvas();
                });
                // Update the position of the overlay when the map is resized.
                this._mapResizeEvent = google.maps.event.addListener(map, 'resize', function (e) {
                    _this.UpdateCanvas();
                });
            };
        /**
         * Associates the cnavas overlay with a map.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @param {?} map
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.SetMap = /**
         * Associates the cnavas overlay with a map.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @param {?} map
         * @return {?}
         */
            function (map) {
                ((this)).setMap(map);
            };
        ///
        /// Protected methods
        ///
        /**
         * Attaches the canvas to the map.
         * @memberof CanvasOverlay
         * @method
         */
        /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.SetCanvasElement = /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
            function (el) {
                /** @type {?} */
                var panes = ((this)).getPanes();
                if (panes) {
                    if (el != null) {
                        panes.overlayLayer.appendChild(el);
                        // 4: floatPane (infowindow)
                        // 3: overlayMouseTarget (mouse events)
                        // 2: markerLayer (marker images)
                        // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)
                        // 0: mapPane (lowest pane above the map tiles)
                    }
                    else {
                        panes.overlayLayer.removeChild(this._canvas);
                    }
                }
            };
        /**
         * Remove the map event handlers.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.RemoveEventHandlers = /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                // Remove all event handlers from the map.
                if (this._viewChangeEndEvent) {
                    google.maps.event.removeListener(this._viewChangeEndEvent);
                }
                if (this._mapResizeEvent) {
                    google.maps.event.removeListener(this._mapResizeEvent);
                }
            };
        /**
         * Updates the Canvas size based on the map size.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.Resize = /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var map = ((this)).getMap();
                /** @type {?} */
                var el = map.getDiv();
                this._canvas.width = el.offsetWidth;
                this._canvas.height = el.offsetHeight;
            };
        /**
         * Updates the Canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.UpdateCanvas = /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var map = ((this)).getMap();
                // Only render the canvas if it isn't in streetside mode.
                {
                    this._canvas.style.display = '';
                    /** @type {?} */
                    var el = map.getDiv();
                    /** @type {?} */
                    var w = el.offsetWidth;
                    /** @type {?} */
                    var h = el.offsetHeight;
                    /** @type {?} */
                    var centerPoint = ((this)).getProjection().fromLatLngToDivPixel(map.getCenter());
                    this.UpdatePosition((centerPoint.x - w / 2), (centerPoint.y - h / 2), w, h);
                    // Redraw the canvas.
                    this.Redraw(true);
                    // Get the current map view information.
                    this._zoomStart = map.getZoom();
                    /** @type {?} */
                    var c = map.getCenter();
                    this._centerStart = {
                        latitude: c.lat(),
                        longitude: c.lng()
                    };
                }
            };
        return GoogleCanvasOverlay;
    }(CanvasOverlay));
    /**
     * Helper function to extend the OverlayView into the CanvasOverlay
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinCanvasOverlay$1() {
        new Extender(GoogleCanvasOverlay)
            .Extend(new google.maps.OverlayView)
            .Map('onAdd', 'OnAdd')
            .Map('draw', 'OnDraw')
            .Map('onRemove', 'OnRemove');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements a factory to create all the implementation specifc services for a map implementation
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapServiceFactory = (function () {
        function MapServiceFactory() {
        }
        MapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        return MapServiceFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract class to implement map api. A concrete implementation should be created for each
     * Map provider supported (e.g. Bing, Goolge, ESRI)
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapService = (function () {
        function MapService() {
        }
        /**
         * Gets a random geo locations filling the bounding box.
         *
         * \@memberof MapService
         * @param {?} count - number of locations to return
         * @param {?} bounds  - bounding box.
         * @return {?} - Array of geo locations.
         */
        MapService.GetRandonLocations = /**
         * Gets a random geo locations filling the bounding box.
         *
         * \@memberof MapService
         * @param {?} count - number of locations to return
         * @param {?} bounds  - bounding box.
         * @return {?} - Array of geo locations.
         */
            function (count, bounds) {
                /** @type {?} */
                var a = [];
                /** @type {?} */
                var _getRandomLocation = function (b) {
                    /** @type {?} */
                    var lat = Math.random() * (b.maxLatitude - b.minLatitude) + b.minLatitude;
                    /** @type {?} */
                    var lng = 0;
                    if (crossesDateLine) {
                        lng = Math.random() * (b.minLongitude + 360 - b.maxLongitude) + b.maxLongitude;
                        if (lng > 180) {
                            lng = lng - 360;
                        }
                    }
                    else {
                        lng = Math.random() * (b.maxLongitude - b.minLongitude) + b.minLongitude;
                    }
                    /** @type {?} */
                    var p = { latitude: lat, longitude: lng };
                    return p;
                };
                /** @type {?} */
                var crossesDateLine = false;
                if (bounds == null) {
                    bounds = /** @type {?} */ ({
                        maxLatitude: 360,
                        minLatitude: 0,
                        maxLongitude: 170,
                        minLongitude: 0
                    });
                }
                if (bounds.center.longitude < bounds.minLongitude || bounds.center.longitude > bounds.maxLongitude) {
                    crossesDateLine = true;
                }
                if (!count || count <= 0) {
                    return [_getRandomLocation(bounds)];
                }
                for (var r = 0; r < count; r++) {
                    a.push(_getRandomLocation(bounds));
                }
                return a;
            };
        MapService.decorators = [
            { type: core.Injectable },
        ];
        return MapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a marker service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var MarkerService = (function () {
        function MarkerService() {
        }
        MarkerService.decorators = [
            { type: core.Injectable },
        ];
        return MarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This class defines the contract for an InfoBoxService. Each Map Architecture provider is expected the furnish a concrete implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var InfoBoxService = (function () {
        function InfoBoxService() {
        }
        InfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        return InfoBoxService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract class to to define the layer service contract. Must be realized by implementing provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var LayerService = (function () {
        function LayerService() {
        }
        LayerService.decorators = [
            { type: core.Injectable },
        ];
        return LayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a polygon service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var PolygonService = (function () {
        function PolygonService() {
        }
        PolygonService.decorators = [
            { type: core.Injectable },
        ];
        return PolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a polyline service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var PolylineService = (function () {
        function PolylineService() {
        }
        PolylineService.decorators = [
            { type: core.Injectable },
        ];
        return PolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract class to to define teh cluster layer service contract. Must be realized by implementing provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var ClusterService = (function (_super) {
        __extends(ClusterService, _super);
        function ClusterService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ClusterService.decorators = [
            { type: core.Injectable },
        ];
        return ClusterService;
    }(LayerService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * InfoBoxAction renders an action in an info window {\@link InfoBox}
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *    .map-container { height: 300px; }
     *  `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'">
     *        <x-info-box>
     *          <x-info-box-action [Label]="actionlabel" (ActionClicked)="actionClicked(this)"></x-info-box-action>
     *        </x-info-box>
     *      </x-map-marker>
     *    </x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var InfoBoxActionDirective = (function () {
        function InfoBoxActionDirective() {
            /**
             * Emits an event when the action has been clicked
             *
             * \@memberof InfoBoxActionDirective
             */
            this.ActionClicked = new core.EventEmitter();
        }
        InfoBoxActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-info-box-action'
                    },] },
        ];
        InfoBoxActionDirective.propDecorators = {
            Label: [{ type: core.Input }],
            ActionClicked: [{ type: core.Output }]
        };
        return InfoBoxActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * internal counter to use as ids for multiple infoboxes.
      @type {?} */
    var infoBoxId = 0;
    /**
     * InfoBox renders a info window inside a {\@link MapMarkerDirective} or standalone.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *    .map-container { height: 300px; }
     * `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'">
     *        <x-info-box [DisableAutoPan]="true">
     *          Hi, this is the content of the <strong>info window</strong>
     *         </x-info-box>
     *       </x-map-marker>
     *     </x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var InfoBoxComponent = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of InfoBoxComponent.
         * @param _infoBoxService - Concrete {@link InfoBoxService} implementation for underlying Map architecture.
         *
         * @memberof InfoBoxComponent
         */
        function InfoBoxComponent(_infoBoxService) {
            this._infoBoxService = _infoBoxService;
            this._infoBoxAddedToManager = false;
            this._id = (infoBoxId++).toString();
            /**
             * Determine whether only one infobox can be open at a time. Note that ANY info box settings.
             *
             * \@memberof InfoBoxComponent
             */
            this.Modal = true;
            /**
             * Determines visibility of infobox
             *
             * \@memberof InfoBoxComponent
             */
            this.Visible = false;
            /**
             * Determines if other info boxes should be closed before opening this one
             *
             * \@memberof InfoBoxComponent
             */
            this.CloseInfoBoxesOnOpen = true;
            /**
             * Emits an event when the info window is closed.
             *
             * \@memberof InfoBoxComponent
             */
            this.InfoBoxClose = new core.EventEmitter();
        }
        Object.defineProperty(InfoBoxComponent.prototype, "HtmlContent", {
            get: /**
             * Gets the HTML content of the info box.
             *
             * \@readonly
             * \@memberof InfoBoxComponent
             * @return {?}
             */ function () {
                if (this._content.nativeElement && this._content.nativeElement.innerText && this._content.nativeElement.innerText.trim() !== '') {
                    return this._content.nativeElement.outerHTML;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfoBoxComponent.prototype, "Id", {
            get: /**
             * Gets the Id of the info box as a string.
             *
             * \@readonly
             * \@memberof InfoBoxComponent
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Closes the Infobox.
         *
         * \@memberof InfoBoxComponent
         * @return {?}
         */
        InfoBoxComponent.prototype.Close = /**
         * Closes the Infobox.
         *
         * \@memberof InfoBoxComponent
         * @return {?}
         */
            function () {
                var _this = this;
                return this._infoBoxService.Close(this).then(function () {
                    _this.InfoBoxClose.emit(_this._id);
                });
            };
        /**
         * Called on after component view as been initialized. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
        InfoBoxComponent.prototype.ngAfterViewInit = /**
         * Called on after component view as been initialized. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
            function () {
                this._infoBoxService.AddInfoWindow(this);
                this._infoBoxAddedToManager = true;
                this.HandleEvents();
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        InfoBoxComponent.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._infoBoxAddedToManager) {
                    return;
                }
                if ((changes['latitude'] || changes['longitude']) && typeof this.Latitude === 'number' &&
                    typeof this.Longitude === 'number') {
                    this._infoBoxService.SetPosition(this, {
                        latitude: changes['latitude'].currentValue,
                        longitude: changes['longitude'].currentValue
                    });
                }
                this.SetInfoWindowOptions(changes);
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
        InfoBoxComponent.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
            function () { this._infoBoxService.DeleteInfoWindow(this); };
        /**
         * Opens a closed info window.
         *
         * \@memberof InfoBoxComponent
         * @param {?=} loc
         * @return {?} - Promise that is fullfilled when the infobox has been opened.
         *
         */
        InfoBoxComponent.prototype.Open = /**
         * Opens a closed info window.
         *
         * \@memberof InfoBoxComponent
         * @param {?=} loc
         * @return {?} - Promise that is fullfilled when the infobox has been opened.
         *
         */
            function (loc) {
                return this._infoBoxService.Open(this, loc);
            };
        /**
         * Returns a string representation of the info box.
         *
         * \@memberof InfoBoxComponent
         * @return {?} - string representation of the info box.
         *
         */
        InfoBoxComponent.prototype.ToString = /**
         * Returns a string representation of the info box.
         *
         * \@memberof InfoBoxComponent
         * @return {?} - string representation of the info box.
         *
         */
            function () { return 'InfoBoxComponent-' + this._id; };
        /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        InfoBoxComponent.prototype.HandleEvents = /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._infoBoxService.CreateEventObservable('infowindowclose', this).subscribe(function (e) {
                    _this.InfoBoxClose.emit(_this._id);
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof InfoBoxComponent
         * @param {?} changes
         *
         * @return {?}
         */
        InfoBoxComponent.prototype.SetInfoWindowOptions = /**
         * Sets the info window options
         *
         * \@memberof InfoBoxComponent
         * @param {?} changes
         *
         * @return {?}
         */
            function (changes) {
                /** @type {?} */
                var options = {};
                if (changes['title']) {
                    options.title = this.Title;
                }
                if (changes['description']) {
                    options.description = this.Description;
                }
                if (changes['disableAutoPan']) {
                    options.disableAutoPan = this.DisableAutoPan;
                }
                if (changes['visible']) {
                    options.visible = this.Visible;
                }
                if (changes['xOffset'] || changes['yOffset']) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    options.pixelOffset.x = this.xOffset;
                    options.pixelOffset.y = this.yOffset;
                }
                this._infoBoxService.SetOptions(this, options);
            };
        InfoBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'x-info-box',
                        template: "\n        <div #infoBoxContent class='info-box-content'>\n            <ng-content></ng-content>\n        </div>",
                        styles: ["\n        x-map .MicrosoftMap .Infobox .infobox-title { padding: 10px 10px 5px 10px }\n        x-map .MicrosoftMap .Infobox .infobox-info { padding: 3px 10px 10px 10px }\n        x-map .MicrosoftMap .Infobox .infobox-actions { height: auto }\n    "],
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        InfoBoxComponent.ctorParameters = function () {
            return [
                { type: InfoBoxService }
            ];
        };
        InfoBoxComponent.propDecorators = {
            _content: [{ type: core.ViewChild, args: ['infoBoxContent',] }],
            InfoWindowActions: [{ type: core.ContentChildren, args: [InfoBoxActionDirective,] }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Description: [{ type: core.Input }],
            DisableAutoPan: [{ type: core.Input }],
            MaxWidth: [{ type: core.Input }],
            Modal: [{ type: core.Input }],
            HostMarker: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            xOffset: [{ type: core.Input }],
            yOffset: [{ type: core.Input }],
            CloseInfoBoxesOnOpen: [{ type: core.Input }],
            InfoBoxClose: [{ type: core.Output }]
        };
        return InfoBoxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * internal counter to use as ids for marker.
      @type {?} */
    var markerId = 0;
    /**
     * MapMarkerDirective renders a map marker inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'"></x-map-marker>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapMarkerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapMarkerDirective.
         * @param _markerService - Concreate implementation of a {@link MarkerService}.
         * @param _containerRef - View container hosting the marker.
         * Used to determine parent layer through markup.
         *
         * @memberof MapMarkerDirective
         */
        function MapMarkerDirective(_markerService, _containerRef) {
            this._markerService = _markerService;
            this._containerRef = _containerRef;
            this._clickTimeout = null;
            this._events = [];
            this._inClusterLayer = false;
            this._inCustomLayer = false;
            this._markerAddedToManger = false;
            /**
             * This event is fired when the DOM dblclick event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * If true, the marker can be dragged. Default value is false.
             *
             * \@memberof MapMarkerDirective
             */
            this.Draggable = false;
            /**
             * This event is fired when the user starts dragging the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event emitter gets emitted when a marker icon is being created.
             *
             * \@memberof MapMarkerDirective
             */
            this.DynamicMarkerCreated = new core.EventEmitter();
            /**
             * True to indiciate whether this is the first marker in a set.
             * Use this for bulk operations (particularily clustering) to ensure performance.
             *
             * \@memberof MapMarkerDirective
             */
            this.IsFirstInSet = false;
            /**
             * True to indiciate whether this is the last marker in a set.
             * Use this for bulk operations (particularily clustering) to ensure performance.
             *
             * \@memberof MapMarkerDirective
             */
            this.IsLastInSet = true;
            /**
             * This event emitter gets emitted when the user clicks on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MarkerClick = new core.EventEmitter();
            /**
             * Arbitary metadata to assign to the Marker. This is useful for events
             *
             * \@memberof MapMarkerDirective
             */
            this.Metadata = new Map();
            /**
             * This event is fired when the DOM mousedown event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on marker mouseout.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on marker mouseover.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the marker
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This even is fired when the marker is right-clicked on.
             *
             * \@memberof MapMarkerDirective
             */
            this.RightClick = new core.EventEmitter();
            this._id = (markerId++).toString();
        }
        Object.defineProperty(MapMarkerDirective.prototype, "AddedToManager", {
            get: /**
             * Getswhether the marker has already been added to the marker service and is ready for use.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._markerAddedToManger; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker as a string.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "InClusterLayer", {
            get: /**
             * Gets whether the marker is in a cluster layer. See {\@link ClusterLayer}.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._inClusterLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the marker is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the marker belongs to.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        /**
         * Translates a marker geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerDirective
         * @param {?=} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
        MapMarkerDirective.prototype.LocationToPixel = /**
         * Translates a marker geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerDirective
         * @param {?=} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
            function (loc) {
                return this._markerService.LocationToPoint(loc ? loc : this);
            };
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                if (this._infoBox != null) {
                    this._infoBox.HostMarker = this;
                }
                if (this._containerRef.element.nativeElement.parentElement) {
                    /** @type {?} */
                    var parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-cluster-layer') {
                        this._inClusterLayer = true;
                    }
                    else if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                    }
                    this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                }
                if (!this._markerAddedToManger) {
                    this._markerService.AddMarker(this);
                    this._markerAddedToManger = true;
                    this.AddEventListeners();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        MapMarkerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                if (typeof this.Latitude !== 'number' || typeof this.Longitude !== 'number') {
                    return;
                }
                if (!this._markerAddedToManger) {
                    return;
                }
                if (changes['Latitude'] || changes['Longitude']) {
                    this._markerService.UpdateMarkerPosition(this);
                }
                if (changes['Title']) {
                    this._markerService.UpdateTitle(this);
                }
                if (changes['Label']) {
                    this._markerService.UpdateLabel(this);
                }
                if (changes['Draggable']) {
                    this._markerService.UpdateDraggable(this);
                }
                if (changes['IconUrl'] || changes['IconInfo']) {
                    this._markerService.UpdateIcon(this);
                }
                if (changes['Anchor']) {
                    this._markerService.UpdateAnchor(this);
                }
                if (changes['Visible']) {
                    this._markerService.UpdateVisible(this);
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                this._markerService.DeleteMarker(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerDirective
         * @return {?} - string representation of the marker id.
         */
        MapMarkerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapMarker-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var _getEventArg = function (e) {
                    return {
                        Marker: _this,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    };
                };
                this._events.push(this._markerService.CreateEventObservable('click', this).subscribe(function (e) {
                    ///
                    /// this is necessary since map will treat a doubleclick first as two clicks...'
                    ///
                    _this._clickTimeout = rxjs.timer(300).subscribe(function (n) {
                        if (_this._infoBox != null) {
                            _this._infoBox.Open(_this._markerService.GetCoordinatesFromClick(e));
                        }
                        _this.MarkerClick.emit(_getEventArg(e));
                    });
                }));
                this._events.push(this._markerService.CreateEventObservable('dblclick', this).subscribe(function (e) {
                    if (_this._clickTimeout) {
                        _this._clickTimeout.unsubscribe();
                        _this._clickTimeout = null;
                    }
                    _this.DblClick.emit(_getEventArg(e));
                }));
                /** @type {?} */
                var handlers = [
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                ];
                handlers.forEach(function (obj) {
                    /** @type {?} */
                    var os = _this._markerService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        MapMarkerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-marker'
                    },] },
        ];
        /** @nocollapse */
        MapMarkerDirective.ctorParameters = function () {
            return [
                { type: MarkerService },
                { type: core.ViewContainerRef }
            ];
        };
        MapMarkerDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Anchor: [{ type: core.Input }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            Draggable: [{ type: core.Input }],
            DragStart: [{ type: core.Output }],
            DynamicMarkerCreated: [{ type: core.Output }],
            Height: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            IconUrl: [{ type: core.Input }],
            IsFirstInSet: [{ type: core.Input }],
            IsLastInSet: [{ type: core.Input }],
            Label: [{ type: core.Input }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            MarkerClick: [{ type: core.Output }],
            Metadata: [{ type: core.Input }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            Width: [{ type: core.Input }]
        };
        return MapMarkerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Renders a map based on a given provider.
     * **Important note**: To be able see a map in the browser, you have to define a height for the CSS
     * class `map-container`.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map',
     *  styles: [`
     *    .map-container { height: 300px; }
     * `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom"></x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var MapComponent = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapComponent.
         *
         * @param _mapService - Concreted implementation of a map service for the underlying maps implementations.
         *                                   Generally provided via injections.
         * @memberof MapComponent
         */
        function MapComponent(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._longitude = 0;
            this._latitude = 0;
            this._zoom = 0;
            this._options = {};
            this._box = null;
            this._containerClass = true;
            /**
             * This event emitter is fired when the map bounding box changes.
             *
             * \@memberof MapComponent
             */
            this.BoundsChange = new core.EventEmitter();
            /**
             * This event emitter is fired when the map center changes.
             *
             * \@memberof MapComponent
             */
            this.CenterChange = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user clicks on the map (but not when they click on a
             * marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapDblClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user right-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapRightClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseOver = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseOut = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseMove = new core.EventEmitter();
            /**
             * The event emitter is fired when the map service is available and the maps has been
             * Initialized (but not necessarily created). It contains a Promise that when fullfilled returns
             * the main map object of the underlying platform.
             *
             * \@memberof MapComponent
             */
            this.MapPromise = new core.EventEmitter();
            /**
             * This event emiiter is fired when the map zoom changes
             *
             * \@memberof MapComponent
             */
            this.ZoomChange = new core.EventEmitter();
            /**
             * This event emitter is fired when the map service is available and the maps has been
             * Initialized
             * \@memberOf MapComponent
             */
            this.MapService = new core.EventEmitter();
        }
        Object.defineProperty(MapComponent.prototype, "Box", {
            ///
            /// Property declarations
            ///
            /**
             * Get or sets the maximum and minimum bounding box for map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Get or sets the maximum and minimum bounding box for map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._box; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._box = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Latitude", {
            /**
             * Gets or sets the latitude that sets the center of the map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the latitude that sets the center of the map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._longitude; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._latitude = this.ConvertToDecimal(value);
                this.UpdateCenter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Longitude", {
            /**
             * Gets or sets the longitude that sets the center of the map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the longitude that sets the center of the map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._longitude; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._longitude = this.ConvertToDecimal(value);
                this.UpdateCenter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Options", {
            /**
             * Gets or sets general map Options
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets general map Options
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._options; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._options = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Zoom", {
            /**
             * Gets or sets the zoom level of the map. The default value is `8`.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the zoom level of the map. The default value is `8`.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._zoom; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._zoom = this.ConvertToDecimal(value, 8);
                if (typeof this._zoom === 'number') {
                    this._mapService.SetZoom(this._zoom);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.ngOnInit = /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                this.InitMapInstance(this._container.nativeElement);
                this.MapPromise.emit(this._mapService.MapPromise);
                this.MapService.emit(this._mapService);
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapComponent.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (this._mapPromise) {
                    if (changes['Box']) {
                        if (this._box != null) {
                            this._mapService.SetViewOptions(/** @type {?} */ ({
                                bounds: this._box
                            }));
                        }
                    }
                    if (changes['Options']) {
                        this._mapService.SetMapOptions(this._options);
                    }
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                this._mapService.DisposeMap();
            };
        /**
         * Triggers a resize event on the map instance.
         *
         * \@memberof MapComponent
         * @return {?} - A promise that gets resolved after the event was triggered.
         *
         */
        MapComponent.prototype.TriggerResize = /**
         * Triggers a resize event on the map instance.
         *
         * \@memberof MapComponent
         * @return {?} - A promise that gets resolved after the event was triggered.
         *
         */
            function () {
                var _this = this;
                // Note: When we would trigger the resize event and show the map in the same turn (which is a
                // common case for triggering a resize event), then the resize event would not
                // work (to show the map), so we trigger the event in a timeout.
                return new Promise(function (resolve) {
                    setTimeout(function () { return _this._mapService.TriggerMapEvent('resize').then(function () { return resolve(); }); });
                });
            };
        /**
         * Converts a number-ish value to a number.
         *
         * \@memberof MapComponent
         * @param {?} value - The value to convert.
         * @param {?=} defaultValue
         * @return {?} - Converted number of the default.
         *
         */
        MapComponent.prototype.ConvertToDecimal = /**
         * Converts a number-ish value to a number.
         *
         * \@memberof MapComponent
         * @param {?} value - The value to convert.
         * @param {?=} defaultValue
         * @return {?} - Converted number of the default.
         *
         */
            function (value, defaultValue) {
                if (defaultValue === void 0) {
                    defaultValue = null;
                }
                if (typeof value === 'string') {
                    return parseFloat(value);
                }
                else if (typeof value === 'number') {
                    return /** @type {?} */ (value);
                }
                return defaultValue;
            };
        /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapClickEvents = /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('click').subscribe(function (e) {
                    //
                    // this is necessary since bing will treat a doubleclick first as two clicks...'
                    //
                    // this is necessary since bing will treat a doubleclick first as two clicks...'
                    ///
                    _this._clickTimeout = setTimeout(function () {
                        _this.MapClick.emit(/** @type {?} */ (e));
                    }, 300);
                });
                this._mapService.SubscribeToMapEvent('dblclick').subscribe(function (e) {
                    if (_this._clickTimeout) {
                        clearTimeout(/** @type {?} */ (_this._clickTimeout));
                    }
                    _this.MapDblClick.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('rightclick').subscribe(function (e) {
                    _this.MapRightClick.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mouseover').subscribe(function (e) {
                    _this.MapMouseOver.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mouseout').subscribe(function (e) {
                    _this.MapMouseOut.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mousemove').subscribe(function (e) {
                    _this.MapMouseMove.emit(/** @type {?} */ (e));
                });
            };
        /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapBoundsChange = /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('boundschanged').subscribe(function () {
                    _this._mapService.GetBounds().then(function (bounds) {
                        _this.BoundsChange.emit(bounds);
                    });
                });
            };
        /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapCenterChange = /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('centerchanged').subscribe(function () {
                    _this._mapService.GetCenter().then(function (center) {
                        if (_this._latitude !== center.latitude || _this._longitude !== center.longitude) {
                            _this._latitude = center.latitude;
                            _this._longitude = center.longitude;
                            _this.CenterChange.emit(/** @type {?} */ ({ latitude: _this._latitude, longitude: _this._longitude }));
                        }
                    });
                });
            };
        /**
         * Delegate handling map zoom change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapZoomChange = /**
         * Delegate handling map zoom change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('zoomchanged').subscribe(function () {
                    _this._mapService.GetZoom().then(function (z) {
                        if (_this._zoom !== z) {
                            _this._zoom = z;
                            _this.ZoomChange.emit(z);
                        }
                    });
                });
            };
        /**
         * Initializes the map.
         *
         * \@memberof MapComponent
         * @param {?} el - Html elements which will host the map canvas.
         *
         * @return {?}
         */
        MapComponent.prototype.InitMapInstance = /**
         * Initializes the map.
         *
         * \@memberof MapComponent
         * @param {?} el - Html elements which will host the map canvas.
         *
         * @return {?}
         */
            function (el) {
                var _this = this;
                this._zone.runOutsideAngular(function () {
                    if (_this._options.center == null) {
                        _this._options.center = { latitude: _this._latitude, longitude: _this._longitude };
                    }
                    if (_this._options.zoom == null) {
                        _this._options.zoom = _this._zoom;
                    }
                    if (_this._options.mapTypeId == null) {
                        _this._options.mapTypeId = MapTypeId.hybrid;
                    }
                    if (_this._box != null) {
                        _this._options.bounds = _this._box;
                    }
                    _this._mapPromise = _this._mapService.CreateMap(el, _this._options);
                    _this.HandleMapCenterChange();
                    _this.HandleMapBoundsChange();
                    _this.HandleMapZoomChange();
                    _this.HandleMapClickEvents();
                });
            };
        /**
         * Updates the map center based on the geo properties of the component.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.UpdateCenter = /**
         * Updates the map center based on the geo properties of the component.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                if (typeof this._latitude !== 'number' || typeof this._longitude !== 'number') {
                    return;
                }
                this._mapService.SetCenter({
                    latitude: this._latitude,
                    longitude: this._longitude,
                });
            };
        MapComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'x-map',
                        providers: [
                            { provide: MapService, deps: [MapServiceFactory], useFactory: MapServiceCreator },
                            { provide: MarkerService, deps: [MapServiceFactory, MapService, LayerService, ClusterService], useFactory: MarkerServiceFactory },
                            {
                                provide: InfoBoxService, deps: [MapServiceFactory, MapService,
                                    MarkerService], useFactory: InfoBoxServiceFactory
                            },
                            { provide: LayerService, deps: [MapServiceFactory, MapService], useFactory: LayerServiceFactory },
                            { provide: ClusterService, deps: [MapServiceFactory, MapService], useFactory: ClusterServiceFactory },
                            { provide: PolygonService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolygonServiceFactory },
                            { provide: PolylineService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolylineServiceFactory }
                        ],
                        template: "\n        <div #container class='map-container-inner'></div>\n        <div class='map-content'>\n            <ng-content></ng-content>\n        </div>\n    ",
                        styles: ["\n        .map-container-inner { width: inherit; height: inherit; }\n        .map-container-inner div { background-repeat: no-repeat; }\n        .map-content { display:none; }\n    "],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MapComponent.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapComponent.propDecorators = {
            _containerClass: [{ type: core.HostBinding, args: ['class.map-container',] }],
            _container: [{ type: core.ViewChild, args: ['container',] }],
            _markers: [{ type: core.ContentChildren, args: [MapMarkerDirective,] }],
            Box: [{ type: core.Input }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            Options: [{ type: core.Input }],
            Zoom: [{ type: core.Input }],
            BoundsChange: [{ type: core.Output }],
            CenterChange: [{ type: core.Output }],
            MapClick: [{ type: core.Output }],
            MapDblClick: [{ type: core.Output }],
            MapRightClick: [{ type: core.Output }],
            MapMouseOver: [{ type: core.Output }],
            MapMouseOut: [{ type: core.Output }],
            MapMouseMove: [{ type: core.Output }],
            MapPromise: [{ type: core.Output }],
            ZoomChange: [{ type: core.Output }],
            MapService: [{ type: core.Output }]
        };
        return MapComponent;
    }());
    /**
     * Factory function to generate a cluster service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @return {?} - A concrete instance of a Cluster Service based on the underlying map architecture
     */
    function ClusterServiceFactory(f, m) { return f.CreateClusterService(m); }
    /**
     * Factory function to generate a infobox service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} ma
     * @return {?} - A concrete instance of a InfoBox Service based on the underlying map architecture.
     */
    function InfoBoxServiceFactory(f, m, ma) { return f.CreateInfoBoxService(m, ma); }
    /**
     * Factory function to generate a layer service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @return {?} - A concrete instance of a Layer Service based on the underlying map architecture.
     */
    function LayerServiceFactory(f, m) { return f.CreateLayerService(m); }
    /**
     * Factory function to generate a map service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @return {?} - A concrete instance of a MapService based on the underlying map architecture.
     */
    function MapServiceCreator(f) { return f.Create(); }
    /**
     * Factory function to generate a marker service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @param {?} c - A {\@link ClusterService} instance.
     * @return {?} - A concrete instance of a Marker Service based on the underlying map architecture.
     */
    function MarkerServiceFactory(f, m, l, c) {
        return f.CreateMarkerService(m, l, c);
    }
    /**
     * Factory function to generate a polygon service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @return {?} - A concrete instance of a Polygon Service based on the underlying map architecture.
     */
    function PolygonServiceFactory(f, m, l) {
        return f.CreatePolygonService(m, l);
    }
    /**
     * Factory function to generate a polyline service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @return {?} - A concrete instance of a Polyline Service based on the underlying map architecture.
     */
    function PolylineServiceFactory(f, m, l) {
        return f.CreatePolylineService(m, l);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * internal counter to use as ids for multiple layers.
      @type {?} */
    var layerId = 0;
    /**
     * MapLayerDirective creates a layer on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
     *     <x-map-layer [Visible]='visible'>
     *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
     *     </x-map-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapLayerDirective.
         * @param _layerService - Concreted implementation of a layer service for the underlying maps implementations.
         * Generally provided via injections.
         * @param _containerRef - Reference to the container hosting the map canvas. Generally provided via injection.
         *
         * @memberof MapLayerDirective
         */
        function MapLayerDirective(_layerService, _containerRef) {
            this._layerService = _layerService;
            this._containerRef = _containerRef;
            this._visible = true;
            this._addedToManager = false;
            this._id = layerId++;
        }
        Object.defineProperty(MapLayerDirective.prototype, "Visible", {
            ///
            /// Property declarations
            ///
            /**
             * Gets or sets the layer visibility.
             *
             * @memberof MapLayerDirective
             */
            get: /**
             * Gets or sets the layer visibility.
             *
             * \@memberof MapLayerDirective
             * @return {?}
             */ function () { return this._visible; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._visible = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapLayerDirective.prototype, "Id", {
            get: /**
             * Gets the layer id.
             *
             * \@readonly
             * \@memberof MapLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnInit = /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
            function () {
                this._containerRef.element.nativeElement.attributes['layerId'] = this._id.toString();
                this._layerService.AddLayer(this);
                this._addedToManager = true;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToManager) {
                    return;
                }
                if (changes['Visible']) {
                    this._layerService.GetNativeLayer(this).then(function (l) {
                        l.SetVisible(!l.GetVisible());
                    });
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
            function () {
                this._layerService.DeleteLayer(this);
            };
        MapLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-layer'
                    },] },
        ];
        /** @nocollapse */
        MapLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: core.ViewContainerRef }
            ];
        };
        MapLayerDirective.propDecorators = {
            _markers: [{ type: core.ContentChildren, args: [MapMarkerDirective,] }],
            Visible: [{ type: core.Input }]
        };
        return MapLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * Creates a cluster layer on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
     *     <x-cluster-layer [Visible]='visible'>
     *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
     *     </x-cluster-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var ClusterLayerDirective = (function (_super) {
        __extends(ClusterLayerDirective, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of ClusterLayerDirective.
         *
         * @param _layerService - Concreted implementation of a cluster layer service for the underlying maps
         * implementations. Generally provided via injections.
         * @param _containerRef - A reference to the view container of the layer. Generally provided via injection.
         *
         * @memberof ClusterLayerDirective
         */
        function ClusterLayerDirective(_layerService, _containerRef) {
            var _this = _super.call(this, _layerService, _containerRef) || this;
            _this._clusteringEnabled = true;
            _this._clusterPlacementMode = ClusterPlacementMode.MeanValue;
            _this._clusterClickAction = ClusterClickAction.ZoomIntoCluster;
            _this._useDynamicSizeMarker = false;
            _this._dynamicMarkerBaseSize = 18;
            _this._dynamicMarkerRanges = new Map([
                [10, 'rgba(20, 180, 20, 0.5)'],
                [100, 'rgba(255, 210, 40, 0.5)'],
                [Number.MAX_SAFE_INTEGER, 'rgba(255, 40, 40, 0.5)']
            ]);
            _this._zoomOnClick = true;
            return _this;
        }
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusterClickAction", {
            ///
            /// Property defintions
            ///
            /**
             * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the the Cluster Click Action {\@link ClusterClickAction}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusterClickAction; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusterClickAction = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusteringEnabled", {
            /**
             * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
             * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
             * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusteringEnabled; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusteringEnabled = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusterPlacementMode", {
            /**
             * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the cluster placement mode. {\@link ClusterPlacementMode}
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusterPlacementMode; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusterPlacementMode = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "CustomMarkerCallback", {
            /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {\@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._iconCreationCallback; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._useDynamicSizeMarker) {
                    throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
                }
                this._iconCreationCallback = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerBaseSize", {
            /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerBaseSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerBaseSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerRanges", {
            /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerRanges; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerRanges = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "GridSize", {
            /**
             * Gets or sets the grid size to be used for clustering.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the grid size to be used for clustering.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._gridSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._gridSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "IconInfo", {
            /**
             * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
             * See {@link IMarkerIconInfo}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
             * See {\@link IMarkerIconInfo}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._iconInfo; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._iconInfo = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "LayerOffset", {
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._layerOffset; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._layerOffset = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "MinimumClusterSize", {
            /**
             * Gets or sets the minimum pins required to form a cluster
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the minimum pins required to form a cluster
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._minimumClusterSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._minimumClusterSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "SpiderClusterOptions", {
            /**
             * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the options for spider clustering behavior. See {\@link ISpiderClusterOptions}
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._spiderClusterOptions; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._spiderClusterOptions = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "Styles", {
            /**
             * Gets or sets the cluster styles
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the cluster styles
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._styles; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._styles = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "UseDynamicSizeMarkers", {
            /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._useDynamicSizeMarker; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._useDynamicSizeMarker = val;
                if (val) {
                    this._iconCreationCallback = function (m, info) {
                        return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ZIndex", {
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._zIndex; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._zIndex = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ZoomOnClick", {
            /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._zoomOnClick; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._zoomOnClick = val; },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} size - The number of markers in the cluster.
         * @param {?} info  - The icon info to be used. This will be hydrated with
         * the actualy dimensions of the created markers and is used by the underlying model/services
         * to correctly offset the marker for correct positioning.
         * @param {?} baseMarkerSize - The base size for dynmic markers.
         * @param {?} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
         * @return {?} - An string containing the SVG for the marker.
         *
         */
        ClusterLayerDirective.CreateDynamicSizeMarker = /**
         * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} size - The number of markers in the cluster.
         * @param {?} info  - The icon info to be used. This will be hydrated with
         * the actualy dimensions of the created markers and is used by the underlying model/services
         * to correctly offset the marker for correct positioning.
         * @param {?} baseMarkerSize - The base size for dynmic markers.
         * @param {?} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
         * @return {?} - An string containing the SVG for the marker.
         *
         */
            function (size, info, baseMarkerSize, ranges) {
                /** @type {?} */
                var mr = baseMarkerSize;
                /** @type {?} */
                var outline = mr * 0.35;
                /** @type {?} */
                var total = size;
                /** @type {?} */
                var r = Math.log(total) / Math.log(10) * 5 + mr;
                /** @type {?} */
                var d = r * 2;
                /** @type {?} */
                var fillColor;
                ranges.forEach(function (v, k) {
                    if (total <= k && !fillColor) {
                        fillColor = v;
                    }
                });
                if (!fillColor) {
                    fillColor = 'rgba(20, 180, 20, 0.5)';
                }
                /** @type {?} */
                var svg = ["<svg xmlns='http://www.w3.org/2000/svg' width='" + d + "' height='" + d + "'>",
                    "<circle cx='" + r + "' cy='" + r + "' r='" + r + "' fill='" + fillColor + "'/>",
                    "<circle cx='" + r + "' cy='" + r + "' r='" + (r - outline) + "' fill='" + fillColor + "'/>",
                    "</svg>"];
                info.size = { width: d, height: d };
                info.markerOffsetRatio = { x: 0.5, y: 0.5 };
                info.textOffset = { x: 0, y: r - 8 };
                return svg.join('');
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        ClusterLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToManager) {
                    return;
                }
                if (changes['ClusterClickAction']) {
                    throw (new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.'));
                }
                /** @type {?} */
                var options = { id: this._id };
                if (changes['ClusteringEnabled']) {
                    options.clusteringEnabled = this._clusteringEnabled;
                }
                if (changes['GridSize']) {
                    options.gridSize = this._gridSize;
                }
                if (changes['LayerOffset']) {
                    options.layerOffset = this._layerOffset;
                }
                if (changes['SpiderClusterOptions']) {
                    options.spiderClusterOptions = this._spiderClusterOptions;
                }
                if (changes['ZIndex']) {
                    options.zIndex = this._zIndex;
                }
                if (changes['Visible']) {
                    options.visible = this._visible;
                }
                this._layerService.GetNativeLayer(this).then(function (l) {
                    l.SetOptions(options);
                });
            };
        ClusterLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-cluster-layer'
                    },] },
        ];
        /** @nocollapse */
        ClusterLayerDirective.ctorParameters = function () {
            return [
                { type: ClusterService },
                { type: core.ViewContainerRef }
            ];
        };
        ClusterLayerDirective.propDecorators = {
            ClusterClickAction: [{ type: core.Input }],
            ClusteringEnabled: [{ type: core.Input }],
            ClusterPlacementMode: [{ type: core.Input }],
            CustomMarkerCallback: [{ type: core.Input }],
            DynamicMarkerBaseSize: [{ type: core.Input }],
            DynamicMarkerRanges: [{ type: core.Input }],
            GridSize: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            MinimumClusterSize: [{ type: core.Input }],
            SpiderClusterOptions: [{ type: core.Input }],
            Styles: [{ type: core.Input }],
            UseDynamicSizeMarkers: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            ZoomOnClick: [{ type: core.Input }]
        };
        return ClusterLayerDirective;
    }(MapLayerDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var polygonId = 0;
    /**
     *
     * MapPolygonDirective renders a polygon inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapPolygonDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map,
     *  styles: [`
     *   .map-container { height: 300px; }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polygon [Paths]="path"></x-map-polygon>
     *   </x-map>
     * `
     * })
     * ```
     *
     *
     * @export
     */
    var MapPolygonDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolygonDirective.
         * @param _polygonManager
         *
         * @memberof MapPolygonDirective
         */
        function MapPolygonDirective(_polygonService, _containerRef) {
            this._polygonService = _polygonService;
            this._containerRef = _containerRef;
            this._inCustomLayer = false;
            this._addedToService = false;
            this._events = [];
            /**
             * Gets or sets whether this Polygon handles mouse events.
             *
             * \@memberof MapPolygonDirective
             */
            this.Clickable = true;
            /**
             * If set to true, the user can drag this shape over the map.
             *
             * \@memberof MapPolygonDirective
             */
            this.Draggable = false;
            /**
             * If set to true, the user can edit this shape by dragging the control
             * points shown at the vertices and on each segment.
             *
             * \@memberof MapPolygonDirective
             */
            this.Editable = false;
            /**
             * When true, edges of the polygon are interpreted as geodesic and will
             * follow the curvature of the Earth. When false, edges of the polygon are
             * rendered as straight lines in screen space. Note that the shape of a
             * geodesic polygon may appear to change when dragged, as the dimensions
             * are maintained relative to the surface of the earth. Defaults to false.
             *
             * \@memberof MapPolygonDirective
             */
            this.Geodesic = false;
            /**
             * Arbitary metadata to assign to the Polygon. This is useful for events
             *
             * \@memberof MapPolygonDirective
             */
            this.Metadata = new Map();
            /**
             * The ordered sequence of coordinates that designates a closed loop.
             * Unlike polylines, a polygon may consist of one or more paths.
             * As a result, the paths property may specify one or more arrays of
             * LatLng coordinates. Paths are closed automatically; do not repeat the
             * first vertex of the path as the last vertex. Simple polygons may be
             * defined using a single array of LatLngs. More complex polygons may
             * specify an array of arrays (for inner loops ). Any simple arrays are converted into Arrays.
             * Inserting or removing LatLngs from the Array will automatically update
             * the polygon on the map.
             *
             * \@memberof MapPolygonDirective
             */
            this.Paths = [];
            /**
             * Whether to show the title of the polygon as the tooltip on the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.ShowTooltip = true;
            /**
             * This event is fired when the DOM click event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.Click = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * This event is fired when the user starts dragging the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousedown event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on Polygon mouseout.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on Polygon mouseover.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the Polygon
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This event is fired when the Polygon is right-clicked on.
             *
             * \@memberof MapPolygonDirective
             */
            this.RightClick = new core.EventEmitter();
            /**
             * This event is fired when editing has completed.
             *
             * \@memberof MapPolygonDirective
             */
            this.PathChanged = new core.EventEmitter();
            this._id = polygonId++;
        }
        Object.defineProperty(MapPolygonDirective.prototype, "AddedToService", {
            get: /**
             * Gets whether the polygon has been registered with the service.
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._addedToService; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "Id", {
            get: /**
             * Get the id of the polygon.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "IdAsString", {
            get: /**
             * Gets the id of the polygon as a string.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._id.toString(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the polygon is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the polygon belongs to.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        ///
        /// Public methods
        ///
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.ngAfterContentInit = /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                if (this._containerRef.element.nativeElement.parentElement) {
                    /** @type {?} */
                    var parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                        this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                    }
                }
                if (!this._addedToService) {
                    this._polygonService.AddPolygon(this);
                    this._addedToService = true;
                    this.AddEventListeners();
                }
                return;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * @param changes - Changes that have occured.
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapPolygonDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToService) {
                    return;
                }
                /** @type {?} */
                var o = this.GeneratePolygonChangeSet(changes);
                if (o != null) {
                    this._polygonService.SetOptions(this, o);
                }
                if (changes['Paths'] && !changes['Paths'].isFirstChange()) {
                    this._polygonService.UpdatePolygon(this);
                }
            };
        /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.ngOnDestroy = /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                this._polygonService.DeletePolygon(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.AddEventListeners = /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var _getEventArg = function (e) {
                    return {
                        Polygon: _this,
                        Click: e
                    };
                };
                this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe(function (ev) {
                    if (_this._infoBox != null) {
                        _this._infoBox.Open(_this._polygonService.GetCoordinatesFromClick(ev));
                    }
                    _this.Click.emit(_getEventArg(ev));
                }));
                /** @type {?} */
                var handlers = [
                    { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(_getEventArg(ev)); } },
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                    { name: 'pathchanged', handler: function (ev) { return _this.PathChanged.emit(ev); } }
                ];
                handlers.forEach(function (obj) {
                    /** @type {?} */
                    var os = _this._polygonService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        /**
         * Generates IPolygon option changeset from directive settings.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolygonOptions} containing the polygon options.
         *
         */
        MapPolygonDirective.prototype.GeneratePolygonChangeSet = /**
         * Generates IPolygon option changeset from directive settings.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolygonOptions} containing the polygon options.
         *
         */
            function (changes) {
                /** @type {?} */
                var options = { id: this._id };
                /** @type {?} */
                var hasOptions = false;
                if (changes['Clickable']) {
                    options.clickable = this.Clickable;
                    hasOptions = true;
                }
                if (changes['Draggable']) {
                    options.draggable = this.Draggable;
                    hasOptions = true;
                }
                if (changes['Editable']) {
                    options.editable = this.Editable;
                    hasOptions = true;
                }
                if (changes['FillColor'] || changes['FillOpacity']) {
                    options.fillColor = this.FillColor;
                    options.fillOpacity = this.FillOpacity;
                    hasOptions = true;
                }
                if (changes['Geodesic']) {
                    options.geodesic = this.Geodesic;
                    hasOptions = true;
                }
                if (changes['LabelMaxZoom']) {
                    options.labelMaxZoom = this.LabelMaxZoom;
                    hasOptions = true;
                }
                if (changes['LabelMinZoom']) {
                    options.labelMinZoom = this.LabelMinZoom;
                    hasOptions = true;
                }
                if (changes['ShowTooltip']) {
                    options.showTooltip = this.ShowTooltip;
                    hasOptions = true;
                }
                if (changes['ShowLabel']) {
                    options.showLabel = this.ShowLabel;
                    hasOptions = true;
                }
                if (changes['StrokeColor'] || changes['StrokeOpacity']) {
                    options.strokeColor = this.StrokeColor;
                    options.strokeOpacity = this.StrokeOpacity;
                    hasOptions = true;
                }
                if (changes['StrokeWeight']) {
                    options.strokeWeight = this.StrokeWeight;
                    hasOptions = true;
                }
                if (changes['Title']) {
                    options.title = this.Title;
                    hasOptions = true;
                }
                if (changes['Visible']) {
                    options.visible = this.Visible;
                    hasOptions = true;
                }
                if (changes['zIndex']) {
                    options.zIndex = this.zIndex;
                    hasOptions = true;
                }
                return hasOptions ? options : null;
            };
        MapPolygonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polygon'
                    },] },
        ];
        /** @nocollapse */
        MapPolygonDirective.ctorParameters = function () {
            return [
                { type: PolygonService },
                { type: core.ViewContainerRef }
            ];
        };
        MapPolygonDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Clickable: [{ type: core.Input }],
            Draggable: [{ type: core.Input }],
            Editable: [{ type: core.Input }],
            FillColor: [{ type: core.Input }],
            FillOpacity: [{ type: core.Input }],
            Geodesic: [{ type: core.Input }],
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            Metadata: [{ type: core.Input }],
            Paths: [{ type: core.Input }],
            ShowLabel: [{ type: core.Input }],
            ShowTooltip: [{ type: core.Input }],
            StrokeColor: [{ type: core.Input }],
            StrokeOpacity: [{ type: core.Input }],
            StrokeWeight: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            zIndex: [{ type: core.Input }],
            Click: [{ type: core.Output }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            DragStart: [{ type: core.Output }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }],
            PathChanged: [{ type: core.Output }]
        };
        return MapPolygonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var polylineId = 0;
    /**
     *
     * MapPolylineDirective renders a polyline inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapPolylineDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map,
     *  styles: [`
     *   .map-container { height: 300px; }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polyline [Paths]="path"></x-map-polyline>
     *   </x-map>
     * `
     * })
     * ```
     *
     *
     * @export
     */
    var MapPolylineDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolylineDirective.
         * @param _polylineManager
         *
         * @memberof MapPolylineDirective
         */
        function MapPolylineDirective(_polylineService, _containerRef) {
            this._polylineService = _polylineService;
            this._containerRef = _containerRef;
            this._inCustomLayer = false;
            this._addedToService = false;
            this._events = [];
            /**
             * Gets or sets whether this Polyline handles mouse events.
             *
             * \@memberof MapPolylineDirective
             */
            this.Clickable = true;
            /**
             * If set to true, the user can drag this shape over the map.
             *
             * \@memberof MapPolylineDirective
             */
            this.Draggable = false;
            /**
             * If set to true, the user can edit this shape by dragging the control
             * points shown at the vertices and on each segment.
             *
             * \@memberof MapPolylineDirective
             */
            this.Editable = false;
            /**
             * When true, edges of the polyline are interpreted as geodesic and will
             * follow the curvature of the Earth. When false, edges of the polyline are
             * rendered as straight lines in screen space. Note that the shape of a
             * geodesic polyline may appear to change when dragged, as the dimensions
             * are maintained relative to the surface of the earth. Defaults to false.
             *
             * \@memberof MapPolylineDirective
             */
            this.Geodesic = false;
            /**
             * Arbitary metadata to assign to the Polyline. This is useful for events
             *
             * \@memberof MapPolylineDirective
             */
            this.Metadata = new Map();
            /**
             * The ordered sequence of coordinates that designates a polyline.
             * Simple polylines may be defined using a single array of LatLngs. More
             * complex polylines may specify an array of arrays.
             *
             * \@memberof MapPolylineDirective
             */
            this.Path = [];
            /**
             * Whether to show the title of the polyline as the tooltip on the polygon.
             *
             * \@memberof MapPolylineDirective
             */
            this.ShowTooltip = true;
            /**
             * This event is fired when the DOM click event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.Click = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * This event is fired when the user starts dragging the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousedown event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on Polyline mouseout.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on Polyline mouseover.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the Polyline
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This even is fired when the Polyline is right-clicked on.
             *
             * \@memberof MapPolylineDirective
             */
            this.RightClick = new core.EventEmitter();
            this._id = polylineId++;
        }
        Object.defineProperty(MapPolylineDirective.prototype, "AddedToService", {
            get: /**
             * Gets whether the polyline has been registered with the service.
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._addedToService; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "Id", {
            get: /**
             * Get the id of the polyline.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "IdAsString", {
            get: /**
             * Gets the id of the polyline as a string.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._id.toString(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the polyline is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the polyline belongs to.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        ///
        /// Public methods
        ///
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.ngAfterContentInit = /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                if (this._containerRef.element.nativeElement.parentElement) {
                    /** @type {?} */
                    var parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                        this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                    }
                }
                if (!this._addedToService) {
                    this._polylineService.AddPolyline(this);
                    this._addedToService = true;
                    this.AddEventListeners();
                }
                return;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * @param changes - Changes that have occured.
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapPolylineDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToService) {
                    return;
                }
                /** @type {?} */
                var o = this.GeneratePolylineChangeSet(changes);
                if (o != null) {
                    this._polylineService.SetOptions(this, o);
                }
                if (changes['Path'] && !changes['Path'].isFirstChange()) {
                    this._polylineService.UpdatePolyline(this);
                }
            };
        /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.ngOnDestroy = /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                this._polylineService.DeletePolyline(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.AddEventListeners = /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var _getEventArg = function (e) {
                    return {
                        Polyline: _this,
                        Click: e
                    };
                };
                this._polylineService.CreateEventObservable('click', this).subscribe(function (ev) {
                    if (_this._infoBox != null) {
                        _this._infoBox.Open(_this._polylineService.GetCoordinatesFromClick(ev));
                    }
                    _this.Click.emit(_getEventArg(ev));
                });
                /** @type {?} */
                var handlers = [
                    { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(_getEventArg(ev)); } },
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                ];
                handlers.forEach(function (obj) {
                    /** @type {?} */
                    var os = _this._polylineService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        /**
         * Generates IPolyline option changeset from directive settings.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolylineOptions} containing the polyline options.
         *
         */
        MapPolylineDirective.prototype.GeneratePolylineChangeSet = /**
         * Generates IPolyline option changeset from directive settings.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolylineOptions} containing the polyline options.
         *
         */
            function (changes) {
                /** @type {?} */
                var options = { id: this._id };
                /** @type {?} */
                var hasOptions = false;
                if (changes['Clickable']) {
                    options.clickable = this.Clickable;
                    hasOptions = true;
                }
                if (changes['Draggable']) {
                    options.draggable = this.Draggable;
                    hasOptions = true;
                }
                if (changes['Editable']) {
                    options.editable = this.Editable;
                    hasOptions = true;
                }
                if (changes['Geodesic']) {
                    options.geodesic = this.Geodesic;
                    hasOptions = true;
                }
                if (changes['ShowTooltip']) {
                    options.showTooltip = this.ShowTooltip;
                    hasOptions = true;
                }
                if (changes['StrokeColor']) {
                    options.strokeColor = this.StrokeColor;
                    hasOptions = true;
                }
                if (changes['StrokeOpacity']) {
                    options.strokeOpacity = this.StrokeOpacity;
                    hasOptions = true;
                }
                if (changes['StrokeWeight']) {
                    options.strokeWeight = this.StrokeWeight;
                    hasOptions = true;
                }
                if (changes['Title']) {
                    options.title = this.Title;
                    hasOptions = true;
                }
                if (changes['Visible']) {
                    options.visible = this.Visible;
                    hasOptions = true;
                }
                if (changes['zIndex']) {
                    options.zIndex = this.zIndex;
                    hasOptions = true;
                }
                return hasOptions ? options : null;
            };
        MapPolylineDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polyline'
                    },] },
        ];
        /** @nocollapse */
        MapPolylineDirective.ctorParameters = function () {
            return [
                { type: PolylineService },
                { type: core.ViewContainerRef }
            ];
        };
        MapPolylineDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Clickable: [{ type: core.Input }],
            Draggable: [{ type: core.Input }],
            Editable: [{ type: core.Input }],
            Geodesic: [{ type: core.Input }],
            Metadata: [{ type: core.Input }],
            Path: [{ type: core.Input }],
            ShowTooltip: [{ type: core.Input }],
            StrokeColor: [{ type: core.Input }],
            StrokeOpacity: [{ type: core.Input }],
            StrokeWeight: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            zIndex: [{ type: core.Input }],
            Click: [{ type: core.Output }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            DragStart: [{ type: core.Output }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }]
        };
        return MapPolylineDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * internal counter to use as ids for marker.
      @type {?} */
    var layerId$1 = 1000000;
    /**
     * MapMarkerLayerDirective performantly renders a large set of map marker inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker-layer [MarkerOptions]="_markers"></x-map-marker-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapMarkerLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapMarkerLayerDirective.
         * @param _markerService - Concreate implementation of a {@link MarkerService}.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _clusterService - Concreate implementation of a {@link ClusterService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         *
         * @memberof MapMarkerLayerDirective
         */
        function MapMarkerLayerDirective(_markerService, _layerService, _clusterService, _mapService, _zone) {
            this._markerService = _markerService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._useDynamicSizeMarker = false;
            this._dynamicMarkerBaseSize = 18;
            this._dynamicMarkerRanges = new Map([
                [10, 'rgba(20, 180, 20, 0.5)'],
                [100, 'rgba(255, 210, 40, 0.5)'],
                [Number.MAX_SAFE_INTEGER, 'rgba(255, 40, 40, 0.5)']
            ]);
            this._streaming = false;
            this._markers = new Array();
            this._markersLast = new Array();
            /**
             * Gets or sets the the Cluster Click Action {\@link ClusterClickAction}.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ClusterClickAction = ClusterClickAction.ZoomIntoCluster;
            /**
             * Gets or sets the cluster placement mode. {\@link ClusterPlacementMode}
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ClusterPlacementMode = ClusterPlacementMode.MeanValue;
            /**
             * Determines whether the layer clusters. This property can only be set on creation of the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.EnableClustering = false;
            /**
             * Gets or sets the grid size to be used for clustering.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.GridSize = 150;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ZIndex = 0;
            /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * \@readonly
             * \@memberof MapMarkerLayerDirective
             */
            this.ZoomOnClick = true;
            /**
             * This event emitter gets emitted when the dynamic icon for a marker is being created.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.DynamicMarkerCreated = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user clicks a marker in the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.MarkerClick = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging a marker.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.DragEnd = new core.EventEmitter();
            this._id = layerId$1++;
        }
        Object.defineProperty(MapMarkerLayerDirective.prototype, "CustomMarkerCallback", {
            /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {\@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._iconCreationCallback; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._useDynamicSizeMarker) {
                    throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
                }
                this._iconCreationCallback = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "DynamicMarkerBaseSize", {
            /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerBaseSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerBaseSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "DynamicMarkerRanges", {
            /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerRanges; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerRanges = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "MarkerOptions", {
            /**
             *  IMarkerOptions array holding the marker info.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             *  IMarkerOptions array holding the marker info.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._markers; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._markersLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._markers).push.apply(_b, __spread(val));
                }
                else {
                    this._markers = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "Styles", {
            /**
             * Gets or sets the cluster styles
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets the cluster styles
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._styles; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._styles = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "TreatNewMarkerOptionsAsStream", {
            /**
             * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the
             * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the
             * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "UseDynamicSizeMarkers", {
            /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._useDynamicSizeMarker; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._useDynamicSizeMarker = val;
                if (val) {
                    this._iconCreationCallback = function (m, info) {
                        return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker layer.
             *
             * \@readonly
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Translates a geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
        MapMarkerLayerDirective.prototype.LocationToPixel = /**
         * Translates a geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
            function (loc) {
                return this._markerService.LocationToPoint(loc);
            };
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    /** @type {?} */
                    var fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible
                    };
                    if (!_this.EnableClustering) {
                        _this._layerService.AddLayer(fakeLayerDirective);
                        _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                        _this._service = _this._layerService;
                    }
                    else {
                        fakeLayerDirective.LayerOffset = _this.LayerOffset;
                        fakeLayerDirective.ZIndex = _this.ZIndex;
                        fakeLayerDirective.ClusteringEnabled = _this.EnableClustering;
                        fakeLayerDirective.ClusterPlacementMode = _this.ClusterPlacementMode;
                        fakeLayerDirective.GridSize = _this.GridSize;
                        fakeLayerDirective.ClusterClickAction = _this.ClusterClickAction;
                        fakeLayerDirective.IconInfo = _this.ClusterIconInfo;
                        fakeLayerDirective.CustomMarkerCallback = _this.CustomMarkerCallback;
                        fakeLayerDirective.UseDynamicSizeMarkers = _this.UseDynamicSizeMarkers;
                        _this._clusterService.AddLayer(fakeLayerDirective);
                        _this._layerPromise = _this._clusterService.GetNativeLayer(fakeLayerDirective);
                        _this._service = _this._clusterService;
                    }
                    _this._layerPromise.then(function (l) {
                        l.SetVisible(_this.Visible);
                        if (_this.MarkerOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdateMarkers(); });
                        }
                    });
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
            function () {
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                var _this = this;
                /** @type {?} */
                var shouldSetOptions = false;
                /** @type {?} */
                var o = {
                    id: this._id
                };
                if (changes['MarkerOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdateMarkers();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._zone.runOutsideAngular(function () {
                        _this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                    });
                }
                if (changes['EnableClustering'] && !changes['EnableClustering'].firstChange) {
                    if ('StopClustering' in this._service) {
                        o.clusteringEnabled = this.EnableClustering;
                        shouldSetOptions = true;
                    }
                    else {
                        throw (new Error('You cannot change EnableClustering after the layer has been created.'));
                    }
                }
                if (changes['ClusterPlacementMode'] && !changes['ClusterPlacementMode'].firstChange && 'StopClustering' in this._service) {
                    o.placementMode = this.ClusterPlacementMode;
                    shouldSetOptions = true;
                }
                if (changes['GridSize'] && !changes['GridSize'].firstChange && 'StopClustering' in this._service) {
                    o.gridSize = this.GridSize;
                    shouldSetOptions = true;
                }
                if (changes['ClusterClickAction'] && !changes['ClusterClickAction'].firstChange && 'StopClustering' in this._service) {
                    o.zoomOnClick = this.ClusterClickAction === ClusterClickAction.ZoomIntoCluster;
                    shouldSetOptions = true;
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange) ||
                    (changes['IconInfo'] && !changes['IconInfo'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if (shouldSetOptions) {
                    this._zone.runOutsideAngular(function () {
                        /** @type {?} */
                        var fakeLayerDirective = { Id: _this._id };
                        _this._layerPromise.then(function (l) { return l.SetOptions(o); });
                    });
                }
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerLayerDirective
         * @return {?} - string representation of the marker id.
         */
        MapMarkerLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerLayerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapMarkerLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} m - the marker for which to add the event.
         *
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} m - the marker for which to add the event.
         *
         * @return {?}
         */
            function (m) {
                var _this = this;
                m.AddListener('click', function (e) {
                    return _this.MarkerClick.emit({
                        Marker: m,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    });
                });
                m.AddListener('dragend', function (e) {
                    return _this.DragEnd.emit({
                        Marker: m,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    });
                });
            };
        /**
         * Sets or updates the markers based on the marker options. This will place the markers on the map
         * and register the associated events.
         *
         * \@memberof MapMarkerLayerDirective
         * \@method
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.UpdateMarkers = /**
         * Sets or updates the markers based on the marker options. This will place the markers on the map
         * and register the associated events.
         *
         * \@memberof MapMarkerLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    /** @type {?} */
                    var markers = _this._streaming ? _this._markersLast.splice(0) : _this._markers;
                    /** @type {?} */
                    var mp = _this._service.CreateMarkers(markers, _this.IconInfo);
                    // set markers once promises are fullfilled.
                    mp.then(function (m) {
                        m.forEach(function (marker) {
                            _this.AddEventListeners(marker);
                        });
                        _this._streaming ? l.AddEntities(m) : l.SetEntities(m);
                    });
                });
            };
        MapMarkerLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-marker-layer'
                    },] },
        ];
        /** @nocollapse */
        MapMarkerLayerDirective.ctorParameters = function () {
            return [
                { type: MarkerService },
                { type: LayerService },
                { type: ClusterService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapMarkerLayerDirective.propDecorators = {
            ClusterClickAction: [{ type: core.Input }],
            ClusterIconInfo: [{ type: core.Input }],
            ClusterPlacementMode: [{ type: core.Input }],
            CustomMarkerCallback: [{ type: core.Input }],
            DynamicMarkerBaseSize: [{ type: core.Input }],
            DynamicMarkerRanges: [{ type: core.Input }],
            EnableClustering: [{ type: core.Input }],
            GridSize: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            MarkerOptions: [{ type: core.Input }],
            Styles: [{ type: core.Input }],
            TreatNewMarkerOptionsAsStream: [{ type: core.Input }],
            UseDynamicSizeMarkers: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            ZoomOnClick: [{ type: core.Input }],
            DynamicMarkerCreated: [{ type: core.Output }],
            MarkerClick: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }]
        };
        return MapMarkerLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * internal counter to use as ids for polygons.
      @type {?} */
    var layerId$2 = 1000000;
    /**
     * MapPolygonLayerDirective performantly renders a large set of polygons on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polygon-layer [PolygonOptions]="_polygons"></x-map-polygon-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapPolygonLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolygonLayerDirective.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         * @memberof MapPolygonLayerDirective
         */
        function MapPolygonLayerDirective(_layerService, _mapService, _zone) {
            this._layerService = _layerService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._labels = new Array();
            this._tooltipSubscriptions = new Array();
            this._tooltipVisible = false;
            this._defaultOptions = {
                fontSize: 11,
                fontFamily: 'sans-serif',
                strokeWeight: 2,
                strokeColor: '#000000',
                fontColor: '#ffffff'
            };
            this._streaming = false;
            this._polygons = new Array();
            this._polygonsLast = new Array();
            /**
             * Set the maximum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolygonLayerDirective
             */
            this.LabelMaxZoom = Number.MAX_SAFE_INTEGER;
            /**
             * Set the minimum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolygonLayerDirective
             */
            this.LabelMinZoom = -1;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Whether to show the polygon titles as the labels on the polygons.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ShowLabels = false;
            /**
             * Whether to show the titles of the polygosn as the tooltips on the polygons.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ShowTooltips = true;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ZIndex = 0;
            /**
             * This event emitter gets emitted when the user clicks a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonDblClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseMove = new core.EventEmitter();
            /**
             * This event is fired on mouseout on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseOut = new core.EventEmitter();
            /**
             * This event is fired on mouseover on a polygon in a layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseOver = new core.EventEmitter();
            this._id = layerId$2++;
        }
        Object.defineProperty(MapPolygonLayerDirective.prototype, "PolygonOptions", {
            /**
             * An array of polygon options representing the polygons in the layer.
             *
             * @memberof MapPolygonLayerDirective
             */
            get: /**
             * An array of polygon options representing the polygons in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._polygons; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._polygonsLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._polygons).push.apply(_b, __spread(val));
                }
                else {
                    this._polygons = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonLayerDirective.prototype, "TreatNewPolygonOptionsAsStream", {
            /**
             * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.
             *
             * @memberof MapPolygonLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.
             *
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker layer.
             *
             * \@readonly
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    /** @type {?} */
                    var fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible,
                        LayerOffset: _this.LayerOffset,
                        ZIndex: _this.ZIndex
                    };
                    _this._layerService.AddLayer(fakeLayerDirective);
                    _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                    Promise.all([
                        _this._layerPromise,
                        _this._mapService.CreateCanvasOverlay(function (el) { return _this.DrawLabels(el); })
                    ]).then(function (values) {
                        values[0].SetVisible(_this.Visible);
                        _this._canvas = values[1];
                        _this._canvas._canvasReady.then(function (b) {
                            _this._tooltip = _this._canvas.GetToolTipOverlay();
                            _this.ManageTooltip(_this.ShowTooltips);
                        });
                        if (_this.PolygonOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdatePolygons(); });
                        }
                    });
                    _this._service = _this._layerService;
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
            function () {
                this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
                if (this._canvas) {
                    this._canvas.Delete();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (changes['PolygonOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdatePolygons();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||
                    (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||
                    (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)) {
                    if (this._canvas) {
                        this._canvas.Redraw(true);
                    }
                }
                if (changes['ShowTooltips'] && this._tooltip) {
                    this.ManageTooltip(changes['ShowTooltips'].currentValue);
                }
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapPolygonLayerDirective
         * @return {?} - string representation of the marker id.
         */
        MapPolygonLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapPolygonLayerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapPolygonLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} p - the polygon for which to add the event.
         *
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} p - the polygon for which to add the event.
         *
         * @return {?}
         */
            function (p) {
                var _this = this;
                /** @type {?} */
                var handlers = [
                    { name: 'click', handler: function (ev) { return _this.PolygonClick.emit({ Polygon: p, Click: ev }); } },
                    { name: 'dblclick', handler: function (ev) { return _this.PolygonDblClick.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mousemove', handler: function (ev) { return _this.PolygonMouseMove.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mouseout', handler: function (ev) { return _this.PolygonMouseOut.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mouseover', handler: function (ev) { return _this.PolygonMouseOver.emit({ Polygon: p, Click: ev }); } }
                ];
                handlers.forEach(function (obj) { return p.AddListener(obj.name, obj.handler); });
            };
        /**
         * Draws the polygon labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.DrawLabels = /**
         * Draws the polygon labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
            function (el) {
                var _this = this;
                if (this.ShowLabels) {
                    this._mapService.GetZoom().then(function (z) {
                        if (_this.LabelMinZoom <= z && _this.LabelMaxZoom >= z) {
                            /** @type {?} */
                            var ctx_1 = el.getContext('2d');
                            /** @type {?} */
                            var labels_1 = _this._labels.map(function (x) { return x.title; });
                            _this._mapService.LocationsToPoints(_this._labels.map(function (x) { return x.loc; })).then(function (locs) {
                                /** @type {?} */
                                var size = _this._mapService.MapSize;
                                for (var i = 0, len = locs.length; i < len; i++) {
                                    // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.
                                    if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {
                                        _this.DrawText(ctx_1, locs[i], labels_1[i]);
                                    }
                                }
                            });
                        }
                    });
                }
            };
        /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.DrawText = /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
            function (ctx, loc, text) {
                /** @type {?} */
                var lo = this.LabelOptions;
                if (lo == null && this._tooltip) {
                    lo = this._tooltip.DefaultLabelStyle;
                }
                if (lo == null) {
                    lo = this._defaultOptions;
                }
                ctx.strokeStyle = lo.strokeColor;
                ctx.font = lo.fontSize + "px " + lo.fontFamily;
                ctx.textAlign = 'center';
                /** @type {?} */
                var strokeWeight = lo.strokeWeight;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, loc.x, loc.y);
                }
                ctx.fillStyle = lo.fontColor;
                ctx.fillText(text, loc.x, loc.y);
            };
        /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ManageTooltip = /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
            function (show) {
                var _this = this;
                if (show && this._canvas) {
                    // add tooltip subscriptions
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                    this._tooltipSubscriptions.push(this.PolygonMouseMove.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            /** @type {?} */
                            var loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('position', loc);
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolygonMouseOver.asObservable().subscribe(function (e) {
                        if (e.Polygon.Title && e.Polygon.Title.length > 0) {
                            /** @type {?} */
                            var loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('text', e.Polygon.Title);
                            _this._tooltip.Set('position', loc);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolygonMouseOut.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            _this._tooltip.Set('hidden', true);
                            _this._tooltipVisible = false;
                        }
                    }));
                }
                else {
                    // remove tooltip subscriptions
                    this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                    this._tooltipSubscriptions.splice(0);
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                }
            };
        /**
         * Sets or updates the polygons based on the polygon options. This will place the polygons on the map
         * and register the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * \@method
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.UpdatePolygons = /**
         * Sets or updates the polygons based on the polygon options. This will place the polygons on the map
         * and register the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    /** @type {?} */
                    var polygons = _this._streaming ? _this._polygonsLast.splice(0) : _this._polygons;
                    if (!_this._streaming) {
                        _this._labels.splice(0);
                    }
                    /** @type {?} */
                    var lp = _this._service.CreatePolygons(l.GetOptions().id, polygons);
                    // set markers once promises are fullfilled.
                    lp.then(function (p) {
                        p.forEach(function (poly) {
                            if (poly.Title != null && poly.Title.length > 0) {
                                _this._labels.push({ loc: poly.Centroid, title: poly.Title });
                            }
                            _this.AddEventListeners(poly);
                        });
                        _this._streaming ? l.AddEntities(p) : l.SetEntities(p);
                        if (_this._canvas) {
                            _this._canvas.Redraw(!_this._streaming);
                        }
                    });
                });
            };
        MapPolygonLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polygon-layer'
                    },] },
        ];
        /** @nocollapse */
        MapPolygonLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapPolygonLayerDirective.propDecorators = {
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            LabelOptions: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            PolygonOptions: [{ type: core.Input }],
            ShowLabels: [{ type: core.Input }],
            ShowTooltips: [{ type: core.Input }],
            TreatNewPolygonOptionsAsStream: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            PolygonClick: [{ type: core.Output }],
            PolygonDblClick: [{ type: core.Output }],
            PolygonMouseMove: [{ type: core.Output }],
            PolygonMouseOut: [{ type: core.Output }],
            PolygonMouseOver: [{ type: core.Output }]
        };
        return MapPolygonLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** *
     * internal counter to use as ids for polylines.
      @type {?} */
    var layerId$3 = 1000000;
    /**
     * MapPolylineLayerDirective performantly renders a large set of polyline on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polyline-layer [PolygonOptions]="_polyline"></x-map-polyline-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapPolylineLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolylineLayerDirective.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         * @memberof MapPolylineLayerDirective
         */
        function MapPolylineLayerDirective(_layerService, _mapService, _zone) {
            this._layerService = _layerService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._labels = new Array();
            this._tooltipSubscriptions = new Array();
            this._tooltipVisible = false;
            this._defaultOptions = {
                fontSize: 11,
                fontFamily: 'sans-serif',
                strokeWeight: 2,
                strokeColor: '#000000',
                fontColor: '#ffffff'
            };
            this._streaming = false;
            this._polylines = new Array();
            this._polylinesLast = new Array();
            /**
             * Set the maximum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolylineLayerDirective
             */
            this.LabelMaxZoom = Number.MAX_SAFE_INTEGER;
            /**
             * Set the minimum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolylineLayerDirective
             */
            this.LabelMinZoom = -1;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Whether to show the polylines titles as the labels on the polylines.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ShowLabels = false;
            /**
             * Whether to show the titles of the polylines as the tooltips on the polylines.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ShowTooltips = true;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ZIndex = 0;
            /**
             * This event emitter gets emitted when the user clicks a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineDblClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseMove = new core.EventEmitter();
            /**
             * This event is fired on mouseout on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseOut = new core.EventEmitter();
            /**
             * This event is fired on mouseover on a polyline in a layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseOver = new core.EventEmitter();
            this._id = layerId$3++;
        }
        Object.defineProperty(MapPolylineLayerDirective.prototype, "PolylineOptions", {
            /**
             * An array of polyline options representing the polylines in the layer.
             *
             * @memberof MapPolylineLayerDirective
             */
            get: /**
             * An array of polyline options representing the polylines in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._polylines; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._polylinesLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._polylines).push.apply(_b, __spread(val));
                }
                else {
                    this._polylines = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineLayerDirective.prototype, "TreatNewPolylineOptionsAsStream", {
            /**
             * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.
             *
             * @memberof MapPolylineLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.
             *
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the polyline layer.
             *
             * \@readonly
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    /** @type {?} */
                    var fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible,
                        LayerOffset: _this.LayerOffset,
                        ZIndex: _this.ZIndex
                    };
                    _this._layerService.AddLayer(fakeLayerDirective);
                    _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                    Promise.all([
                        _this._layerPromise,
                        _this._mapService.CreateCanvasOverlay(function (el) { return _this.DrawLabels(el); })
                    ]).then(function (values) {
                        values[0].SetVisible(_this.Visible);
                        _this._canvas = values[1];
                        _this._canvas._canvasReady.then(function (b) {
                            _this._tooltip = _this._canvas.GetToolTipOverlay();
                            _this.ManageTooltip(_this.ShowTooltips);
                        });
                        if (_this.PolylineOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdatePolylines(); });
                        }
                    });
                    _this._service = _this._layerService;
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
            function () {
                this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
                if (this._canvas) {
                    this._canvas.Delete();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (changes['PolylineOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdatePolylines();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||
                    (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||
                    (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)) {
                    if (this._canvas) {
                        this._canvas.Redraw(true);
                    }
                }
                if (changes['ShowTooltips'] && this._tooltip) {
                    this.ManageTooltip(changes['ShowTooltips'].currentValue);
                }
            };
        /**
         * Obtains a string representation of the Layer Id.
         * \@memberof MapPolylineLayerDirective
         * @return {?} - string representation of the layer id.
         */
        MapPolylineLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Layer Id.
         * \@memberof MapPolylineLayerDirective
         * @return {?} - string representation of the layer id.
         */
            function () { return 'MapPolylineLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the polylines.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} p - the polyline for which to add the event.
         *
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the polylines.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} p - the polyline for which to add the event.
         *
         * @return {?}
         */
            function (p) {
                var _this = this;
                /** @type {?} */
                var handlers = [
                    { name: 'click', handler: function (ev) { return _this.PolylineClick.emit({ Polyline: p, Click: ev }); } },
                    { name: 'dblclick', handler: function (ev) { return _this.PolylineDblClick.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mousemove', handler: function (ev) { return _this.PolylineMouseMove.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mouseout', handler: function (ev) { return _this.PolylineMouseOut.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mouseover', handler: function (ev) { return _this.PolylineMouseOver.emit({ Polyline: p, Click: ev }); } }
                ];
                handlers.forEach(function (obj) { return p.AddListener(obj.name, obj.handler); });
            };
        /**
         * Draws the polyline labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.DrawLabels = /**
         * Draws the polyline labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
            function (el) {
                var _this = this;
                if (this.ShowLabels) {
                    this._mapService.GetZoom().then(function (z) {
                        if (_this.LabelMinZoom <= z && _this.LabelMaxZoom >= z) {
                            /** @type {?} */
                            var ctx_1 = el.getContext('2d');
                            /** @type {?} */
                            var labels_1 = _this._labels.map(function (x) { return x.title; });
                            _this._mapService.LocationsToPoints(_this._labels.map(function (x) { return x.loc; })).then(function (locs) {
                                /** @type {?} */
                                var size = _this._mapService.MapSize;
                                for (var i = 0, len = locs.length; i < len; i++) {
                                    // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.
                                    if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {
                                        _this.DrawText(ctx_1, locs[i], labels_1[i]);
                                    }
                                }
                            });
                        }
                    });
                }
            };
        /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.DrawText = /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
            function (ctx, loc, text) {
                /** @type {?} */
                var lo = this.LabelOptions;
                if (lo == null && this._tooltip) {
                    lo = this._tooltip.DefaultLabelStyle;
                }
                if (lo == null) {
                    lo = this._defaultOptions;
                }
                ctx.strokeStyle = lo.strokeColor;
                ctx.font = lo.fontSize + "px " + lo.fontFamily;
                ctx.textAlign = 'center';
                /** @type {?} */
                var strokeWeight = lo.strokeWeight;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, loc.x, loc.y);
                }
                ctx.fillStyle = lo.fontColor;
                ctx.fillText(text, loc.x, loc.y);
            };
        /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ManageTooltip = /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
            function (show) {
                var _this = this;
                if (show && this._canvas) {
                    // add tooltip subscriptions
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                    this._tooltipSubscriptions.push(this.PolylineMouseMove.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            /** @type {?} */
                            var loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('position', loc);
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolylineMouseOver.asObservable().subscribe(function (e) {
                        if (e.Polyline.Title && e.Polyline.Title.length > 0) {
                            /** @type {?} */
                            var loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('text', e.Polyline.Title);
                            _this._tooltip.Set('position', loc);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolylineMouseOut.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            _this._tooltip.Set('hidden', true);
                            _this._tooltipVisible = false;
                        }
                    }));
                }
                else {
                    // remove tooltip subscriptions
                    this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                    this._tooltipSubscriptions.splice(0);
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                }
            };
        /**
         * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map
         * and register the associated events.
         *
         * \@memberof MapPolylineLayerDirective
         * \@method
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.UpdatePolylines = /**
         * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map
         * and register the associated events.
         *
         * \@memberof MapPolylineLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    /** @type {?} */
                    var polylines = _this._streaming ? _this._polylinesLast.splice(0) : _this._polylines;
                    if (!_this._streaming) {
                        _this._labels.splice(0);
                    }
                    /** @type {?} */
                    var lp = _this._service.CreatePolylines(l.GetOptions().id, polylines);
                    // set polylines once promises are fullfilled.
                    lp.then(function (p) {
                        /** @type {?} */
                        var y = new Array();
                        p.forEach(function (poly) {
                            if (Array.isArray(poly)) {
                                /** @type {?} */
                                var title_1 = '';
                                /** @type {?} */
                                var centroids_1 = new Array();
                                poly.forEach(function (x) {
                                    y.push(x);
                                    _this.AddEventListeners(x);
                                    centroids_1.push(x.Centroid);
                                    if (x.Title != null && x.Title.length > 0 && title_1.length === 0) {
                                        title_1 = x.Title;
                                    }
                                });
                                _this._labels.push({ loc: Polyline.GetPolylineCentroid(centroids_1), title: title_1 });
                            }
                            else {
                                y.push(poly);
                                if (poly.Title != null && poly.Title.length > 0) {
                                    _this._labels.push({ loc: poly.Centroid, title: poly.Title });
                                }
                                _this.AddEventListeners(poly);
                            }
                        });
                        _this._streaming ? l.AddEntities(y) : l.SetEntities(y);
                        if (_this._canvas) {
                            _this._canvas.Redraw(!_this._streaming);
                        }
                    });
                });
            };
        MapPolylineLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polyline-layer'
                    },] },
        ];
        /** @nocollapse */
        MapPolylineLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapPolylineLayerDirective.propDecorators = {
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            LabelOptions: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            PolylineOptions: [{ type: core.Input }],
            ShowLabels: [{ type: core.Input }],
            ShowTooltips: [{ type: core.Input }],
            TreatNewPolylineOptionsAsStream: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            PolylineClick: [{ type: core.Output }],
            PolylineDblClick: [{ type: core.Output }],
            PolylineMouseMove: [{ type: core.Output }],
            PolylineMouseOut: [{ type: core.Output }],
            PolylineMouseOver: [{ type: core.Output }]
        };
        return MapPolylineLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Abstract implementation. USed for defintion only and as a base to implement your
     * own provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapAPILoader = (function () {
        function MapAPILoader() {
        }
        MapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        return MapAPILoader;
    }());
    /**
     * Document Reference service to assist with abstracting the availability of document. Needed for AOT and
     * Server Side rendering
     *
     * @export
     */
    var DocumentRef = (function () {
        function DocumentRef() {
        }
        Object.defineProperty(DocumentRef.prototype, "IsAvailable", {
            get: /**
             * Gets whether a document implementation is available. Generally will be true in the browser and false otherwise, unless there
             * there is a browser-less implementation in the current non-browser environment.
             *
             * \@readonly
             * \@memberof DocumentRef
             * @return {?}
             */ function () {
                return !(typeof (document) === 'undefined');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the document object of the current environment.
         *
         * \@memberof DocumentRef
         * @return {?} - The document object.
         *
         */
        DocumentRef.prototype.GetNativeDocument = /**
         * Returns the document object of the current environment.
         *
         * \@memberof DocumentRef
         * @return {?} - The document object.
         *
         */
            function () {
                if (typeof (document) === 'undefined') {
                    return null;
                }
                return document;
            };
        DocumentRef.decorators = [
            { type: core.Injectable },
        ];
        return DocumentRef;
    }());
    /**
     * Window Reference service to assist with abstracting the availability of window. Needed for AOT and
     * Server Side rendering
     *
     * @export
     */
    var WindowRef = (function () {
        function WindowRef() {
        }
        Object.defineProperty(WindowRef.prototype, "IsAvailable", {
            get: /**
             * Gets whether a window implementation is available. Generally will be true in the browser and false otherwise, unless there
             * there is a browser-less implementation in the current non-browser environment.
             *
             * \@readonly
             * \@memberof WindowRef
             * @return {?}
             */ function () {
                return !(typeof (window) === 'undefined');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the window object of the current environment.
         *
         * \@memberof WindowRef
         * @return {?} - The window object.
         *
         */
        WindowRef.prototype.GetNativeWindow = /**
         * Returns the window object of the current environment.
         *
         * \@memberof WindowRef
         * @return {?} - The window object.
         *
         */
            function () {
                if (typeof (window) === 'undefined') {
                    return null;
                }
                return window;
            };
        WindowRef.decorators = [
            { type: core.Injectable },
        ];
        return WindowRef;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var ScriptProtocol = {
        HTTP: 0,
        HTTPS: 1,
        AUTO: 2,
    };
    ScriptProtocol[ScriptProtocol.HTTP] = 'HTTP';
    ScriptProtocol[ScriptProtocol.HTTPS] = 'HTTPS';
    ScriptProtocol[ScriptProtocol.AUTO] = 'AUTO';
    /**
     * Bing Maps V8 specific loader configuration to be used with the {\@link BingMapAPILoader}
     *
     * @export
     */
    var BingMapAPILoaderConfig = (function () {
        function BingMapAPILoaderConfig() {
            this.apiKey = '';
            this.hostAndPath = 'www.bing.com/api/maps/mapcontrol';
            this.protocol = ScriptProtocol.HTTPS;
            this.branch = '';
        }
        BingMapAPILoaderConfig.decorators = [
            { type: core.Injectable },
        ];
        return BingMapAPILoaderConfig;
    }());
    /** *
     * Default loader configuration.
      @type {?} */
    var DEFAULT_CONFIGURATION = new BingMapAPILoaderConfig();
    /**
     * Bing Maps V8 implementation for the {\@link MapAPILoader} service.
     *
     * @export
     */
    var BingMapAPILoader = (function (_super) {
        __extends(BingMapAPILoader, _super);
        /**
         * Creates an instance of BingMapAPILoader.
         * @param _config  - The loader configuration.
         * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
         * @param _documentRef - An instance of {@link DocumentRef}.
         * Necessary because Bing Map V8 interacts with the document object.
         *
         * @memberof BingMapAPILoader
         */
        function BingMapAPILoader(_config, _windowRef, _documentRef) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            _this._windowRef = _windowRef;
            _this._documentRef = _documentRef;
            if (_this._config === null || _this._config === undefined) {
                _this._config = DEFAULT_CONFIGURATION;
            }
            return _this;
        }
        Object.defineProperty(BingMapAPILoader.prototype, "Config", {
            get: /**
             * Gets the loader configuration.
             *
             * \@readonly
             * \@memberof BingMapAPILoader
             * @return {?}
             */ function () { return this._config; },
            enumerable: true,
            configurable: true
        });
        /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof BingMapAPILoader
         * @return {?}
         */
        BingMapAPILoader.prototype.Load = /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof BingMapAPILoader
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._scriptLoadingPromise) {
                    return this._scriptLoadingPromise;
                }
                /** @type {?} */
                var script = this._documentRef.GetNativeDocument().createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.defer = true;
                /** @type {?} */
                var callbackName = "angular2bingmaps" + new Date().getMilliseconds();
                script.src = this.GetScriptSrc(callbackName);
                this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                    ((_this._windowRef.GetNativeWindow()))[callbackName] = function () {
                        resolve();
                    };
                    script.onerror = function (error) { reject(error); };
                });
                this._documentRef.GetNativeDocument().head.appendChild(script);
                return this._scriptLoadingPromise;
            };
        /**
         * Gets the Bing Map V8 scripts url for injections into the header.
         *
         * \@memberof BingMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.
         * @return {?} - The url to be used to load the Bing Map scripts.
         *
         */
        BingMapAPILoader.prototype.GetScriptSrc = /**
         * Gets the Bing Map V8 scripts url for injections into the header.
         *
         * \@memberof BingMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.
         * @return {?} - The url to be used to load the Bing Map scripts.
         *
         */
            function (callbackName) {
                /** @type {?} */
                var protocolType = (this._config && this._config.protocol) || DEFAULT_CONFIGURATION.protocol;
                /** @type {?} */
                var protocol;
                switch (protocolType) {
                    case ScriptProtocol.AUTO:
                        protocol = '';
                        break;
                    case ScriptProtocol.HTTP:
                        protocol = 'http:';
                        break;
                    case ScriptProtocol.HTTPS:
                        protocol = 'https:';
                        break;
                }
                /** @type {?} */
                var hostAndPath = this._config.hostAndPath || DEFAULT_CONFIGURATION.hostAndPath;
                /** @type {?} */
                var queryParams = {
                    callback: callbackName
                };
                if (this._config.branch !== '') {
                    queryParams['branch'] = this._config.branch;
                }
                /** @type {?} */
                var params = Object.keys(queryParams)
                    .map(function (k, i) {
                    /** @type {?} */
                    var param = (i === 0) ? '?' : '&';
                    return param += k + "=" + queryParams[k];
                })
                    .join('');
                return protocol + "//" + hostAndPath + params;
            };
        BingMapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapAPILoader.ctorParameters = function () {
            return [
                { type: BingMapAPILoaderConfig, decorators: [{ type: core.Optional }] },
                { type: WindowRef },
                { type: DocumentRef }
            ];
        };
        return BingMapAPILoader;
    }(MapAPILoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link InfoBoxService} contract for the Bing Maps V8 architecture.
     *
     * @export
     */
    var BingInfoBoxService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingInfoBoxService.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         * @param _zone - An instance of NgZone to provide zone aware promises.
         *
         * @memberof BingInfoBoxService
         */
        function BingInfoBoxService(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._boxes = new Map();
        }
        /**
         * Adds an info window to the map or layer.
         *
         * \@memberof BingInfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         *
         * @return {?}
         */
        BingInfoBoxService.prototype.AddInfoWindow = /**
         * Adds an info window to the map or layer.
         *
         * \@memberof BingInfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         *
         * @return {?}
         */
            function (info) {
                /** @type {?} */
                var options = {};
                if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {
                    options.position = {
                        latitude: info.Latitude,
                        longitude: info.Longitude
                    };
                }
                if (typeof info.InfoWindowActions !== 'undefined' && info.InfoWindowActions.length > 0) {
                    options.actions = [];
                    info.InfoWindowActions.forEach(function (action) {
                        options.actions.push({
                            label: action.Label,
                            eventHandler: function () { action.ActionClicked.emit(null); }
                        });
                    });
                }
                if (info.HtmlContent !== '') {
                    options.htmlContent = info.HtmlContent;
                }
                else {
                    options.title = info.Title;
                    options.description = info.Description;
                }
                if (info.xOffset || info.yOffset) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    if (info.xOffset) {
                        options.pixelOffset.x = info.xOffset;
                    }
                    if (info.yOffset) {
                        options.pixelOffset.y = info.yOffset;
                    }
                }
                options.visible = info.Visible;
                /** @type {?} */
                var infoPromise = this._mapService.CreateInfoWindow(options);
                this._boxes.set(info, infoPromise);
            };
        /**
         * Closes an InfoBoxComponent that is open.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been closed.
         *
         */
        BingInfoBoxService.prototype.Close = /**
         * Closes an InfoBoxComponent that is open.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been closed.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (w) { return w.Close(); });
            };
        /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingInfoBoxService.prototype.CreateEventObservable = /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, infoComponent) {
                var _this = this;
                /** @type {?} */
                var eventNameTranslated = BingMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._boxes.get(infoComponent).then(function (b) {
                        b.AddListener(eventNameTranslated, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes an infobox.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been deleted.
         *
         */
        BingInfoBoxService.prototype.DeleteInfoWindow = /**
         * Deletes an infobox.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been deleted.
         *
         */
            function (info) {
                var _this = this;
                /** @type {?} */
                var w = this._boxes.get(info);
                if (w == null) {
                    return Promise.resolve();
                }
                return w.then(function (i) {
                    return _this._zone.run(function () {
                        i.Close();
                        _this._boxes.delete(info);
                    });
                });
            };
        /**
         * Opens an infobox that is closed.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?=} loc
         * @return {?} - A promise that is fullfilled when the infobox has been opened.
         *
         */
        BingInfoBoxService.prototype.Open = /**
         * Opens an infobox that is closed.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?=} loc
         * @return {?} - A promise that is fullfilled when the infobox has been opened.
         *
         */
            function (info, loc) {
                if (info.CloseInfoBoxesOnOpen || info.Modal) {
                    // close all open info boxes.
                    this._boxes.forEach(function (v, i) {
                        if (info.Id !== i.Id) {
                            v.then(function (w) {
                                if (w.IsOpen) {
                                    w.Close();
                                    i.Close();
                                }
                            });
                        }
                    });
                }
                return this._boxes.get(info).then(function (w) {
                    /** @type {?} */
                    var options = {};
                    if (info.HtmlContent !== '') {
                        options.htmlContent = info.HtmlContent;
                    }
                    else {
                        options.title = info.Title;
                        options.description = info.Description;
                    }
                    w.SetOptions(options);
                    if (info.Latitude && info.Longitude) {
                        w.SetPosition({ latitude: info.Latitude, longitude: info.Longitude });
                    }
                    else if (loc) {
                        w.SetPosition(loc);
                    }
                    else if (info.HostMarker) {
                        w.SetPosition({ latitude: info.HostMarker.Latitude, longitude: info.HostMarker.Longitude });
                    }
                    w.Open();
                });
            };
        /**
         * Sets the infobox options.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?} options - {\@link IInfoWindowOptions} object containing the options to set. Options provided are
         * merged with the existing options of the underlying infobox.
         * @return {?} - A promise that is fullfilled when the infobox options have been updated.
         *
         */
        BingInfoBoxService.prototype.SetOptions = /**
         * Sets the infobox options.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?} options - {\@link IInfoWindowOptions} object containing the options to set. Options provided are
         * merged with the existing options of the underlying infobox.
         * @return {?} - A promise that is fullfilled when the infobox options have been updated.
         *
         */
            function (info, options) {
                return this._boxes.get(info).then(function (i) { return i.SetOptions(options); });
            };
        /**
         * Set the position of the infobox based on the properties set on the InfoBox component.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox position has been updated.
         *
         */
        BingInfoBoxService.prototype.SetPosition = /**
         * Set the position of the infobox based on the properties set on the InfoBox component.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox position has been updated.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (i) {
                    return i.SetPosition({
                        latitude: info.Latitude,
                        longitude: info.Longitude
                    });
                });
            };
        BingInfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingInfoBoxService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingInfoBoxService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the MarkerService abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingMarkerService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMarkerService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _clusterService - {@link ClusterService} instance.
         * The concrete {@link BingClusterService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingMarkerService
         */
        function BingMarkerService(_mapService, _layerService, _clusterService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._zone = _zone;
            this._markers = new Map();
        }
        /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         *
         * @return {?}
         */
        BingMarkerService.prototype.AddMarker = /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         *
         * @return {?}
         */
            function (marker) {
                /** @type {?} */
                var o = {
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    title: marker.Title,
                    label: marker.Label,
                    draggable: marker.Draggable,
                    icon: marker.IconUrl,
                    iconInfo: marker.IconInfo,
                    isFirst: marker.IsFirstInSet,
                    isLast: marker.IsLastInSet
                };
                if (marker.Width) {
                    o.width = marker.Width;
                }
                if (marker.Height) {
                    o.height = marker.Height;
                }
                if (marker.Anchor) {
                    o.anchor = marker.Anchor;
                }
                if (marker.Metadata) {
                    o.metadata = marker.Metadata;
                }
                /** @type {?} */
                var markerPromise = null;
                if (marker.InClusterLayer) {
                    markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
                }
                else if (marker.InCustomLayer) {
                    markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
                }
                else {
                    markerPromise = this._mapService.CreateMarker(o);
                }
                this._markers.set(marker, markerPromise);
                if (marker.IconInfo) {
                    markerPromise.then(function (m) {
                        // update iconInfo to provide hook to do post icon creation activities and
                        // also re-anchor the marker
                        marker.DynamicMarkerCreated.emit(o.iconInfo);
                        /** @type {?} */
                        var p = {
                            x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                            y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                        };
                        m.SetAnchor(p);
                    });
                }
            };
        /**
         * Registers an event delegate for a marker.
         *
         * \@memberof BingMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarker} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingMarkerService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a marker.
         *
         * \@memberof BingMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarker} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, marker) {
                var _this = this;
                /** @type {?} */
                var b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._markers.get(marker).then(function (m) {
                        m.AddListener(eventName, function (e) {
                            return _this._zone.run(function () {
                                return observer.next(e);
                            });
                        });
                    });
                });
            };
        /**
         * Deletes a marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - {\@link MapMarker} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         *
         */
        BingMarkerService.prototype.DeleteMarker = /**
         * Deletes a marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - {\@link MapMarker} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         *
         */
            function (marker) {
                var _this = this;
                /** @type {?} */
                var m = this._markers.get(marker);
                /** @type {?} */
                var p = Promise.resolve();
                if (m != null) {
                    p = m.then(function (ma) {
                        if (marker.InClusterLayer) {
                            _this._clusterService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                        }
                        if (marker.InCustomLayer) {
                            _this._layerService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                        }
                        return _this._zone.run(function () {
                            ma.DeleteMarker();
                            _this._markers.delete(marker);
                        });
                    });
                }
                return p;
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingMarkerService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.primitive) {
                    return null;
                }
                if (!(e.primitive instanceof Microsoft.Maps.Pushpin)) {
                    return null;
                }
                /** @type {?} */
                var p = e.primitive;
                /** @type {?} */
                var loc = p.getLocation();
                return { latitude: loc.latitude, longitude: loc.longitude };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarker} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         *
         */
        BingMarkerService.prototype.GetNativeMarker = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarker} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         *
         */
            function (marker) {
                return this._markers.get(marker);
            };
        /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         *
         */
        BingMarkerService.prototype.GetPixelsFromClick = /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         *
         */
            function (e) {
                /** @type {?} */
                var loc = this.GetCoordinatesFromClick(e);
                if (loc == null) {
                    return null;
                }
                /** @type {?} */
                var l = BingConversions.TranslateLocation(loc);
                /** @type {?} */
                var p = (((this._mapService)).MapInstance.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                if (p == null) {
                    return null;
                }
                return { x: p.x, y: p.y };
            };
        /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof BingMarkerService
         * @param {?} target - Either a {\@link MapMarker} or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         *
         */
        BingMarkerService.prototype.LocationToPoint = /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof BingMarkerService
         * @param {?} target - Either a {\@link MapMarker} or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         *
         */
            function (target) {
                var _this = this;
                if (target == null) {
                    return Promise.resolve(null);
                }
                if (target instanceof MapMarkerDirective) {
                    return this._markers.get(target).then(function (m) {
                        /** @type {?} */
                        var l = m.Location;
                        /** @type {?} */
                        var p = _this._mapService.LocationToPoint(l);
                        return p;
                    });
                }
                return this._mapService.LocationToPoint(target);
            };
        /**
         * Updates the anchor position for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         *
         */
        BingMarkerService.prototype.UpdateAnchor = /**
         * Updates the anchor position for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    m.SetAnchor(marker.Anchor);
                });
            };
        /**
         * Updates whether the marker is draggable.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         *
         */
        BingMarkerService.prototype.UpdateDraggable = /**
         * Updates whether the marker is draggable.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
            };
        /**
         * Updates the Icon on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         *
         */
        BingMarkerService.prototype.UpdateIcon = /**
         * Updates the Icon on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         *
         */
            function (marker) {
                /** @type {?} */
                var payload = function (m, icon, iconInfo) {
                    if (icon && icon !== '') {
                        m.SetIcon(icon);
                        marker.DynamicMarkerCreated.emit(iconInfo);
                    }
                };
                return this._markers.get(marker).then(function (m) {
                    if (marker.IconInfo) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(marker.IconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(m, s, marker.IconInfo));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(m, x.icon, x.iconInfo));
                            });
                        }
                    }
                    else {
                        return (m.SetIcon(marker.IconUrl));
                    }
                });
            };
        /**
         * Updates the label on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         *
         */
        BingMarkerService.prototype.UpdateLabel = /**
         * Updates the label on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
            };
        /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         *
         */
        BingMarkerService.prototype.UpdateMarkerPosition = /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    return m.SetPosition({
                        latitude: marker.Latitude,
                        longitude: marker.Longitude
                    });
                });
            };
        /**
         * Updates the title on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         *
         */
        BingMarkerService.prototype.UpdateTitle = /**
         * Updates the title on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
            };
        /**
         * Updates the visibility on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the visibility has been updated.
         *
         */
        BingMarkerService.prototype.UpdateVisible = /**
         * Updates the visibility on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the visibility has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
            };
        BingMarkerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMarkerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: ClusterService },
                { type: core.NgZone }
            ];
        };
        return BingMarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the MapService abstract implementing a Bin Map V8 provider
     *
     * @export
     */
    var BingMapService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMapService.
         * @param _loader MapAPILoader instance implemented for Bing Maps. This instance will generally be injected.
         * @param _zone NgZone object to enable zone aware promises. This will generally be injected.
         *
         * @memberof BingMapService
         */
        function BingMapService(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._modules = new Map();
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
            this._config = ((this._loader)).Config;
        }
        Object.defineProperty(BingMapService.prototype, "LoadedModules", {
            get: /**
             * Gets an array of loaded Bong modules.
             *
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._modules; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapInstance", {
            get: /**
             * Gets the Bing Map control instance underlying the implementation
             *
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._mapInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapPromise", {
            get: /**
             * Gets a Promise for a Bing Map control instance underlying the implementation. Use this instead of {\@link MapInstance} if you
             * are not sure if and when the instance will be created.
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._map; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapSize", {
            get: /**
             * Gets the maps physical size.
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapService
             * @return {?}
             */ function () {
                if (this.MapInstance) {
                    /** @type {?} */
                    var s = { width: this.MapInstance.getWidth(), height: this.MapInstance.getHeight() };
                    return s;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof BingMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
        BingMapService.prototype.CreateCanvasOverlay = /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof BingMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
            function (drawCallback) {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var overlay = new BingCanvasOverlay(drawCallback);
                    map.layers.insert(overlay);
                    return overlay;
                });
            };
        /**
         * Creates a Bing map cluster layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link IClusterOptions}.
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
         *
         */
        BingMapService.prototype.CreateClusterLayer = /**
         * Creates a Bing map cluster layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link IClusterOptions}.
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    /** @type {?} */
                    var p = new Promise(function (resolve) {
                        _this.LoadModule('Microsoft.Maps.Clustering', function () {
                            /** @type {?} */
                            var o = BingConversions.TranslateClusterOptions(options);
                            /** @type {?} */
                            var layer = new Microsoft.Maps.ClusterLayer(new Array(), o);
                            /** @type {?} */
                            var bl;
                            map.layers.insert(layer);
                            bl = new BingClusterLayer(layer, _this);
                            bl.SetOptions(options);
                            resolve(bl);
                        });
                    });
                    return p;
                });
            };
        /**
         * Creates an information window for a map position
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
        BingMapService.prototype.CreateInfoWindow = /**
         * Creates an information window for a map position
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
            function (options) {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var loc;
                    if (options.position == null) {
                        loc = map.getCenter();
                    }
                    else {
                        loc = new Microsoft.Maps.Location(options.position.latitude, options.position.longitude);
                    }
                    /** @type {?} */
                    var infoBox = new Microsoft.Maps.Infobox(loc, BingConversions.TranslateInfoBoxOptions(options));
                    infoBox.setMap(map);
                    return new BingInfoWindow(infoBox);
                });
            };
        /**
         * Creates a map layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
        BingMapService.prototype.CreateLayer = /**
         * Creates a map layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    /** @type {?} */
                    var layer = new Microsoft.Maps.Layer(options.id.toString());
                    map.layers.insert(layer);
                    return new BingLayer(layer, _this);
                });
            };
        /**
         * Creates a map instance
         *
         * \@memberof BingMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
        BingMapService.prototype.CreateMap = /**
         * Creates a map instance
         *
         * \@memberof BingMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
            function (el, mapOptions) {
                var _this = this;
                return this._loader.Load().then(function () {
                    // apply mixins
                    MixinMapLabelWithOverlayView();
                    MixinCanvasOverlay();
                    // map startup...
                    if (_this._mapInstance != null) {
                        _this.DisposeMap();
                    }
                    /** @type {?} */
                    var o = BingConversions.TranslateLoadOptions(mapOptions);
                    if (!o.credentials) {
                        o.credentials = _this._config.apiKey;
                    }
                    /** @type {?} */
                    var map = new Microsoft.Maps.Map(el, o);
                    _this._mapInstance = map;
                    _this._mapResolver(map);
                });
            };
        /**
         * Creates a Bing map marker within the map context
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
        BingMapService.prototype.CreateMarker = /**
         * Creates a Bing map marker within the map context
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
            function (options) {
                if (options === void 0) {
                    options = /** @type {?} */ ({});
                }
                /** @type {?} */
                var payload = function (icon, map) {
                    /** @type {?} */
                    var loc = BingConversions.TranslateLocation(options.position);
                    /** @type {?} */
                    var o = BingConversions.TranslateMarkerOptions(options);
                    if (icon && icon !== '') {
                        o.icon = icon;
                    }
                    /** @type {?} */
                    var pushpin = new Microsoft.Maps.Pushpin(loc, o);
                    /** @type {?} */
                    var marker = new BingMarker(pushpin, map, null);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                    }
                    map.entities.push(pushpin);
                    return marker;
                };
                return this._map.then(function (map) {
                    if (options.iconInfo && options.iconInfo.markerType) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(s, map));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(x.icon, map));
                            });
                        }
                    }
                    else {
                        return (payload(null, map));
                    }
                });
            };
        /**
         * Creates a polygon within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
        BingMapService.prototype.CreatePolygon = /**
         * Creates a polygon within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    /** @type {?} */
                    var locs = BingConversions.TranslatePaths(options.paths);
                    /** @type {?} */
                    var o = BingConversions.TranslatePolygonOptions(options);
                    /** @type {?} */
                    var poly = new Microsoft.Maps.Polygon(locs, o);
                    map.entities.push(poly);
                    /** @type {?} */
                    var p = new BingPolygon(poly, _this, null);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return p.Metadata.set(k, v); });
                    }
                    if (options.title && options.title !== '') {
                        p.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        p.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        p.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        p.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        p.LabelMinZoom = options.labelMinZoom;
                    }
                    if (options.editable) {
                        p.SetEditable(options.editable);
                    }
                    return p;
                });
            };
        /**
         * Creates a polyline within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array thereof for complex paths),
         * which models the underlying native polygon.
         *
         */
        BingMapService.prototype.CreatePolyline = /**
         * Creates a polyline within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array thereof for complex paths),
         * which models the underlying native polygon.
         *
         */
            function (options) {
                /** @type {?} */
                var polyline;
                return this._map.then(function (map) {
                    /** @type {?} */
                    var o = BingConversions.TranslatePolylineOptions(options);
                    /** @type {?} */
                    var locs = BingConversions.TranslatePaths(options.path);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        polyline = new Microsoft.Maps.Polyline(locs[0], o);
                        map.entities.push(polyline);
                        /** @type {?} */
                        var pl_1 = new BingPolyline(polyline, map, null);
                        if (options.metadata) {
                            options.metadata.forEach(function (v, k) { return pl_1.Metadata.set(k, v); });
                        }
                        if (options.title && options.title !== '') {
                            pl_1.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            pl_1.ShowTooltip = options.showTooltip;
                        }
                        return pl_1;
                    }
                    else {
                        /** @type {?} */
                        var lines_1 = new Array();
                        locs.forEach(function (p) {
                            polyline = new Microsoft.Maps.Polyline(p, o);
                            map.entities.push(polyline);
                            /** @type {?} */
                            var pl = new BingPolyline(polyline, map, null);
                            if (options.metadata) {
                                options.metadata.forEach(function (v, k) { return pl.Metadata.set(k, v); });
                            }
                            if (options.title && options.title !== '') {
                                pl.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                pl.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(pl);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Deletes a layer from the map.
         *
         * \@memberof BingMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Bing specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
        BingMapService.prototype.DeleteLayer = /**
         * Deletes a layer from the map.
         *
         * \@memberof BingMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Bing specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                return this._map.then(function (map) {
                    map.layers.remove(layer.NativePrimitve);
                });
            };
        /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof BingMapService
         * @return {?}
         */
        BingMapService.prototype.DisposeMap = /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof BingMapService
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._map == null && this._mapInstance == null) {
                    return;
                }
                if (this._mapInstance != null) {
                    this._mapInstance.dispose();
                    this._mapInstance = null;
                    this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
                }
            };
        /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
        BingMapService.prototype.GetCenter = /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var center = map.getCenter();
                    return /** @type {?} */ ({
                        latitude: center.latitude,
                        longitude: center.longitude
                    });
                });
            };
        /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the bounding box. See {\@link IBox}.
         *
         */
        BingMapService.prototype.GetBounds = /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the bounding box. See {\@link IBox}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var box = map.getBounds();
                    return /** @type {?} */ ({
                        maxLatitude: box.getNorth(),
                        maxLongitude: box.crossesInternationalDateLine() ? box.getWest() : box.getEast(),
                        minLatitude: box.getSouth(),
                        minLongitude: box.crossesInternationalDateLine() ? box.getEast() : box.getWest(),
                        center: { latitude: box.center.latitude, longitude: box.center.longitude },
                        padding: 0
                    });
                });
            };
        /**
         * Gets a shared or private instance of the map drawing tools.
         *
         * \@memberof BingMapService
         * @param {?=} useSharedInstance
         * @return {?} - Promise that when resolved containst an instance of the drawing tools.
         */
        BingMapService.prototype.GetDrawingTools = /**
         * Gets a shared or private instance of the map drawing tools.
         *
         * \@memberof BingMapService
         * @param {?=} useSharedInstance
         * @return {?} - Promise that when resolved containst an instance of the drawing tools.
         */
            function (useSharedInstance) {
                var _this = this;
                if (useSharedInstance === void 0) {
                    useSharedInstance = true;
                }
                return new Promise(function (resolve, reject) {
                    _this.LoadModuleInstance('Microsoft.Maps.DrawingTools', useSharedInstance).then(function (o) {
                        resolve(o);
                    });
                });
            };
        /**
         * Gets the current zoom level of the map.
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
        BingMapService.prototype.GetZoom = /**
         * Gets the current zoom level of the map.
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
            function () {
                return this._map.then(function (map) { return map.getZoom(); });
            };
        /**
         * Loads a module into the Map.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?} callback - Callback to call once loading is complete.
         * @return {?}
         */
        BingMapService.prototype.LoadModule = /**
         * Loads a module into the Map.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?} callback - Callback to call once loading is complete.
         * @return {?}
         */
            function (moduleName, callback) {
                var _this = this;
                if (this._modules.has(moduleName)) {
                    callback();
                }
                else {
                    Microsoft.Maps.loadModule(moduleName, function () {
                        _this._modules.set(moduleName, null);
                        callback();
                    });
                }
            };
        /**
         * Loads a module into the Map and delivers and instance of the module payload.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?=} useSharedInstance
         * @return {?}
         */
        BingMapService.prototype.LoadModuleInstance = /**
         * Loads a module into the Map and delivers and instance of the module payload.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?=} useSharedInstance
         * @return {?}
         */
            function (moduleName, useSharedInstance) {
                var _this = this;
                if (useSharedInstance === void 0) {
                    useSharedInstance = true;
                }
                /** @type {?} */
                var s = moduleName.substr(moduleName.lastIndexOf('.') + 1);
                if (this._modules.has(moduleName)) {
                    /** @type {?} */
                    var o = null;
                    if (!useSharedInstance) {
                        o = new ((Microsoft.Maps))[s](this._mapInstance);
                    }
                    else if (this._modules.get(moduleName) != null) {
                        o = this._modules.get(moduleName);
                    }
                    else {
                        o = new ((Microsoft.Maps))[s](this._mapInstance);
                        this._modules.set(moduleName, o);
                    }
                    return Promise.resolve(o);
                }
                else {
                    return new Promise(function (resolve, reject) {
                        try {
                            Microsoft.Maps.loadModule(moduleName, function () {
                                /** @type {?} */
                                var o = new ((Microsoft.Maps))[s](_this._mapInstance);
                                if (useSharedInstance) {
                                    _this._modules.set(moduleName, o);
                                }
                                else {
                                    _this._modules.set(moduleName, null);
                                }
                                resolve(o);
                            });
                        }
                        catch (e) {
                            reject('Could not load module or create instance.');
                        }
                    });
                }
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
        BingMapService.prototype.LocationToPoint = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
            function (loc) {
                return this._map.then(function (m) {
                    /** @type {?} */
                    var l = BingConversions.TranslateLocation(loc);
                    /** @type {?} */
                    var p = (m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                    if (p != null) {
                        return { x: p.x, y: p.y };
                    }
                    return null;
                });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
        BingMapService.prototype.LocationsToPoints = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
            function (locs) {
                return this._map.then(function (m) {
                    /** @type {?} */
                    var l = locs.map(function (loc) { return BingConversions.TranslateLocation(loc); });
                    /** @type {?} */
                    var p = (m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                    return p ? p : new Array();
                });
            };
        /**
         * Centers the map on a geo location.
         *
         * \@memberof BingMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
        BingMapService.prototype.SetCenter = /**
         * Centers the map on a geo location.
         *
         * \@memberof BingMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
            function (latLng) {
                return this._map.then(function (map) {
                    return map.setView({
                        center: BingConversions.TranslateLocation(latLng)
                    });
                });
            };
        /**
         * Sets the generic map options.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        BingMapService.prototype.SetMapOptions = /**
         * Sets the generic map options.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    /** @type {?} */
                    var o = BingConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the view options of the map.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        BingMapService.prototype.SetViewOptions = /**
         * Sets the view options of the map.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    /** @type {?} */
                    var o = BingConversions.TranslateViewOptions(options);
                    m.setView(o);
                });
            };
        /**
         * Sets the zoom level of the map.
         *
         * \@memberof BingMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
        BingMapService.prototype.SetZoom = /**
         * Sets the zoom level of the map.
         *
         * \@memberof BingMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
            function (zoom) {
                return this._map.then(function (map) {
                    return map.setView({
                        zoom: zoom
                    });
                });
            };
        /**
         * Creates an event subscription
         *
         * \@memberof BingMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of tpye E that fires when the event occurs.
         *
         */
        BingMapService.prototype.SubscribeToMapEvent = /**
         * Creates an event subscription
         *
         * \@memberof BingMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of tpye E that fires when the event occurs.
         *
         */
            function (eventName) {
                var _this = this;
                /** @type {?} */
                var eventNameTranslated = BingMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._map.then(function (m) {
                        Microsoft.Maps.Events.addHandler(m, eventNameTranslated, function (e) {
                            _this._zone.run(function () { return observer.next(e); });
                        });
                    });
                });
            };
        /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof BingMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
        BingMapService.prototype.TriggerMapEvent = /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof BingMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
            function (eventName) {
                return this._map.then(function (m) { return Microsoft.Maps.Events.invoke(m, eventName, null); });
            };
        BingMapService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapService.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return BingMapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Bing Maps V8 archtiecture. It serves
     * as the base class for basic layer ({\@link BingLayerService}) and cluster layer ({\@link BingClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Bing Maps V8 archtiecture. It serves
     * as the base class for basic layer ({\@link BingLayerService}) and cluster layer ({\@link BingClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */ BingLayerBase = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingLayerBase.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         *
         * @memberof BingLayerBase
         */
        function BingLayerBase(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._layers = new Map();
        }
        /**
         * Creates a marker in the layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
        BingLayerBase.prototype.CreateMarker = /**
         * Creates a marker in the layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
            function (layer, options) {
                /** @type {?} */
                var payload = function (icon, l) {
                    /** @type {?} */
                    var loc = BingConversions.TranslateLocation(options.position);
                    /** @type {?} */
                    var o = BingConversions.TranslateMarkerOptions(options);
                    if (icon && icon !== '') {
                        o.icon = icon;
                    }
                    /** @type {?} */
                    var pushpin = new Microsoft.Maps.Pushpin(loc, o);
                    /** @type {?} */
                    var marker = new BingMarker(pushpin, null, l.NativePrimitve);
                    marker.IsFirst = options.isFirst;
                    marker.IsLast = options.isLast;
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                    }
                    l.AddEntity(marker);
                    return marker;
                };
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    if (options.iconInfo && options.iconInfo.markerType) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(s, l));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(x.icon, l));
                            });
                        }
                    }
                    else {
                        return (payload(null, l));
                    }
                });
            };
        /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof BingLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
        BingLayerBase.prototype.CreateMarkers = /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof BingLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
            function (options, markerIcon) {
                /** @type {?} */
                var payload = function (icon, op) {
                    /** @type {?} */
                    var markers = op.map(function (mo) {
                        /** @type {?} */
                        var s;
                        /** @type {?} */
                        var o = BingConversions.TranslateMarkerOptions(mo);
                        if (icon && icon !== '') {
                            s = icon;
                        }
                        else if (o.icon) {
                            s = o.icon;
                        }
                        if (o.icon) {
                            delete o.icon;
                        }
                        /** @type {?} */
                        var loc = BingConversions.TranslateLocation(mo.position);
                        /** @type {?} */
                        var pushpin = new Microsoft.Maps.Pushpin(loc, o);
                        /** @type {?} */
                        var img = Marker.GetImageForMarker(s);
                        if (img != null) {
                            ((pushpin)).image = img;
                        }
                        /** @type {?} */
                        var marker = new BingMarker(pushpin, null, null);
                        marker.IsFirst = mo.isFirst;
                        marker.IsLast = mo.isLast;
                        if (mo.metadata) {
                            mo.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                        }
                        return marker;
                    });
                    return markers;
                };
                /** @type {?} */
                var p = new Promise(function (resolve, reject) {
                    if (markerIcon && markerIcon.markerType) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(markerIcon);
                        if (typeof (s) === 'string') {
                            resolve(payload(s, options));
                        }
                        else {
                            return s.then(function (x) {
                                resolve(payload(x.icon, options));
                            });
                        }
                    }
                    else {
                        resolve(payload(null, options));
                    }
                });
                return p;
            };
        /**
         * Deletes the layer
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
        BingLayerBase.prototype.DeleteLayer = /**
         * Deletes the layer
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.Delete();
                        _this._layers.delete(layer.Id);
                    });
                });
            };
        /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
        BingLayerBase.prototype.GetNativeLayer = /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
            function (layer) {
                /** @type {?} */
                var p = null;
                if (typeof (layer) === 'number') {
                    p = this._layers.get(layer);
                }
                else {
                    p = this._layers.get(((layer)).Id);
                }
                return p;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * @param id - Layer Id.
         * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.
         *
         * @memberof BingLayerBase
         */
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof BingLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
        BingLayerBase.prototype.GetLayerById = /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof BingLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
            function (id) {
                /** @type {?} */
                var p;
                this._layers.forEach(function (l, k) {
                    if (k === id) {
                        p = l;
                    }
                });
                return p;
            };
        return BingLayerBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements the {\@link LayerService} contract for a  Bing Maps V8 specific implementation.
     *
     * @export
     */
    var BingLayerService = (function (_super) {
        __extends(BingLayerService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingLayerService.
         * @param _mapService - Instance of the Bing Maps Service. Will generally be injected.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof BingLayerService
         */
        function BingLayerService(_mapService, _zone) {
            return _super.call(this, _mapService, _zone) || this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        BingLayerService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var layerPromise = this._mapService.CreateLayer({ id: layer.Id });
                this._layers.set(layer.Id, layerPromise);
                layerPromise.then(function (l) { return l.SetVisible(layer.Visible); });
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        BingLayerService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                var _this = this;
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    /** @type {?} */
                    var locs = BingConversions.TranslatePaths(options.paths);
                    /** @type {?} */
                    var o = BingConversions.TranslatePolygonOptions(options);
                    /** @type {?} */
                    var poly = new Microsoft.Maps.Polygon(locs, o);
                    /** @type {?} */
                    var polygon = new BingPolygon(poly, /** @type {?} */ (_this._mapService), l.NativePrimitve);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return polygon.Metadata.set(k, v); });
                    }
                    if (options.title && options.title !== '') {
                        polygon.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        polygon.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        polygon.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        polygon.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        polygon.LabelMinZoom = options.labelMinZoom;
                    }
                    l.AddEntity(polygon);
                    return polygon;
                });
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        BingLayerService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                var _this = this;
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    /** @type {?} */
                    var polygons = new Promise(function (resolve, reject) {
                        /** @type {?} */
                        var polys = options.map(function (o) {
                            /** @type {?} */
                            var locs = BingConversions.TranslatePaths(o.paths);
                            /** @type {?} */
                            var op = BingConversions.TranslatePolygonOptions(o);
                            /** @type {?} */
                            var poly = new Microsoft.Maps.Polygon(locs, op);
                            /** @type {?} */
                            var polygon = new BingPolygon(poly, /** @type {?} */ (_this._mapService), l.NativePrimitve);
                            if (o.title && o.title !== '') {
                                polygon.Title = o.title;
                            }
                            if (o.metadata) {
                                o.metadata.forEach(function (v, k) { return polygon.Metadata.set(k, v); });
                            }
                            return polygon;
                        });
                        resolve(polys);
                    });
                    return polygons;
                });
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        BingLayerService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                var _this = this;
                /** @type {?} */
                var p = this.GetLayerById(layer);
                /** @type {?} */
                var polyline;
                /** @type {?} */
                var line;
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    /** @type {?} */
                    var locs = BingConversions.TranslatePaths(options.path);
                    /** @type {?} */
                    var o = BingConversions.TranslatePolylineOptions(options);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        polyline = new Microsoft.Maps.Polyline(locs[0], o);
                        line = new BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                        l.AddEntity(line);
                        if (options.metadata) {
                            options.metadata.forEach(function (v, k) { return line.Metadata.set(k, v); });
                        }
                        if (options.title && options.title !== '') {
                            line.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            line.ShowTooltip = options.showTooltip;
                        }
                        return line;
                    }
                    else {
                        /** @type {?} */
                        var lines_1 = new Array();
                        locs.forEach(function (x) {
                            polyline = new Microsoft.Maps.Polyline(x, o);
                            line = new BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                            l.AddEntity(line);
                            if (options.metadata) {
                                options.metadata.forEach(function (v, k) { return line.Metadata.set(k, v); });
                            }
                            if (options.title && options.title !== '') {
                                line.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                line.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(line);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        BingLayerService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                var _this = this;
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    /** @type {?} */
                    var polylines = new Promise(function (resolve, reject) {
                        /** @type {?} */
                        var polys = options.map(function (o) {
                            /** @type {?} */
                            var locs = BingConversions.TranslatePaths(o.path);
                            /** @type {?} */
                            var op = BingConversions.TranslatePolylineOptions(o);
                            if (locs && locs.length > 0 && !Array.isArray(locs[0])) {
                                /** @type {?} */
                                var poly = new Microsoft.Maps.Polyline(locs[0], op);
                                /** @type {?} */
                                var polyline_1 = new BingPolyline(poly, _this._mapService.MapInstance, l.NativePrimitve);
                                if (o.title && o.title !== '') {
                                    polyline_1.Title = o.title;
                                }
                                if (o.metadata) {
                                    o.metadata.forEach(function (v, k) { return polyline_1.Metadata.set(k, v); });
                                }
                                return polyline_1;
                            }
                            else {
                                /** @type {?} */
                                var lines_2 = new Array();
                                locs.forEach(function (x) {
                                    /** @type {?} */
                                    var poly = new Microsoft.Maps.Polyline(x, op);
                                    /** @type {?} */
                                    var polyline = new BingPolyline(poly, _this._mapService.MapInstance, l.NativePrimitve);
                                    if (o.metadata) {
                                        o.metadata.forEach(function (v, k) { return polyline.Metadata.set(k, v); });
                                    }
                                    if (o.title && o.title !== '') {
                                        polyline.Title = o.title;
                                    }
                                    lines_2.push(polyline);
                                });
                                return lines_2;
                            }
                        });
                        resolve(polys);
                    });
                    return polylines;
                });
            };
        BingLayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingLayerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingLayerService;
    }(BingLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements the {\@link ClusterService} contract for a  Bing Maps V8 specific implementation.
     *
     * @export
     */
    var BingClusterService = (function (_super) {
        __extends(BingClusterService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingClusterService.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof BingClusterService
         */
        function BingClusterService(_mapService, _zone) {
            return _super.call(this, _mapService, _zone) || this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object.
         * Generally, MapLayer will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        BingClusterService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object.
         * Generally, MapLayer will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var options = {
                    id: layer.Id,
                    visible: layer.Visible,
                    clusteringEnabled: layer.ClusteringEnabled,
                    placementMode: layer.ClusterPlacementMode
                };
                if (layer.GridSize) {
                    options.gridSize = layer.GridSize;
                }
                if (layer.LayerOffset) {
                    options.layerOffset = layer.LayerOffset;
                }
                if (layer.ZIndex) {
                    options.zIndex = layer.ZIndex;
                }
                if (layer.IconInfo) {
                    options.clusteredPinCallback = function (pin) { _this.CreateClusterPushPin(pin, layer); };
                }
                if (layer.CustomMarkerCallback) {
                    options.clusteredPinCallback = function (pin) { _this.CreateCustomClusterPushPin(pin, layer); };
                }
                if (layer.SpiderClusterOptions) {
                    options.spiderClusterOptions = layer.SpiderClusterOptions;
                }
                /** @type {?} */
                var layerPromise = this._mapService.CreateClusterLayer(options);
                ((this._mapService)).MapPromise.then(function (m) {
                    Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) {
                        if (layer.ClusteringEnabled && m.getZoom() === 19) {
                            layerPromise.then(function (l) {
                                l.SetOptions({ id: layer.Id, clusteringEnabled: false });
                            });
                        }
                        if (layer.ClusteringEnabled && m.getZoom() < 19) {
                            layerPromise.then(function (l) {
                                if (!l.GetOptions().clusteringEnabled) {
                                    l.SetOptions({ id: layer.Id, clusteringEnabled: true });
                                }
                            });
                        }
                    });
                });
                this._layers.set(layer.Id, layerPromise);
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        BingClusterService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        BingClusterService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        BingClusterService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        BingClusterService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.StartClustering();
                    });
                });
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.StopClustering();
                    });
                });
            };
        /**
         * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {\@link ClusterLayerDirective} model
         * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
         * clusters in the layer.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component representing the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.CreateClusterPushPin = /**
         * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {\@link ClusterLayerDirective} model
         * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
         * clusters in the layer.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component representing the layer.
         *
         * @return {?}
         */
            function (cluster, layer) {
                var _this = this;
                this._layers.get(layer.Id).then(function (l) {
                    if (layer.IconInfo) {
                        /** @type {?} */
                        var o_1 = {};
                        /** @type {?} */
                        var payload_1 = function (ico, info) {
                            o_1.icon = ico;
                            o_1.anchor = new Microsoft.Maps.Point((info.size && info.markerOffsetRatio) ? (info.size.width * info.markerOffsetRatio.x) : 0, (info.size && info.markerOffsetRatio) ? (info.size.height * info.markerOffsetRatio.y) : 0);
                            cluster.setOptions(o_1);
                        };
                        /** @type {?} */
                        var icon = Marker.CreateMarker(layer.IconInfo);
                        if (typeof (icon) === 'string') {
                            payload_1(icon, layer.IconInfo);
                        }
                        else {
                            icon.then(function (x) {
                                payload_1(x.icon, x.iconInfo);
                            });
                        }
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {
                        Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.Spider) {
                        Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                        l.InitializeSpiderClusterSupport();
                    }
                });
            };
        /**
         * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
         * in situation where the pin should differ to represent information about the pins in the cluster.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component
         * representing the layer. Set the {\@link ClusterLayerDirective.CustomMarkerCallback}
         * property to define the callback generating the pin.
         *
         * @return {?}
         */
        BingClusterService.prototype.CreateCustomClusterPushPin = /**
         * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
         * in situation where the pin should differ to represent information about the pins in the cluster.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component
         * representing the layer. Set the {\@link ClusterLayerDirective.CustomMarkerCallback}
         * property to define the callback generating the pin.
         *
         * @return {?}
         */
            function (cluster, layer) {
                var _this = this;
                this._layers.get(layer.Id).then(function (l) {
                    /** @type {?} */
                    var m = new Array();
                    cluster.containedPushpins.forEach(function (p) {
                        /** @type {?} */
                        var marker = l.GetMarkerFromBingMarker(p);
                        if (marker) {
                            m.push(marker);
                        }
                    });
                    /** @type {?} */
                    var iconInfo = { markerType: MarkerTypeId.None };
                    /** @type {?} */
                    var o = {};
                    o.icon = layer.CustomMarkerCallback(m, iconInfo);
                    if (o.icon !== '') {
                        o.anchor = new Microsoft.Maps.Point((iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0, (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0);
                        if (iconInfo.textOffset) {
                            o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y);
                        }
                        cluster.setOptions(o);
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {
                        Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.Spider) {
                        Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                        l.InitializeSpiderClusterSupport();
                    }
                });
            };
        /**
         * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
         *
         * \@memberof BingClusterService
         * @param {?} e - Mouse Event.
         *
         * @return {?}
         */
        BingClusterService.prototype.ZoomIntoCluster = /**
         * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
         *
         * \@memberof BingClusterService
         * @param {?} e - Mouse Event.
         *
         * @return {?}
         */
            function (e) {
                /** @type {?} */
                var pin = (e.target);
                if (pin && pin.containedPushpins) {
                    /** @type {?} */
                    var bounds_1 = void 0;
                    /** @type {?} */
                    var locs_1 = new Array();
                    pin.containedPushpins.forEach(function (p) { return locs_1.push(p.getLocation()); });
                    bounds_1 = Microsoft.Maps.LocationRect.fromLocations(locs_1);
                    // Zoom into the bounding box of the cluster.
                    // Add a padding to compensate for the pixel area of the pushpins.
                    ((this._mapService)).MapPromise.then(function (m) {
                        m.setView({ bounds: bounds_1, padding: 75 });
                    });
                }
            };
        BingClusterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingClusterService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingClusterService;
    }(BingLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingPolygonService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingPolygonService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link BingLayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingPolygonService
         */
        function BingPolygonService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polygons = new Map();
        }
        /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
        BingPolygonService.prototype.AddPolygon = /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
            function (polygon) {
                /** @type {?} */
                var o = {
                    id: polygon.Id,
                    clickable: polygon.Clickable,
                    draggable: polygon.Draggable,
                    editable: polygon.Editable,
                    fillColor: polygon.FillColor,
                    fillOpacity: polygon.FillOpacity,
                    geodesic: polygon.Geodesic,
                    labelMaxZoom: polygon.LabelMaxZoom,
                    labelMinZoom: polygon.LabelMinZoom,
                    paths: polygon.Paths,
                    showLabel: polygon.ShowLabel,
                    showTooltip: polygon.ShowTooltip,
                    strokeColor: polygon.StrokeColor,
                    strokeOpacity: polygon.StrokeOpacity,
                    strokeWeight: polygon.StrokeWeight,
                    title: polygon.Title,
                    visible: polygon.Visible,
                    zIndex: polygon.zIndex,
                };
                /** @type {?} */
                var polygonPromise;
                if (polygon.InCustomLayer) {
                    polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);
                }
                else {
                    polygonPromise = this._mapService.CreatePolygon(o);
                }
                this._polygons.set(polygon, polygonPromise);
            };
        /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof BingPolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingPolygonService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof BingPolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polygon) {
                var _this = this;
                /** @type {?} */
                var b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._polygons.get(polygon).then(function (p) {
                        p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a polygon.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
        BingPolygonService.prototype.DeletePolygon = /**
         * Deletes a polygon.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
            function (polygon) {
                var _this = this;
                /** @type {?} */
                var m = this._polygons.get(polygon);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        l.Delete();
                        _this._polygons.delete(polygon);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof BingPolygonService
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingPolygonService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof BingPolygonService
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                /** @type {?} */
                var x = (e);
                return { latitude: x.location.latitude, longitude: x.location.longitude };
            };
        /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
        BingPolygonService.prototype.GetNativePolygon = /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
            function (polygon) {
                return this._polygons.get(polygon);
            };
        /**
         * Set the polygon options.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
        BingPolygonService.prototype.SetOptions = /**
         * Set the polygon options.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
            function (polygon, options) {
                return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
            };
        /**
         * Updates the Polygon path
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
        BingPolygonService.prototype.UpdatePolygon = /**
         * Updates the Polygon path
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
            function (polygon) {
                /** @type {?} */
                var m = this._polygons.get(polygon);
                if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    if (Array.isArray(polygon.Paths[0])) {
                        l.SetPaths(polygon.Paths);
                    }
                    else {
                        l.SetPath(/** @type {?} */ (polygon.Paths));
                    }
                });
            };
        BingPolygonService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingPolygonService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return BingPolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingPolylineService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingPolylineService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingPolylineService
         */
        function BingPolylineService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polylines = new Map();
        }
        /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * corresponding layer.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
        BingPolylineService.prototype.AddPolyline = /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * corresponding layer.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
            function (polyline) {
                /** @type {?} */
                var o = {
                    id: polyline.Id,
                    clickable: polyline.Clickable,
                    draggable: polyline.Draggable,
                    editable: polyline.Editable,
                    geodesic: polyline.Geodesic,
                    path: polyline.Path,
                    showTooltip: polyline.ShowTooltip,
                    strokeColor: polyline.StrokeColor,
                    strokeOpacity: polyline.StrokeOpacity,
                    strokeWeight: polyline.StrokeWeight,
                    title: polyline.Title,
                    visible: polyline.Visible,
                    zIndex: polyline.zIndex,
                };
                /** @type {?} */
                var polylinePromise;
                if (polyline.InCustomLayer) {
                    polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);
                }
                else {
                    polylinePromise = this._mapService.CreatePolyline(o);
                }
                this._polylines.set(polyline, polylinePromise);
            };
        /**
         * Registers an event delegate for a line.
         *
         * \@memberof BingPolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingPolylineService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a line.
         *
         * \@memberof BingPolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polyline) {
                var _this = this;
                /** @type {?} */
                var b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._polylines.get(polyline).then(function (p) {
                        /** @type {?} */
                        var x = Array.isArray(p) ? p : [p];
                        x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
                    });
                });
            };
        /**
         * Deletes a polyline.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
        BingPolylineService.prototype.DeletePolyline = /**
         * Deletes a polyline.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
            function (polyline) {
                var _this = this;
                /** @type {?} */
                var m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        /** @type {?} */
                        var x = Array.isArray(l) ? l : [l];
                        x.forEach(function (line) { return line.Delete(); });
                        _this._polylines.delete(polyline);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * @abstract
         * \@memberof BingPolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingPolylineService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * @abstract
         * \@memberof BingPolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.location) {
                    return null;
                }
                return { latitude: e.location.latitude, longitude: e.location.longitude };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
        BingPolylineService.prototype.GetNativePolyline = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
            function (polyline) {
                return this._polylines.get(polyline);
            };
        /**
         * Set the polyline options.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
        BingPolylineService.prototype.SetOptions = /**
         * Set the polyline options.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
            function (polyline, options) {
                return this._polylines.get(polyline).then(function (l) {
                    /** @type {?} */
                    var x = Array.isArray(l) ? l : [l];
                    x.forEach(function (line) { return line.SetOptions(options); });
                });
            };
        /**
         * Updates the Polyline path
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
        BingPolylineService.prototype.UpdatePolyline = /**
         * Updates the Polyline path
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
            function (polyline) {
                var _this = this;
                /** @type {?} */
                var m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        /** @type {?} */
                        var x = Array.isArray(l) ? l : [l];
                        /** @type {?} */
                        var p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? /** @type {?} */ (polyline.Path) : /** @type {?} */ ([polyline.Path]);
                        x.forEach(function (line, index) {
                            if (p.length > index) {
                                line.SetPath(p[index]);
                            }
                        });
                        if (Array.isArray(l) && l.length > p.length) {
                            l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
                        }
                    });
                });
            };
        BingPolylineService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingPolylineService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return BingPolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements a factory to create thre necessary Bing Maps V8 specific service instances.
     *
     * @export
     */
    var BingMapServiceFactory = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMapServiceFactory.
         * @param _loader - {@link MapAPILoader} implementation for the Bing Map V8 provider.
         * @param _zone - NgZone object to implement zone aware promises.
         *
         * @memberof BingMapServiceFactory
         */
        function BingMapServiceFactory(_loader, _zone) {
            this._loader = _loader;
            this._zone = _zone;
        }
        /**
         * Creates the map service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link BingMapService}.
         *
         */
        BingMapServiceFactory.prototype.Create = /**
         * Creates the map service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link BingMapService}.
         *
         */
            function () {
                return new BingMapService(this._loader, this._zone);
            };
        /**
         * Creates the cluster service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link BingClusterService}.
         *
         */
        BingMapServiceFactory.prototype.CreateClusterService = /**
         * Creates the cluster service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link BingClusterService}.
         *
         */
            function (_mapService) {
                return new BingClusterService(_mapService, this._zone);
            };
        /**
         * Creates thh info box service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link BingInfoBoxService}.
         *
         */
        BingMapServiceFactory.prototype.CreateInfoBoxService = /**
         * Creates thh info box service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link BingInfoBoxService}.
         *
         */
            function (_mapService) {
                return new BingInfoBoxService(_mapService, this._zone);
            };
        /**
         * Creates the layer service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link BingLayerService}.
         *
         */
        BingMapServiceFactory.prototype.CreateLayerService = /**
         * Creates the layer service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link BingLayerService}.
         *
         */
            function (_mapService) {
                return new BingLayerService(_mapService, this._zone);
            };
        /**
         * Creates the marker service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link BingMarkerService}.
         *
         */
        BingMapServiceFactory.prototype.CreateMarkerService = /**
         * Creates the marker service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link BingMarkerService}.
         *
         */
            function (_mapService, _layerService, _clusterService) {
                return new BingMarkerService(_mapService, _layerService, _clusterService, this._zone);
            };
        /**
         * Creates the polygon service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
        BingMapServiceFactory.prototype.CreatePolygonService = /**
         * Creates the polygon service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new BingPolygonService(map, layers, this._zone);
            };
        /**
         * Creates the polyline service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
        BingMapServiceFactory.prototype.CreatePolylineService = /**
         * Creates the polyline service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new BingPolylineService(map, layers, this._zone);
            };
        BingMapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapServiceFactory.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return BingMapServiceFactory;
    }());
    /**
     * Creates a new instance of a plaform specific MapServiceFactory.
     *
     * @export
     * @param {?} apiLoader - An {\@link MapAPILoader} instance. This is expected to the a {\@link BingMapAPILoader}.
     * @param {?} zone - An NgZone instance to provide zone aware promises.
     *
     * @return {?} -  A {\@link MapServiceFactory} instance.
     */
    function BingMapServiceFactoryFactory(apiLoader, zone) {
        return new BingMapServiceFactory(apiLoader, zone);
    }
    /**
     * Creates a new instance of a plaform specific MapLoaderFactory.
     *
     * @export
     * @return {?} - A {\@link MapAPILoader} instance.
     */
    function BingMapLoaderFactory() {
        return new BingMapAPILoader(new BingMapAPILoaderConfig(), new WindowRef(), new DocumentRef());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Google Maps archtiecture. It serves
     * as the base class for basic layer ({\@link GoogleLayerService}) and cluster layer ({\@link GoogleClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Google Maps archtiecture. It serves
     * as the base class for basic layer ({\@link GoogleLayerService}) and cluster layer ({\@link GoogleClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */ GoogleLayerBase = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleLayerBase.
         * @param _mapService - Concrete {@link MapService} implementation for Google Maps.
         * An instance of {@link GoogleMapService}.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof GoogleLayerBase
         */
        function GoogleLayerBase(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
        }
        /**
         * Deletes the layer
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
        GoogleLayerBase.prototype.DeleteLayer = /**
         * Deletes the layer
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.Delete();
                        _this._layers.delete(layer.Id);
                    });
                });
            };
        /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object or layer id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
        GoogleLayerBase.prototype.GetNativeLayer = /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object or layer id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
            function (layer) {
                /** @type {?} */
                var p = null;
                if (typeof (layer) === 'number') {
                    p = this._layers.get(layer);
                }
                else {
                    p = this._layers.get(((layer)).Id);
                }
                return p;
            };
        /**
         * Creates a marker in the layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
        GoogleLayerBase.prototype.CreateMarker = /**
         * Creates a marker in the layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
            function (layer, options) {
                /** @type {?} */
                var mp = this._mapService.MapPromise;
                /** @type {?} */
                var lp = this._layers.get(layer);
                return Promise.all([mp, lp]).then(function (_a) {
                    var _b = __read(_a, 2), map = _b[0], l = _b[1];
                    /** @type {?} */
                    var payload = function (x) {
                        /** @type {?} */
                        var marker = new google.maps.Marker(x);
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return marker.Metadata.set(key, val); });
                        }
                        marker.setMap(map);
                        /** @type {?} */
                        var m = new GoogleMarker(marker);
                        m.IsFirst = options.isFirst;
                        m.IsLast = options.isLast;
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return m.Metadata.set(key, val); });
                        }
                        l.AddEntity(m);
                        return m;
                    };
                    /** @type {?} */
                    var o = GoogleConversions.TranslateMarkerOptions(options);
                    if (options.iconInfo && options.iconInfo.markerType) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            o.icon = s;
                            return payload(o);
                        }
                        else {
                            return s.then(function (x) {
                                o.icon = x.icon;
                                return payload(o);
                            });
                        }
                    }
                    else {
                        return payload(o);
                    }
                });
            };
        /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
        GoogleLayerBase.prototype.CreateMarkers = /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
            function (options, markerIcon) {
                /** @type {?} */
                var payload = function (icon) {
                    /** @type {?} */
                    var markers = options.map(function (mo) {
                        /** @type {?} */
                        var o = GoogleConversions.TranslateMarkerOptions(mo);
                        if (icon && icon !== '') {
                            o.icon = icon;
                        }
                        /** @type {?} */
                        var pushpin = new google.maps.Marker(o);
                        /** @type {?} */
                        var marker = new GoogleMarker(pushpin);
                        marker.IsFirst = mo.isFirst;
                        marker.IsLast = mo.isLast;
                        if (mo.metadata) {
                            mo.metadata.forEach(function (val, key) { return marker.Metadata.set(key, val); });
                        }
                        return marker;
                    });
                    return markers;
                };
                /** @type {?} */
                var p = new Promise(function (resolve, reject) {
                    if (markerIcon && markerIcon.markerType) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(markerIcon);
                        if (typeof (s) === 'string') {
                            resolve(payload(s));
                        }
                        else {
                            return s.then(function (x) {
                                resolve(payload(x.icon));
                            });
                        }
                    }
                    else {
                        resolve(payload(null));
                    }
                });
                return p;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * @param id - Layer Id.
         * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.
         *
         * @memberof GoogleLayerBase
         */
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof GoogleLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
        GoogleLayerBase.prototype.GetLayerById = /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof GoogleLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
            function (id) {
                /** @type {?} */
                var p;
                this._layers.forEach(function (l, k) {
                    if (k === id) {
                        p = l;
                    }
                });
                return p;
            };
        return GoogleLayerBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var GoogleClusterService = (function (_super) {
        __extends(GoogleClusterService, _super);
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleClusterService.
         * @param _mapService
         * @param _zone
         * @memberof GoogleClusterService
         */
        function GoogleClusterService(_mapService, _zone) {
            var _this = _super.call(this, _mapService, _zone) || this;
            _this._layers = new Map();
            _this._layerStyles = new Map();
            return _this;
        }
        /**
         * Creates the cluster icon from the styles
         *
         * \@memberof GoogleClusterService
         * @param {?} styles
         * @return {?} - Promise that when resolved contains an Array of IClusterIconInfo objects
         * containing the hydrated cluster icons.
         */
        GoogleClusterService.CreateClusterIcons = /**
         * Creates the cluster icon from the styles
         *
         * \@memberof GoogleClusterService
         * @param {?} styles
         * @return {?} - Promise that when resolved contains an Array of IClusterIconInfo objects
         * containing the hydrated cluster icons.
         */
            function (styles) {
                /** @type {?} */
                var i = new Promise(function (resolve, reject) {
                    /** @type {?} */
                    var pa = new Array();
                    styles.forEach(function (style, index) {
                        if (style.iconInfo) {
                            /** @type {?} */
                            var s = Marker.CreateMarker(style.iconInfo);
                            if (typeof (s) === 'string') {
                                style.url = s;
                                if (style.width == null) {
                                    style.width = style.iconInfo.size.width;
                                    style.height = style.iconInfo.size.height;
                                }
                                if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {
                                    /** @type {?} */
                                    var o = style.iconInfo;
                                    style.anchor = [
                                        o.size.width * o.markerOffsetRatio.x,
                                        o.size.height * o.markerOffsetRatio.y
                                    ];
                                }
                                delete style.iconInfo;
                            }
                            else {
                                s.then(function (x) {
                                    style.url = x.icon;
                                    if (style.width == null) {
                                        style.width = x.iconInfo.size.width;
                                        style.height = x.iconInfo.size.height;
                                    }
                                    if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {
                                        /** @type {?} */
                                        var o = x.iconInfo;
                                        style.anchor = [
                                            o.size.width * o.markerOffsetRatio.x,
                                            o.size.height * o.markerOffsetRatio.y
                                        ];
                                    }
                                    delete style.iconInfo;
                                });
                                pa.push(s);
                            }
                        }
                    });
                    if (pa.length === 0) {
                        resolve(styles);
                    }
                    else {
                        Promise.all(pa).then(function () {
                            resolve(styles);
                        });
                    }
                });
                return i;
            };
        /**
         * Adds the cluster layer to the map
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.AddLayer = /**
         * Adds the cluster layer to the map
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var options = {
                    id: layer.Id,
                    visible: layer.Visible,
                    clusteringEnabled: layer.ClusteringEnabled,
                    zoomOnClick: layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster
                };
                if (layer.GridSize) {
                    options.gridSize = layer.GridSize;
                }
                if (layer.MinimumClusterSize) {
                    options.minimumClusterSize = layer.MinimumClusterSize;
                }
                if (layer.Styles) {
                    options.styles = layer.Styles;
                }
                if (layer.UseDynamicSizeMarkers) {
                    options.styles = null;
                    // do not to attempt to setup styles here as the dynamic call back will generate them.
                }
                else {
                    options.styles = [{
                            height: 30,
                            width: 35,
                            textColor: 'white',
                            textSize: 11,
                            backgroundPosition: 'center',
                            iconInfo: {
                                markerType: MarkerTypeId.FontMarker,
                                fontName: 'FontAwesome',
                                fontSize: 30,
                                color: 'green',
                                text: '\uF111'
                            }
                        }];
                }
                /** @type {?} */
                var dynamicClusterCallback = function (markers, numStyles, clusterer) {
                    /** @type {?} */
                    var styles = _this._layerStyles.get(layer.Id);
                    /** @type {?} */
                    var iconInfo = {
                        markerType: MarkerTypeId.None
                    };
                    /** @type {?} */
                    var icon = layer.CustomMarkerCallback(/** @type {?} */ (markers), iconInfo);
                    styles[0] = {
                        url: "\"data:image/svg+xml;utf8," + icon + "\"",
                        height: iconInfo.size.height,
                        width: iconInfo.size.width,
                        textColor: 'white',
                        textSize: 11,
                        backgroundPosition: 'center',
                    };
                    return {
                        text: markers.length.toString(),
                        index: 1
                    };
                };
                /** @type {?} */
                var resetStyles = function (clusterer) {
                    if (_this._layerStyles.has(layer.Id)) {
                        _this._layerStyles.get(layer.Id).splice(0);
                    }
                    else {
                        /** @type {?} */
                        var styles = new Array();
                        styles.push({});
                        _this._layerStyles.set(layer.Id, styles);
                        clusterer.setStyles(styles);
                        // this is important for dynamic styles as the pointer to this array gets passed
                        // around key objects in the clusterer. Therefore, it must be initialized here in order for
                        // updates to the styles to be visible.
                        // also, we need to add at least one style to prevent the default styles from being picked up.
                    }
                };
                /** @type {?} */
                var layerPromise = this._mapService.CreateClusterLayer(options);
                this._layers.set(layer.Id, layerPromise);
                layerPromise.then(function (l) {
                    /** @type {?} */
                    var clusterer = (l.NativePrimitve);
                    if (options.styles) {
                        /** @type {?} */
                        var s = GoogleClusterService.CreateClusterIcons(options.styles);
                        s.then(function (x) {
                            clusterer.setStyles(/** @type {?} */ (x));
                        });
                    }
                    else {
                        resetStyles(clusterer);
                        _this._mapService.MapPromise.then(function (m) {
                            m.addListener('zoom_changed', function () {
                                resetStyles(clusterer);
                            });
                        });
                        clusterer.setCalculator(function (m, n) {
                            return dynamicClusterCallback(m, n, clusterer);
                        });
                    }
                });
            };
        /**
         * Create a marker in the cluster
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
        GoogleClusterService.prototype.CreateMarker = /**
         * Create a marker in the cluster
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
            function (layer, options) {
                var _this = this;
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    return _this._mapService.CreateMarker(options)
                        .then(function (marker) {
                        marker.IsFirst = options.isFirst;
                        marker.IsLast = options.isLast;
                        l.AddEntity(marker);
                        return marker;
                    });
                });
            };
        /**
         * Starts the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.StartClustering = /**
         * Starts the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                return Promise.resolve();
            };
        /**
         * Stops the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.StopClustering = /**
         * Stops the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                return Promise.resolve();
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        GoogleClusterService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        GoogleClusterService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an
         * array of polygons for complex paths) model.
         *
         */
        GoogleClusterService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an
         * array of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        GoogleClusterService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        GoogleClusterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleClusterService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return GoogleClusterService;
    }(GoogleLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var GoogleInfoBoxService = (function (_super) {
        __extends(GoogleInfoBoxService, _super);
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleInfoBoxService.
         * @param _mapService
         * @param _markerService
         * @param _zone
         *
         * @memberof GoogleInfoBoxService
         */
        function GoogleInfoBoxService(_mapService, _markerService, _zone) {
            var _this = _super.call(this) || this;
            _this._mapService = _mapService;
            _this._markerService = _markerService;
            _this._zone = _zone;
            _this._boxes = new Map();
            return _this;
        }
        /**
         * Creates a new instance of an info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.AddInfoWindow = /**
         * Creates a new instance of an info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
            function (info) {
                /** @type {?} */
                var options = {};
                if (info.HtmlContent !== '') {
                    options.htmlContent = info.HtmlContent;
                }
                else {
                    options.title = info.Title;
                    options.description = info.Description;
                }
                if (info.xOffset || info.yOffset) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    if (info.xOffset) {
                        options.pixelOffset.x = info.xOffset;
                    }
                    if (info.yOffset) {
                        options.pixelOffset.y = info.yOffset;
                    }
                }
                options.disableAutoPan = info.DisableAutoPan;
                options.visible = info.Visible;
                if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {
                    options.position = { latitude: info.Latitude, longitude: info.Longitude };
                }
                /** @type {?} */
                var infoWindowPromise = this._mapService.CreateInfoWindow(options);
                this._boxes.set(info, infoWindowPromise);
            };
        /**
         * Closes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @return {?} -  A promise that is resolved when the info box is closed.
         *
         */
        GoogleInfoBoxService.prototype.Close = /**
         * Closes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @return {?} -  A promise that is resolved when the info box is closed.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (w) {
                    w.Close();
                });
            };
        /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GoogleInfoBoxService.prototype.CreateEventObservable = /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, infoComponent) {
                var _this = this;
                /** @type {?} */
                var googleEventName = GoogleMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._boxes.get(infoComponent).then(function (b) {
                        b.AddListener(googleEventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.DeleteInfoWindow = /**
         * Deletes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
            function (info) {
                return Promise.resolve();
            };
        /**
         * Opens the info window. Window opens on a marker, if supplied, or a specific location if given
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?=} loc
         * @return {?}
         */
        GoogleInfoBoxService.prototype.Open = /**
         * Opens the info window. Window opens on a marker, if supplied, or a specific location if given
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?=} loc
         * @return {?}
         */
            function (info, loc) {
                var _this = this;
                if (info.CloseInfoBoxesOnOpen || info.Modal) {
                    // close all open info boxes
                    this._boxes.forEach(function (box, i) {
                        if (info.Id !== i.Id) {
                            box.then(function (w) {
                                if (w.IsOpen) {
                                    w.Close();
                                    i.Close();
                                }
                            });
                        }
                    });
                }
                return this._boxes.get(info).then(function (w) {
                    /** @type {?} */
                    var options = {};
                    if (info.HtmlContent !== '') {
                        options.htmlContent = info.HtmlContent;
                    }
                    else {
                        options.title = info.Title;
                        options.description = info.Description;
                    }
                    w.SetOptions(options);
                    if (info.HostMarker != null) {
                        return _this._markerService.GetNativeMarker(info.HostMarker).then(function (marker) {
                            return _this._mapService.MapPromise.then(function (map) { return ((w)).Open(((marker)).NativePrimitve); });
                        });
                    }
                    return _this._mapService.MapPromise.then(function (map) {
                        if (loc) {
                            w.SetPosition(loc);
                        }
                        w.Open();
                    });
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} options
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.SetOptions = /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} options
         *
         * @return {?}
         */
            function (info, options) {
                return this._boxes.get(info).then(function (w) {
                    w.SetOptions(options);
                });
            };
        /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} latlng
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.SetPosition = /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} latlng
         *
         * @return {?}
         */
            function (info, latlng) {
                this._boxes.get(info).then(function (w) {
                    w.SetPosition(latlng);
                });
                return Promise.resolve();
            };
        GoogleInfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleInfoBoxService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: MarkerService },
                { type: core.NgZone }
            ];
        };
        return GoogleInfoBoxService;
    }(InfoBoxService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of a layer for the Google Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a layer for the Google Map Provider.
     *
     * @export
     */ GoogleLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the GoogleMarkerClusterer class.
         *
         * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof GoogleLayer
         */
        function GoogleLayer(_layer, _maps, _id) {
            this._layer = _layer;
            this._maps = _maps;
            this._id = _id;
            this._entities = new Array();
            this._visible = true;
        }
        Object.defineProperty(GoogleLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer. Google does not have the concept of a custom layer,
             * so we are returning the Map as the native object because it hosts all the markers.
             *
             * \@memberof GoogleLayer
             * @return {?} GoogleMapTypes.GoogleMap.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                throw (new Error('Events are not supported on Google Layers. You can still add events to individual markers.'));
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleLAyer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleLAyer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    this._entities.push(entity);
                    entity.NativePrimitve.setVisible(this._visible);
                    entity.NativePrimitve.setMap(this.NativePrimitve);
                }
            };
        /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof GoogleLAyer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddEntities = /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof GoogleLAyer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    (_a = this._entities).push.apply(_a, __spread(entities));
                    async.eachSeries(__spread(entities), function (e, next) {
                        e.NativePrimitve.setVisible(_this._visible);
                        e.NativePrimitve.setMap(_this.NativePrimitve);
                        async.nextTick(function () { return next(); });
                    });
                }
                var _a;
            };
        /**
         * Deletes the layer anbd the markers in it.
         *
         * \@memberof GoogleLayer
         * @return {?}
         */
        GoogleLayer.prototype.Delete = /**
         * Deletes the layer anbd the markers in it.
         *
         * \@memberof GoogleLayer
         * @return {?}
         */
            function () {
                async.eachSeries(this._entities.splice(0), function (e, next) {
                    e.NativePrimitve.setMap(null);
                    async.nextTick(function () { return next(); });
                });
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} ILayerOptions. The layer options.
         *
         */
        GoogleLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} ILayerOptions. The layer options.
         *
         */
            function () {
                /** @type {?} */
                var options = {
                    id: this._id
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        GoogleLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._visible;
            };
        /**
         * Removes an entity from the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.RemoveEntity = /**
         * Removes an entity from the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    /** @type {?} */
                    var j = this._entities.indexOf(entity);
                    if (j > -1) {
                        this._entities.splice(j, 1);
                    }
                    entity.NativePrimitve.setMap(null);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                this.Delete();
                this.AddEntities(entities);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                this._id = options.id;
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                async.eachSeries(__spread(this._entities), function (e, next) {
                    e.NativePrimitve.setVisible(visible);
                    async.nextTick(function () { return next(); });
                });
                this._visible = visible;
            };
        return GoogleLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements the {\@link LayerService} contract for a Google Maps specific implementation.
     *
     * @export
     */
    var GoogleLayerService = (function (_super) {
        __extends(GoogleLayerService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleLayerService.
         * @param _mapService - Instance of the Google Maps Service. Will generally be injected.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof GoogleLayerService
         */
        function GoogleLayerService(_mapService, _zone) {
            var _this = _super.call(this, _mapService, _zone) || this;
            _this._layers = new Map();
            return _this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        GoogleLayerService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                /** @type {?} */
                var p = new Promise(function (resolve, reject) {
                    _this._mapService.MapPromise.then(function (m) {
                        /** @type {?} */
                        var l = new GoogleLayer(m, _this._mapService, layer.Id);
                        l.SetVisible(layer.Visible);
                        resolve(l);
                    });
                });
                this._layers.set(layer.Id, p);
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        GoogleLayerService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                /** @type {?} */
                var p = this._mapService.CreatePolygon(options);
                /** @type {?} */
                var l = this._layers.get(layer);
                Promise.all([p, l]).then(function (x) { return x[1].AddEntity(x[0]); });
                return p;
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        GoogleLayerService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    /** @type {?} */
                    var polygons = new Promise(function (resolve, reject) {
                        /** @type {?} */
                        var polys = options.map(function (o) {
                            /** @type {?} */
                            var op = GoogleConversions.TranslatePolygonOptions(o);
                            /** @type {?} */
                            var poly = new google.maps.Polygon(op);
                            /** @type {?} */
                            var polygon = new GooglePolygon(poly);
                            if (o.title && o.title !== '') {
                                polygon.Title = o.title;
                            }
                            if (o.metadata) {
                                o.metadata.forEach(function (val, key) { return polygon.Metadata.set(key, val); });
                            }
                            return polygon;
                        });
                        resolve(polys);
                    });
                    return polygons;
                });
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polyline.
         * @param {?} options - Polyline options defining the polyline.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        GoogleLayerService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polyline.
         * @param {?} options - Polyline options defining the polyline.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                /** @type {?} */
                var p = this._mapService.CreatePolyline(options);
                /** @type {?} */
                var l = this._layers.get(layer);
                Promise.all([p, l]).then(function (x) {
                    /** @type {?} */
                    var p1 = Array.isArray(x[0]) ? /** @type {?} */ (x[0]) : [/** @type {?} */ (x[0])];
                    try {
                        for (var p1_1 = __values(p1), p1_1_1 = p1_1.next(); !p1_1_1.done; p1_1_1 = p1_1.next()) {
                            var p2 = p1_1_1.value;
                            x[1].AddEntity(p2);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (p1_1_1 && !p1_1_1.done && (_a = p1_1.return))
                                _a.call(p1_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    var e_1, _a;
                });
                return p;
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        GoogleLayerService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                /** @type {?} */
                var p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    /** @type {?} */
                    var polylines = new Promise(function (resolve, reject) {
                        /** @type {?} */
                        var polys = options.map(function (o) {
                            /** @type {?} */
                            var op = GoogleConversions.TranslatePolylineOptions(o);
                            if (o.path && o.path.length > 0 && !Array.isArray(o.path[0])) {
                                op.path = GoogleConversions.TranslatePaths(o.path)[0];
                                /** @type {?} */
                                var poly = new google.maps.Polyline(op);
                                /** @type {?} */
                                var polyline_1 = new GooglePolyline(poly);
                                if (o.title && o.title !== '') {
                                    polyline_1.Title = o.title;
                                }
                                if (o.metadata) {
                                    o.metadata.forEach(function (v, k) { return polyline_1.Metadata.set(k, v); });
                                }
                                return polyline_1;
                            }
                            else {
                                /** @type {?} */
                                var paths = GoogleConversions.TranslatePaths(o.path);
                                /** @type {?} */
                                var lines_1 = new Array();
                                paths.forEach(function (x) {
                                    op.path = x;
                                    /** @type {?} */
                                    var poly = new google.maps.Polyline(op);
                                    /** @type {?} */
                                    var polyline = new GooglePolyline(poly);
                                    if (o.metadata) {
                                        o.metadata.forEach(function (v, k) { return polyline.Metadata.set(k, v); });
                                    }
                                    if (o.title && o.title !== '') {
                                        polyline.Title = o.title;
                                    }
                                    lines_1.push(polyline);
                                });
                                return lines_1;
                            }
                        });
                        resolve(polys);
                    });
                    return polylines;
                });
            };
        GoogleLayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleLayerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return GoogleLayerService;
    }(GoogleLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var ScriptProtocol$1 = {
        HTTP: 0,
        HTTPS: 1,
        AUTO: 2,
    };
    ScriptProtocol$1[ScriptProtocol$1.HTTP] = 'HTTP';
    ScriptProtocol$1[ScriptProtocol$1.HTTPS] = 'HTTPS';
    ScriptProtocol$1[ScriptProtocol$1.AUTO] = 'AUTO';
    /**
     * Bing Maps V8 specific loader configuration to be used with the {\@link GoogleMapAPILoader}
     *
     * @export
     */
    var GoogleMapAPILoaderConfig = (function () {
        function GoogleMapAPILoaderConfig() {
        }
        GoogleMapAPILoaderConfig.decorators = [
            { type: core.Injectable },
        ];
        return GoogleMapAPILoaderConfig;
    }());
    /** *
     * Default loader configuration.
      @type {?} */
    var DEFAULT_CONFIGURATION$1 = new GoogleMapAPILoaderConfig();
    /**
     * Bing Maps V8 implementation for the {\@link MapAPILoader} service.
     *
     * @export
     */
    var GoogleMapAPILoader = (function (_super) {
        __extends(GoogleMapAPILoader, _super);
        /**
         * Creates an instance of GoogleMapAPILoader.
         * @param _config - The loader configuration.
         * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
         * @param _documentRef - An instance of {@link DocumentRef}.
         *                                     Necessary because Bing Map V8 interacts with the document object.
         * @memberof GoogleMapAPILoader
         */
        function GoogleMapAPILoader(_config, _windowRef, _documentRef) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            _this._windowRef = _windowRef;
            _this._documentRef = _documentRef;
            if (_this._config === null || _this._config === undefined) {
                _this._config = DEFAULT_CONFIGURATION$1;
            }
            return _this;
        }
        Object.defineProperty(GoogleMapAPILoader.prototype, "Config", {
            get: /**
             * Gets the loader configuration.
             *
             * \@readonly
             * \@memberof GoogleMapAPILoader
             * @return {?}
             */ function () { return this._config; },
            enumerable: true,
            configurable: true
        });
        /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?}
         */
        GoogleMapAPILoader.prototype.Load = /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._scriptLoadingPromise) {
                    return this._scriptLoadingPromise;
                }
                /** @type {?} */
                var script = this._documentRef.GetNativeDocument().createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.defer = true;
                /** @type {?} */
                var callbackName = "Create";
                script.src = this.GetMapsScriptSrc(callbackName);
                this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                    ((_this._windowRef.GetNativeWindow()))[callbackName] = function () {
                        if (_this._config.enableClustering) {
                            /** @type {?} */
                            var clusterScript = _this._documentRef.GetNativeDocument().createElement('script');
                            clusterScript.type = 'text/javascript';
                            clusterScript.src = _this.GetClusterScriptSrc();
                            clusterScript.onload = clusterScript.onreadystatechange = function () {
                                resolve();
                            };
                            _this._documentRef.GetNativeDocument().head.appendChild(clusterScript);
                        }
                        else {
                            resolve();
                        }
                    };
                    script.onerror = function (error) { reject(error); };
                });
                this._documentRef.GetNativeDocument().head.appendChild(script);
                return this._scriptLoadingPromise;
            };
        /**
         * Gets the Google Maps scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
         * @return {?} - The url to be used to load the Google Map scripts.
         *
         */
        GoogleMapAPILoader.prototype.GetMapsScriptSrc = /**
         * Gets the Google Maps scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
         * @return {?} - The url to be used to load the Google Map scripts.
         *
         */
            function (callbackName) {
                /** @type {?} */
                var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
                /** @type {?} */
                var queryParams = {
                    v: this._config.apiVersion,
                    callback: callbackName,
                    key: this._config.apiKey,
                    client: this._config.clientId,
                    channel: this._config.channel,
                    libraries: this._config.libraries,
                    region: this._config.region,
                    language: this._config.language
                };
                return this.GetScriptSrc(hostAndPath, queryParams);
            };
        /**
         * Gets the Google Maps Cluster library url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?} - The url to be used to load the Google Map Cluster library.
         *
         */
        GoogleMapAPILoader.prototype.GetClusterScriptSrc = /**
         * Gets the Google Maps Cluster library url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?} - The url to be used to load the Google Map Cluster library.
         *
         */
            function () {
                /** @type {?} */
                var hostAndPath = this._config.clusterHostAndPath ||
                    'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';
                return this.GetScriptSrc(hostAndPath, {});
            };
        /**
         * Gets a scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} hostAndPath - Host and path name of the script to load.
         * @param {?} queryParams - Url query parameters.
         * @return {?} - The url with correct protocol, path, and query parameters.
         *
         */
        GoogleMapAPILoader.prototype.GetScriptSrc = /**
         * Gets a scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} hostAndPath - Host and path name of the script to load.
         * @param {?} queryParams - Url query parameters.
         * @return {?} - The url with correct protocol, path, and query parameters.
         *
         */
            function (hostAndPath, queryParams) {
                /** @type {?} */
                var protocolType = (((this._config && this._config.protocol) || ScriptProtocol$1.HTTPS));
                /** @type {?} */
                var protocol;
                switch (protocolType) {
                    case ScriptProtocol$1.AUTO:
                        protocol = '';
                        break;
                    case ScriptProtocol$1.HTTP:
                        protocol = 'http:';
                        break;
                    case ScriptProtocol$1.HTTPS:
                        protocol = 'https:';
                        break;
                }
                /** @type {?} */
                var params = Object.keys(queryParams)
                    .filter(function (k) { return queryParams[k] != null; })
                    .filter(function (k) {
                    // remove empty arrays
                    return !Array.isArray(queryParams[k]) ||
                        (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
                })
                    .map(function (k) {
                    /** @type {?} */
                    var i = queryParams[k];
                    if (Array.isArray(i)) {
                        return { key: k, value: i.join(',') };
                    }
                    return { key: k, value: queryParams[k] };
                })
                    .map(function (entry) { return entry.key + "=" + entry.value; })
                    .join('&');
                return protocol + "//" + hostAndPath + "?" + params;
            };
        GoogleMapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapAPILoader.ctorParameters = function () {
            return [
                { type: GoogleMapAPILoaderConfig, decorators: [{ type: core.Optional }] },
                { type: WindowRef },
                { type: DocumentRef }
            ];
        };
        return GoogleMapAPILoader;
    }(MapAPILoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the MarkerService abstract class for Google.
     *
     * @export
     */
    var GoogleMarkerService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMarkerService.
         * @param _mapService - {@link MapService} instance.
         * The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _clusterService - {@link ClusterService} instance.
         * The concrete {@link GoogleClusterService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GoogleMarkerService
         */
        function GoogleMarkerService(_mapService, _layerService, _clusterService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._zone = _zone;
            this._markers = new Map();
        }
        /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         * @return {?}
         */
        GoogleMarkerService.prototype.AddMarker = /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         * @return {?}
         */
            function (marker) {
                /** @type {?} */
                var o = {
                    anchor: marker.Anchor,
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    title: marker.Title,
                    label: marker.Label,
                    draggable: marker.Draggable,
                    icon: marker.IconUrl,
                    iconInfo: marker.IconInfo,
                    width: marker.Width,
                    height: marker.Height,
                    isFirst: marker.IsFirstInSet,
                    isLast: marker.IsLastInSet
                };
                /** @type {?} */
                var markerPromise = null;
                if (marker.InClusterLayer) {
                    markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
                }
                else if (marker.InCustomLayer) {
                    markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
                }
                else {
                    markerPromise = this._mapService.CreateMarker(o);
                }
                this._markers.set(marker, markerPromise);
                if (marker.IconInfo) {
                    markerPromise.then(function (m) {
                        // update iconInfo to provide hook to do post icon creation activities and
                        // also re-anchor the marker
                        marker.DynamicMarkerCreated.emit(o.iconInfo);
                        /** @type {?} */
                        var p = {
                            x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                            y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                        };
                        m.SetAnchor(p);
                    });
                }
            };
        /**
         * Registers an event delegate for a marker.
         *
         * \@memberof GoogleMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarkerDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         */
        GoogleMarkerService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a marker.
         *
         * \@memberof GoogleMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarkerDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         */
            function (eventName, marker) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._markers.get(marker).then(function (m) {
                        m.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - {\@link MapMarkerDirective} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         */
        GoogleMarkerService.prototype.DeleteMarker = /**
         * Deletes a marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - {\@link MapMarkerDirective} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         */
            function (marker) {
                var _this = this;
                /** @type {?} */
                var m = this._markers.get(marker);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (ma) {
                    if (marker.InClusterLayer) {
                        _this._clusterService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                    }
                    if (marker.InCustomLayer) {
                        _this._layerService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                    }
                    return _this._zone.run(function () {
                        ma.DeleteMarker();
                        _this._markers.delete(marker);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        GoogleMarkerService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         */
        GoogleMarkerService.prototype.GetNativeMarker = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         */
            function (marker) {
                return this._markers.get(marker);
            };
        /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         */
        GoogleMarkerService.prototype.GetPixelsFromClick = /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         */
            function (e) {
                if (!e || !e.latLng || !e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                if (this._mapService.MapInstance == null) {
                    return null;
                }
                /** @type {?} */
                var crossesDateLine = false;
                /** @type {?} */
                var m = this._mapService.MapInstance;
                /** @type {?} */
                var p = m.getProjection();
                /** @type {?} */
                var s = Math.pow(2, m.getZoom());
                /** @type {?} */
                var b = m.getBounds();
                if (b.getCenter().lng() < b.getSouthWest().lng() ||
                    b.getCenter().lng() > b.getNorthEast().lng()) {
                    crossesDateLine = true;
                }
                /** @type {?} */
                var offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                /** @type {?} */
                var offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                /** @type {?} */
                var point = p.fromLatLngToPoint(e.latLng);
                return {
                    x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                    y: Math.floor((point.y - offsetY) * s)
                };
            };
        /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof GoogleMarkerService
         * @param {?} target - Either a {\@link MapMarkerDirective}
         * or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         */
        GoogleMarkerService.prototype.LocationToPoint = /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof GoogleMarkerService
         * @param {?} target - Either a {\@link MapMarkerDirective}
         * or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         */
            function (target) {
                var _this = this;
                if (target == null) {
                    return Promise.resolve(null);
                }
                if (target instanceof MapMarkerDirective) {
                    return this._markers.get(target).then(function (m) {
                        /** @type {?} */
                        var l = m.Location;
                        /** @type {?} */
                        var p = _this._mapService.LocationToPoint(l);
                        return p;
                    });
                }
                return this._mapService.LocationToPoint(target);
            };
        /**
         * Updates the anchor position for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         */
        GoogleMarkerService.prototype.UpdateAnchor = /**
         * Updates the anchor position for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    m.SetAnchor(marker.Anchor);
                });
            };
        /**
         * Updates whether the marker is draggable.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         */
        GoogleMarkerService.prototype.UpdateDraggable = /**
         * Updates whether the marker is draggable.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
            };
        /**
         * Updates the Icon on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         */
        GoogleMarkerService.prototype.UpdateIcon = /**
         * Updates the Icon on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    if (marker.IconInfo) {
                        /** @type {?} */
                        var x = {
                            position: { latitude: marker.Latitude, longitude: marker.Longitude },
                            iconInfo: marker.IconInfo
                        };
                        /** @type {?} */
                        var o = GoogleConversions.TranslateMarkerOptions(x);
                        m.SetIcon(o.icon);
                        marker.DynamicMarkerCreated.emit(x.iconInfo);
                    }
                    else {
                        m.SetIcon(marker.IconUrl);
                    }
                });
            };
        /**
         * Updates the label on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         */
        GoogleMarkerService.prototype.UpdateLabel = /**
         * Updates the label on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
            };
        /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         */
        GoogleMarkerService.prototype.UpdateMarkerPosition = /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    return m.SetPosition({
                        latitude: marker.Latitude,
                        longitude: marker.Longitude
                    });
                });
            };
        /**
         * Updates the title on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
        GoogleMarkerService.prototype.UpdateTitle = /**
         * Updates the title on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
            };
        /**
         * Updates the visibility on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
        GoogleMarkerService.prototype.UpdateVisible = /**
         * Updates the visibility on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
            };
        GoogleMarkerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMarkerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: ClusterService },
                { type: core.NgZone }
            ];
        };
        return GoogleMarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of a clustering layer for the Google Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a clustering layer for the Google Map Provider.
     *
     * @export
     */ GoogleMarkerClusterer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the GoogleMarkerClusterer class.
         *
         * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof GoogleMarkerClusterer
         */
        function GoogleMarkerClusterer(_layer) {
            this._layer = _layer;
            this._isClustering = true;
            this._markerLookup = new Map();
            this._markers = new Array();
            this._pendingMarkers = new Array();
            this._mapclicks = 0;
            this._currentZoom = 0;
            this._visible = true;
        }
        Object.defineProperty(GoogleMarkerClusterer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof GoogleMarkerClusterer
             * @return {?} GoogleMapTypes.MarkerClusterer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                /** @type {?} */
                var isMarker = entity instanceof Marker;
                isMarker = entity instanceof GoogleMarker || isMarker;
                if (isMarker) {
                    entity.NativePrimitve.setMap(null);
                    // remove the marker from the map as the clusterer will control marker visibility.
                    if (entity.IsFirst) {
                        this.StopClustering();
                    }
                }
                if (entity.NativePrimitve && entity.Location) {
                    if (this._isClustering && this._visible) {
                        this._layer.addMarker(entity.NativePrimitve);
                        this._markers.push(entity);
                    }
                    else {
                        this._pendingMarkers.push(entity);
                    }
                    this._markerLookup.set(entity.NativePrimitve, entity);
                }
                if (isMarker) {
                    if (entity.IsLast) {
                        this.StartClustering();
                    }
                }
            };
        /**
         * Adds a number of markers to the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddEntities = /**
         * Adds a number of markers to the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    /** @type {?} */
                    var e = entities.map(function (p) {
                        _this._markerLookup.set(p.NativePrimitve, p);
                        p.NativePrimitve.setMap(null);
                        // remove the marker from the map as the clusterer will control marker visibility.
                        return p.NativePrimitve;
                    });
                    if (this._isClustering && this._visible) {
                        this._layer.addMarkers(e);
                        (_a = this._markers).push.apply(_a, __spread(entities));
                    }
                    else {
                        // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later
                        // will render the markers appropriately
                        // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later
                        // will render the markers appropriately
                        (_b = this._pendingMarkers).push.apply(_b, __spread(entities));
                    }
                }
                var _a, _b;
            };
        /**
         * Deletes the clustering layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.Delete = /**
         * Deletes the clustering layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
            function () {
                this._layer.getMarkers().forEach(function (m) {
                    m.setMap(null);
                    // remove the marker from the map as the clusterer will control marker visibility.
                });
                this._layer.clearMarkers();
                this._markers.splice(0);
                this._pendingMarkers.splice(0);
            };
        /**
         * Returns the abstract marker used to wrap the Google Marker.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
        GoogleMarkerClusterer.prototype.GetMarkerFromGoogleMarker = /**
         * Returns the abstract marker used to wrap the Google Marker.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                /** @type {?} */
                var m = this._markerLookup.get(pin);
                return m;
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        GoogleMarkerClusterer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                /** @type {?} */
                var options = {
                    id: 0,
                    gridSize: this._layer.getGridSize(),
                    clusteringEnabled: this._layer.getGridSize() === 0,
                    maxZoom: this._layer.getMaxZoom(),
                    minimumClusterSize: this._layer.getMinClusterSize(),
                    placementMode: this._layer.isAverageCenter() ? ClusterPlacementMode.MeanValue : ClusterPlacementMode.FirstPin,
                    visible: this._visible,
                    zoomOnClick: this._layer.isZoomOnClick(),
                    styles: this._layer.getStyles()
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        GoogleMarkerClusterer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._visible;
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker Entity to be removed from the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve && entity.Location) {
                    /** @type {?} */
                    var j = this._markers.indexOf(entity);
                    /** @type {?} */
                    var k = this._pendingMarkers.indexOf(entity);
                    if (j > -1) {
                        this._markers.splice(j, 1);
                    }
                    if (k > -1) {
                        this._pendingMarkers.splice(k, 1);
                    }
                    if (this._isClustering) {
                        this._layer.removeMarker(entity.NativePrimitve);
                    }
                    this._markerLookup.delete(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                this._layer.getMarkers().forEach(function (m) {
                    m.setMap(null);
                });
                this._layer.clearMarkers();
                this._markers.splice(0);
                this._pendingMarkers.splice(0);
                this._markerLookup.clear();
                /** @type {?} */
                var p = new Array();
                entities.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        e.NativePrimitve.setMap(null);
                        _this._markerLookup.set(e.NativePrimitve, e);
                        if (_this._visible) {
                            _this._markers.push(e);
                            p.push(e.NativePrimitve);
                        }
                        else {
                            _this._pendingMarkers.push(e);
                        }
                    }
                });
                this._layer.addMarkers(p);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                if (options.placementMode != null) {
                    throw (new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));
                }
                if (options.zoomOnClick != null) {
                    throw (new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));
                }
                if (options.callback != null) ;
                if (options.clusteringEnabled != null) {
                    this._layer.setMinClusterSize(options.clusteringEnabled ? 1 : 10000000);
                    this._layer.resetViewport();
                    this._layer.redraw();
                }
                if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {
                    this._layer.setGridSize(options.gridSize);
                    this._layer.resetViewport();
                    this._layer.redraw();
                }
                if (options.maxZoom != null) {
                    this._layer.setMaxZoom(options.maxZoom);
                }
                if (options.minimumClusterSize != null) {
                    this._layer.setMinClusterSize(options.minimumClusterSize);
                }
                if (options.styles != null) {
                    this._layer.setStyles(options.styles);
                }
                if (options.visible != null) {
                    this.SetVisible(options.visible);
                }
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                /** @type {?} */
                var map = visible ? this._layer.getMap() : null;
                if (!visible) {
                    this._layer.resetViewport(true);
                }
                else {
                    /** @type {?} */
                    var p_1 = new Array();
                    if (this._pendingMarkers.length > 0) {
                        this._pendingMarkers.forEach(function (e) {
                            if (e.NativePrimitve && e.Location) {
                                p_1.push(/** @type {?} */ (e.NativePrimitve));
                            }
                        });
                        this._layer.addMarkers(p_1);
                        this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                    }
                    else {
                        this._layer.redraw();
                    }
                }
                this._visible = visible;
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._isClustering) {
                    return;
                }
                if (this._visible) {
                    /** @type {?} */
                    var p_2 = new Array();
                    this._markers.forEach(function (e) {
                        if (e.NativePrimitve && e.Location) {
                            p_2.push(/** @type {?} */ (e.NativePrimitve));
                        }
                    });
                    this._pendingMarkers.forEach(function (e) {
                        if (e.NativePrimitve && e.Location) {
                            p_2.push(/** @type {?} */ (e.NativePrimitve));
                        }
                    });
                    this._layer.addMarkers(p_2);
                    this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                }
                if (!this._visible) {
                    // only add the markers if the layer is visible. Otherwise, keep them pending. They would be added once the
                    // layer is set to visible.
                    rxjs.timer(0).subscribe(function () {
                        _this._layer.resetViewport(true);
                    });
                }
                this._isClustering = true;
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         *
         */
        GoogleMarkerClusterer.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         *
         */
            function () {
                if (!this._isClustering) {
                    return;
                }
                this._isClustering = false;
            };
        return GoogleMarkerClusterer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the MapService abstract implementing a Google Maps provider
     *
     * @export
     */
    var GoogleMapService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMapService.
         * @param _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.
         * @param _zone NgZone object to enable zone aware promises. This will generally be injected.
         *
         * @memberof GoogleMapService
         */
        function GoogleMapService(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
            this._config = ((this._loader)).Config;
        }
        Object.defineProperty(GoogleMapService.prototype, "MapInstance", {
            get: /**
             * Gets the Google Map control instance underlying the implementation
             *
             * \@readonly
             * \@memberof GoogleMapService
             * @return {?}
             */ function () { return this._mapInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMapService.prototype, "MapPromise", {
            get: /**
             * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {\@link MapInstance} if you
             * are not sure if and when the instance will be created.
             * \@readonly
             * \@memberof GoogleMapService
             * @return {?}
             */ function () { return this._map; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMapService.prototype, "MapSize", {
            get: /**
             * Gets the maps physical size.
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapService
             * @return {?}
             */ function () {
                if (this.MapInstance) {
                    /** @type {?} */
                    var el = this.MapInstance.getDiv();
                    /** @type {?} */
                    var s = { width: el.offsetWidth, height: el.offsetHeight };
                    return s;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof GoogleMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
        GoogleMapService.prototype.CreateCanvasOverlay = /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof GoogleMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
            function (drawCallback) {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var overlay = new GoogleCanvasOverlay(drawCallback);
                    overlay.SetMap(map);
                    return overlay;
                });
            };
        /**
         * @param {?} options
         * @return {?}
         */
        GoogleMapService.prototype.CreateClusterLayer = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var updateOptions = false;
                    /** @type {?} */
                    var markerClusterer = new MarkerClusterer(map, [], options);
                    /** @type {?} */
                    var clusterLayer = new GoogleMarkerClusterer(markerClusterer);
                    /** @type {?} */
                    var o = {
                        id: options.id
                    };
                    if (!options.visible) {
                        o.visible = false;
                        updateOptions = true;
                    }
                    if (!options.clusteringEnabled) {
                        o.clusteringEnabled = false;
                        updateOptions = true;
                    }
                    if (updateOptions) {
                        clusterLayer.SetOptions(o);
                    }
                    return clusterLayer;
                });
            };
        /**
         * Creates an information window for a map position
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
        GoogleMapService.prototype.CreateInfoWindow = /**
         * Creates an information window for a map position
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    /** @type {?} */
                    var o = GoogleConversions.TranslateInfoWindowOptions(options);
                    /** @type {?} */
                    var infoWindow = new google.maps.InfoWindow(o);
                    return new GoogleInfoWindow(infoWindow, _this);
                });
            };
        /**
         * Creates a map layer within the map context
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
        GoogleMapService.prototype.CreateLayer = /**
         * Creates a map layer within the map context
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    return new GoogleLayer(map, _this, options.id);
                });
            };
        /**
         * Creates a map instance
         *
         * \@memberof GoogleMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
        GoogleMapService.prototype.CreateMap = /**
         * Creates a map instance
         *
         * \@memberof GoogleMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
            function (el, mapOptions) {
                var _this = this;
                return this._loader.Load().then(function () {
                    // apply mixins
                    MixinMapLabelWithOverlayView$1();
                    MixinCanvasOverlay$1();
                    // execute map startup
                    if (!mapOptions.mapTypeId == null) {
                        mapOptions.mapTypeId = MapTypeId.hybrid;
                    }
                    if (_this._mapInstance != null) {
                        _this.DisposeMap();
                    }
                    /** @type {?} */
                    var o = GoogleConversions.TranslateOptions(mapOptions);
                    /** @type {?} */
                    var map = new google.maps.Map(el, o);
                    if (mapOptions.bounds) {
                        map.fitBounds(GoogleConversions.TranslateBounds(mapOptions.bounds));
                    }
                    _this._mapInstance = map;
                    _this._mapResolver(map);
                    return;
                });
            };
        /**
         * Creates a Google map marker within the map context
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
        GoogleMapService.prototype.CreateMarker = /**
         * Creates a Google map marker within the map context
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
            function (options) {
                if (options === void 0) {
                    options = /** @type {?} */ ({});
                }
                /** @type {?} */
                var payload = function (x, map) {
                    /** @type {?} */
                    var marker = new google.maps.Marker(x);
                    /** @type {?} */
                    var m = new GoogleMarker(marker);
                    m.IsFirst = options.isFirst;
                    m.IsLast = options.isLast;
                    if (options.metadata) {
                        options.metadata.forEach(function (val, key) { return m.Metadata.set(key, val); });
                    }
                    marker.setMap(map);
                    return m;
                };
                return this._map.then(function (map) {
                    /** @type {?} */
                    var o = GoogleConversions.TranslateMarkerOptions(options);
                    if (options.iconInfo && options.iconInfo.markerType) {
                        /** @type {?} */
                        var s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            o.icon = s;
                            return payload(o, map);
                        }
                        else {
                            return s.then(function (x) {
                                o.icon = x.icon;
                                return payload(o, map);
                            });
                        }
                    }
                    else {
                        return payload(o, map);
                    }
                });
            };
        /**
         * Creates a polygon within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
        GoogleMapService.prototype.CreatePolygon = /**
         * Creates a polygon within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
            function (options) {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var o = GoogleConversions.TranslatePolygonOptions(options);
                    /** @type {?} */
                    var polygon = new google.maps.Polygon(o);
                    polygon.setMap(map);
                    /** @type {?} */
                    var p = new GooglePolygon(polygon);
                    if (options.metadata) {
                        options.metadata.forEach(function (val, key) { return p.Metadata.set(key, val); });
                    }
                    if (options.title && options.title !== '') {
                        p.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        p.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        p.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        p.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        p.LabelMinZoom = options.labelMinZoom;
                    }
                    return p;
                });
            };
        /**
         * Creates a polyline within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array therefore for complex paths)
         * which models the underlying native polyline.
         *
         */
        GoogleMapService.prototype.CreatePolyline = /**
         * Creates a polyline within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array therefore for complex paths)
         * which models the underlying native polyline.
         *
         */
            function (options) {
                /** @type {?} */
                var polyline;
                return this._map.then(function (map) {
                    /** @type {?} */
                    var o = GoogleConversions.TranslatePolylineOptions(options);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        o.path = GoogleConversions.TranslatePaths(options.path)[0];
                        polyline = new google.maps.Polyline(o);
                        polyline.setMap(map);
                        /** @type {?} */
                        var pl_1 = new GooglePolyline(polyline);
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return pl_1.Metadata.set(key, val); });
                        }
                        if (options.title && options.title !== '') {
                            pl_1.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            pl_1.ShowTooltip = options.showTooltip;
                        }
                        return pl_1;
                    }
                    else {
                        /** @type {?} */
                        var paths = GoogleConversions.TranslatePaths(options.path);
                        /** @type {?} */
                        var lines_1 = new Array();
                        paths.forEach(function (p) {
                            o.path = p;
                            polyline = new google.maps.Polyline(o);
                            polyline.setMap(map);
                            /** @type {?} */
                            var pl = new GooglePolyline(polyline);
                            if (options.metadata) {
                                options.metadata.forEach(function (val, key) { return pl.Metadata.set(key, val); });
                            }
                            if (options.title && options.title !== '') {
                                pl.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                pl.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(pl);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Deletes a layer from the map.
         *
         * \@memberof GoogleMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Google specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
        GoogleMapService.prototype.DeleteLayer = /**
         * Deletes a layer from the map.
         *
         * \@memberof GoogleMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Google specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                // return resolved promise as there is no conept of a custom layer in Google.
                return Promise.resolve();
            };
        /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof GoogleMapService
         * @return {?}
         */
        GoogleMapService.prototype.DisposeMap = /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof GoogleMapService
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._map == null && this._mapInstance == null) {
                    return;
                }
                if (this._mapInstance != null) {
                    this._mapInstance = null;
                    this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
                }
            };
        /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
        GoogleMapService.prototype.GetCenter = /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var center = map.getCenter();
                    return /** @type {?} */ ({
                        latitude: center.lat(),
                        longitude: center.lng()
                    });
                });
            };
        /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the geo location of the bounding box. See {\@link IBox}.
         *
         */
        GoogleMapService.prototype.GetBounds = /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the geo location of the bounding box. See {\@link IBox}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var box = map.getBounds();
                    return /** @type {?} */ ({
                        maxLatitude: box.getNorthEast().lat(),
                        maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),
                        minLatitude: box.getSouthWest().lat(),
                        minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),
                        center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },
                        padding: 0
                    });
                });
            };
        /**
         * Gets the current zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
        GoogleMapService.prototype.GetZoom = /**
         * Gets the current zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
            function () {
                return this._map.then(function (map) { return map.getZoom(); });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof GoogleMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
        GoogleMapService.prototype.LocationToPoint = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof GoogleMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
            function (loc) {
                return this._map.then(function (m) {
                    /** @type {?} */
                    var crossesDateLine = false;
                    /** @type {?} */
                    var l = GoogleConversions.TranslateLocationObject(loc);
                    /** @type {?} */
                    var p = m.getProjection();
                    /** @type {?} */
                    var s = Math.pow(2, m.getZoom());
                    /** @type {?} */
                    var b = m.getBounds();
                    if (b.getCenter().lng() < b.getSouthWest().lng() ||
                        b.getCenter().lng() > b.getNorthEast().lng()) {
                        crossesDateLine = true;
                    }
                    /** @type {?} */
                    var offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                    /** @type {?} */
                    var offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                    /** @type {?} */
                    var point = p.fromLatLngToPoint(l);
                    return {
                        x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                        y: Math.floor((point.y - offsetY) * s)
                    };
                });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
        GoogleMapService.prototype.LocationsToPoints = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
            function (locs) {
                return this._map.then(function (m) {
                    /** @type {?} */
                    var crossesDateLine = false;
                    /** @type {?} */
                    var p = m.getProjection();
                    /** @type {?} */
                    var s = Math.pow(2, m.getZoom());
                    /** @type {?} */
                    var b = m.getBounds();
                    if (b.getCenter().lng() < b.getSouthWest().lng() ||
                        b.getCenter().lng() > b.getNorthEast().lng()) {
                        crossesDateLine = true;
                    }
                    /** @type {?} */
                    var offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                    /** @type {?} */
                    var offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                    /** @type {?} */
                    var l = locs.map(function (ll) {
                        /** @type {?} */
                        var l1 = GoogleConversions.TranslateLocationObject(ll);
                        /** @type {?} */
                        var point = p.fromLatLngToPoint(l1);
                        return {
                            x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                            y: Math.floor((point.y - offsetY) * s)
                        };
                    });
                    return l;
                });
            };
        /**
         * Centers the map on a geo location.
         *
         * \@memberof GoogleMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
        GoogleMapService.prototype.SetCenter = /**
         * Centers the map on a geo location.
         *
         * \@memberof GoogleMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
            function (latLng) {
                return this._map.then(function (map) {
                    /** @type {?} */
                    var center = GoogleConversions.TranslateLocationObject(latLng);
                    map.setCenter(center);
                });
            };
        /**
         * Sets the generic map options.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        GoogleMapService.prototype.SetMapOptions = /**
         * Sets the generic map options.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    /** @type {?} */
                    var o = GoogleConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the view options of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        GoogleMapService.prototype.SetViewOptions = /**
         * Sets the view options of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    if (options.bounds) {
                        m.fitBounds(GoogleConversions.TranslateBounds(options.bounds));
                    }
                    /** @type {?} */
                    var o = GoogleConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
        GoogleMapService.prototype.SetZoom = /**
         * Sets the zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
            function (zoom) {
                return this._map.then(function (map) { return map.setZoom(zoom); });
            };
        /**
         * Creates an event subscription
         *
         * \@memberof GoogleMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of type E that fires when the event occurs.
         *
         */
        GoogleMapService.prototype.SubscribeToMapEvent = /**
         * Creates an event subscription
         *
         * \@memberof GoogleMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of type E that fires when the event occurs.
         *
         */
            function (eventName) {
                var _this = this;
                /** @type {?} */
                var googleEventName = GoogleMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._map.then(function (m) {
                        m.addListener(googleEventName, function (e) {
                            _this._zone.run(function () { return observer.next(e); });
                        });
                    });
                });
            };
        /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof GoogleMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
        GoogleMapService.prototype.TriggerMapEvent = /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof GoogleMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
            function (eventName) {
                return this._map.then(function (m) { return google.maps.event.trigger(m, eventName, null); });
            };
        GoogleMapService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapService.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return GoogleMapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the Polygon Service abstract class for Google Maps.
     *
     * @export
     */
    var GooglePolygonService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GooglePolygonService.
         * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link GoogleLayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GooglePolygonService
         */
        function GooglePolygonService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polygons = new Map();
        }
        /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
        GooglePolygonService.prototype.AddPolygon = /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
            function (polygon) {
                /** @type {?} */
                var o = {
                    id: polygon.Id,
                    clickable: polygon.Clickable,
                    draggable: polygon.Draggable,
                    editable: polygon.Editable,
                    fillColor: polygon.FillColor,
                    fillOpacity: polygon.FillOpacity,
                    geodesic: polygon.Geodesic,
                    labelMaxZoom: polygon.LabelMaxZoom,
                    labelMinZoom: polygon.LabelMinZoom,
                    paths: polygon.Paths,
                    showLabel: polygon.ShowLabel,
                    showTooltip: polygon.ShowTooltip,
                    strokeColor: polygon.StrokeColor,
                    strokeOpacity: polygon.StrokeOpacity,
                    strokeWeight: polygon.StrokeWeight,
                    title: polygon.Title,
                    visible: polygon.Visible,
                    zIndex: polygon.zIndex,
                };
                /** @type {?} */
                var polygonPromise = this._mapService.CreatePolygon(o);
                this._polygons.set(polygon, polygonPromise);
            };
        /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof GooglePolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GooglePolygonService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof GooglePolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polygon) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._polygons.get(polygon).then(function (p) {
                        p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a polygon.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
        GooglePolygonService.prototype.DeletePolygon = /**
         * Deletes a polygon.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
            function (polygon) {
                var _this = this;
                /** @type {?} */
                var m = this._polygons.get(polygon);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        l.Delete();
                        _this._polygons.delete(polygon);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof GooglePolygonService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        GooglePolygonService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof GooglePolygonService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
        GooglePolygonService.prototype.GetNativePolygon = /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
            function (polygon) {
                return this._polygons.get(polygon);
            };
        /**
         * Set the polygon options.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
        GooglePolygonService.prototype.SetOptions = /**
         * Set the polygon options.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
            function (polygon, options) {
                return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
            };
        /**
         * Updates the Polygon path
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
        GooglePolygonService.prototype.UpdatePolygon = /**
         * Updates the Polygon path
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
            function (polygon) {
                /** @type {?} */
                var m = this._polygons.get(polygon);
                if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    if (Array.isArray(polygon.Paths[0])) {
                        l.SetPaths(polygon.Paths);
                    }
                    else {
                        l.SetPath(/** @type {?} */ (polygon.Paths));
                    }
                });
            };
        GooglePolygonService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GooglePolygonService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return GooglePolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation of the Polyline Service abstract class for Google Maps.
     *
     * @export
     */
    var GooglePolylineService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GooglePolylineService.
         * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GooglePolylineService
         */
        function GooglePolylineService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polylines = new Map();
        }
        /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
        GooglePolylineService.prototype.AddPolyline = /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
            function (polyline) {
                /** @type {?} */
                var o = {
                    id: polyline.Id,
                    clickable: polyline.Clickable,
                    draggable: polyline.Draggable,
                    editable: polyline.Editable,
                    geodesic: polyline.Geodesic,
                    path: polyline.Path,
                    showTooltip: polyline.ShowTooltip,
                    strokeColor: polyline.StrokeColor,
                    strokeOpacity: polyline.StrokeOpacity,
                    strokeWeight: polyline.StrokeWeight,
                    title: polyline.Title,
                    visible: polyline.Visible,
                    zIndex: polyline.zIndex,
                };
                /** @type {?} */
                var polylinePromise = this._mapService.CreatePolyline(o);
                this._polylines.set(polyline, polylinePromise);
            };
        /**
         * Registers an event delegate for a line.
         *
         * \@memberof GooglePolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GooglePolylineService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a line.
         *
         * \@memberof GooglePolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polyline) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._polylines.get(polyline).then(function (p) {
                        /** @type {?} */
                        var x = Array.isArray(p) ? p : [p];
                        x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
                    });
                });
            };
        /**
         * Deletes a polyline.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
        GooglePolylineService.prototype.DeletePolyline = /**
         * Deletes a polyline.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
            function (polyline) {
                var _this = this;
                /** @type {?} */
                var m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        /** @type {?} */
                        var x = Array.isArray(l) ? l : [l];
                        x.forEach(function (line) { return line.Delete(); });
                        _this._polylines.delete(polyline);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the line on the click location
         *
         * @abstract
         * \@memberof GooglePolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked line.
         *
         */
        GooglePolylineService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the line on the click location
         *
         * @abstract
         * \@memberof GooglePolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked line.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the polyline model for the line allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
        GooglePolylineService.prototype.GetNativePolyline = /**
         * Obtains the polyline model for the line allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
            function (polyline) {
                return this._polylines.get(polyline);
            };
        /**
         * Set the polyline options.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
        GooglePolylineService.prototype.SetOptions = /**
         * Set the polyline options.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
            function (polyline, options) {
                return this._polylines.get(polyline).then(function (l) {
                    /** @type {?} */
                    var x = Array.isArray(l) ? l : [l];
                    x.forEach(function (line) { return line.SetOptions(options); });
                });
            };
        /**
         * Updates the Polyline path
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
        GooglePolylineService.prototype.UpdatePolyline = /**
         * Updates the Polyline path
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
            function (polyline) {
                var _this = this;
                /** @type {?} */
                var m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        /** @type {?} */
                        var x = Array.isArray(l) ? l : [l];
                        /** @type {?} */
                        var p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? /** @type {?} */ (polyline.Path) : /** @type {?} */ ([polyline.Path]);
                        x.forEach(function (line, index) {
                            if (p.length > index) {
                                line.SetPath(p[index]);
                            }
                        });
                        if (Array.isArray(l) && l.length > p.length) {
                            l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
                        }
                    });
                });
            };
        GooglePolylineService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GooglePolylineService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return GooglePolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Implements a factory to create three necessary Google Maps specific service instances.
     *
     * @export
     */
    var GoogleMapServiceFactory = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMapServiceFactory.
         * @param _loader - {@link MapAPILoader} implementation for the Google Map provider.
         * @param _zone - NgZone object to implement zone aware promises.
         *
         * @memberof GoogleMapServiceFactory
         */
        function GoogleMapServiceFactory(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map =
                new Promise(function (resolve) { _this._mapResolver = resolve; });
        }
        /**
         * Creates the map service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link GoogleMapService}.
         *
         */
        GoogleMapServiceFactory.prototype.Create = /**
         * Creates the map service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link GoogleMapService}.
         *
         */
            function () {
                return new GoogleMapService(this._loader, this._zone);
            };
        /**
         * Creates the cluster service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link GoogleClusterService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateClusterService = /**
         * Creates the cluster service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link GoogleClusterService}.
         *
         */
            function (_mapService) {
                return new GoogleClusterService(_mapService, this._zone);
            };
        /**
         * Creates thh info box service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _markerService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link GoogleInfoBoxService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateInfoBoxService = /**
         * Creates thh info box service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _markerService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link GoogleInfoBoxService}.
         *
         */
            function (_mapService, _markerService) {
                return new GoogleInfoBoxService(_mapService, _markerService, this._zone);
            };
        /**
         * Creates the layer service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link GoogleLayerService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateLayerService = /**
         * Creates the layer service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link GoogleLayerService}.
         *
         */
            function (_mapService) {
                return new GoogleLayerService(_mapService, this._zone);
            };
        /**
         * Creates the marker service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link GoogleMarkerService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateMarkerService = /**
         * Creates the marker service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link GoogleMarkerService}.
         *
         */
            function (_mapService, _layerService, _clusterService) {
                return new GoogleMarkerService(_mapService, _layerService, _clusterService, this._zone);
            };
        /**
         * Creates the polygon service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
        GoogleMapServiceFactory.prototype.CreatePolygonService = /**
         * Creates the polygon service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new GooglePolygonService(map, layers, this._zone);
            };
        /**
         * Creates the polyline service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
        GoogleMapServiceFactory.prototype.CreatePolylineService = /**
         * Creates the polyline service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new GooglePolylineService(map, layers, this._zone);
            };
        GoogleMapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapServiceFactory.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return GoogleMapServiceFactory;
    }());
    /**
     *  Creates a new instance of a plaform specific MapServiceFactory.
     *
     * @param {?} apiLoader - An {\@link MapAPILoader} instance. This is expected to the a {\@link GoogleMapAPILoader}.
     * @param {?} zone - An NgZone instance to provide zone aware promises.
     *
     * @return {?} - A {\@link MapServiceFactory} instance.
     */
    function GoogleMapServiceFactoryFactory(apiLoader, zone) {
        return new GoogleMapServiceFactory(apiLoader, zone);
    }
    /**
     * Creates a new instance of a plaform specific MapLoaderFactory.
     *
     * @export
     * @return {?} - A {\@link MapAPILoader} instance.
     */
    function GoogleMapLoaderFactory() {
        return new GoogleMapAPILoader(new GoogleMapAPILoaderConfig(), new WindowRef(), new DocumentRef());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MapModule = (function () {
        function MapModule() {
        }
        /**
         * @param {?=} mapServiceFactory
         * @param {?=} loader
         * @return {?}
         */
        MapModule.forRoot = /**
         * @param {?=} mapServiceFactory
         * @param {?=} loader
         * @return {?}
         */
            function (mapServiceFactory, loader) {
                return {
                    ngModule: MapModule,
                    providers: [
                        mapServiceFactory ? { provide: MapServiceFactory, useValue: mapServiceFactory } :
                            { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: BingMapServiceFactoryFactory },
                        loader ? { provide: MapAPILoader, useValue: loader } : { provide: MapAPILoader, useFactory: BingMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        /**
         * @return {?}
         */
        MapModule.forRootBing = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: MapModule,
                    providers: [
                        { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: BingMapServiceFactoryFactory },
                        { provide: MapAPILoader, useFactory: BingMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        /**
         * @return {?}
         */
        MapModule.forRootGoogle = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: MapModule,
                    providers: [
                        { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: GoogleMapServiceFactoryFactory },
                        { provide: MapAPILoader, useFactory: GoogleMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        MapModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            MapLayerDirective,
                            MapComponent,
                            MapMarkerDirective,
                            InfoBoxComponent,
                            InfoBoxActionDirective,
                            MapPolygonDirective,
                            MapPolylineDirective,
                            ClusterLayerDirective,
                            MapMarkerLayerDirective,
                            MapPolygonLayerDirective,
                            MapPolylineLayerDirective
                        ],
                        imports: [common.CommonModule],
                        exports: [
                            common.CommonModule,
                            MapComponent,
                            MapMarkerDirective,
                            MapPolygonDirective,
                            MapPolylineDirective,
                            InfoBoxComponent,
                            InfoBoxActionDirective,
                            MapLayerDirective,
                            ClusterLayerDirective,
                            MapMarkerLayerDirective,
                            MapPolygonLayerDirective,
                            MapPolylineLayerDirective
                        ]
                    },] },
        ];
        return MapModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.MapComponent = MapComponent;
    exports.InfoBoxComponent = InfoBoxComponent;
    exports.MapMarkerDirective = MapMarkerDirective;
    exports.MapPolygonDirective = MapPolygonDirective;
    exports.MapPolylineDirective = MapPolylineDirective;
    exports.InfoBoxActionDirective = InfoBoxActionDirective;
    exports.MapMarkerLayerDirective = MapMarkerLayerDirective;
    exports.MapPolygonLayerDirective = MapPolygonLayerDirective;
    exports.MapLayerDirective = MapLayerDirective;
    exports.ClusterLayerDirective = ClusterLayerDirective;
    exports.MapPolylineLayerDirective = MapPolylineLayerDirective;
    exports.MapTypeId = MapTypeId;
    exports.Marker = Marker;
    exports.MarkerTypeId = MarkerTypeId;
    exports.InfoWindow = InfoWindow;
    exports.Layer = Layer;
    exports.ClusterPlacementMode = ClusterPlacementMode;
    exports.ClusterClickAction = ClusterClickAction;
    exports.SpiderClusterMarker = SpiderClusterMarker;
    exports.Polygon = Polygon;
    exports.Polyline = Polyline;
    exports.CanvasOverlay = CanvasOverlay;
    exports.MapService = MapService;
    exports.MapServiceFactory = MapServiceFactory;
    exports.MarkerService = MarkerService;
    exports.InfoBoxService = InfoBoxService;
    exports.MapAPILoader = MapAPILoader;
    exports.WindowRef = WindowRef;
    exports.DocumentRef = DocumentRef;
    exports.LayerService = LayerService;
    exports.PolygonService = PolygonService;
    exports.PolylineService = PolylineService;
    exports.ClusterService = ClusterService;
    exports.BingMapServiceFactory = BingMapServiceFactory;
    exports.BingMapAPILoaderConfig = BingMapAPILoaderConfig;
    exports.BingMapService = BingMapService;
    exports.BingInfoBoxService = BingInfoBoxService;
    exports.BingMarkerService = BingMarkerService;
    exports.BingPolygonService = BingPolygonService;
    exports.BingPolylineService = BingPolylineService;
    exports.BingMapAPILoader = BingMapAPILoader;
    exports.BingLayerService = BingLayerService;
    exports.BingClusterService = BingClusterService;
    exports.BingLayer = BingLayer;
    exports.BingMarker = BingMarker;
    exports.BingPolyline = BingPolyline;
    exports.BingMapEventsLookup = BingMapEventsLookup;
    exports.BingPolygon = BingPolygon;
    exports.BingInfoWindow = BingInfoWindow;
    exports.BingClusterLayer = BingClusterLayer;
    exports.BingSpiderClusterMarker = BingSpiderClusterMarker;
    exports.BingCanvasOverlay = BingCanvasOverlay;
    exports.GoogleClusterService = GoogleClusterService;
    exports.GoogleInfoBoxService = GoogleInfoBoxService;
    exports.GoogleLayerService = GoogleLayerService;
    exports.GoogleMapAPILoader = GoogleMapAPILoader;
    exports.GoogleMapAPILoaderConfig = GoogleMapAPILoaderConfig;
    exports.GoogleMapServiceFactory = GoogleMapServiceFactory;
    exports.GoogleMapService = GoogleMapService;
    exports.GoogleMarkerService = GoogleMarkerService;
    exports.GooglePolygonService = GooglePolygonService;
    exports.GooglePolylineService = GooglePolylineService;
    exports.GoogleMarker = GoogleMarker;
    exports.GoogleInfoWindow = GoogleInfoWindow;
    exports.GooglePolygon = GooglePolygon;
    exports.GooglePolyline = GooglePolyline;
    exports.GoogleMapEventsLookup = GoogleMapEventsLookup;
    exports.GoogleCanvasOverlay = GoogleCanvasOverlay;
    exports.MapModule = MapModule;
    exports.a = ClusterServiceFactory;
    exports.b = InfoBoxServiceFactory;
    exports.c = LayerServiceFactory;
    exports.d = MapServiceCreator;
    exports.e = MarkerServiceFactory;
    exports.f = PolygonServiceFactory;
    exports.g = PolylineServiceFactory;
    exports.l = BingLayerBase;
    exports.i = BingMapLoaderFactory;
    exports.h = BingMapServiceFactoryFactory;
    exports.m = GoogleLayerBase;
    exports.k = GoogleMapLoaderFactory;
    exports.j = GoogleMapServiceFactoryFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1tYXBzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcmtlci10eXBlLWlkLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcC10eXBlLWlkLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvcG9seWdvbi50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvcG9seWxpbmUudHMiLG51bGwsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvc3BpZGVyLWNsdXN0ZXItbWFya2VyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9jbHVzdGVyLXBsYWNlbWVudC1tb2RlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbi50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvY2FudmFzLW92ZXJsYXkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1zcGlkZXItY2x1c3Rlci1tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1jbHVzdGVyLWxheWVyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcC1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZXh0ZW5kZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLXBvbHlnb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1wb2x5bGluZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLWV2ZW50cy1sb29rdXAudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1jYW52YXMtb3ZlcmxheS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcy50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNvbnZlcnNpb25zLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLW1hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWV2ZW50cy1sb29rdXAudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtY2FudmFzLW92ZXJsYXkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbWFwc2VydmljZWZhY3RvcnkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbWFwLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbWFya2VyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvaW5mb2JveC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvcG9seWdvbi5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL3BvbHlsaW5lLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvaW5mb2JveC1hY3Rpb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9pbmZvYm94LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLW1hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9tYXAtcG9seWdvbi50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1wb2x5bGluZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1tYXJrZXItbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9tYXAtcG9seWdvbi1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1wb2x5bGluZS1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9tYXBhcGlsb2FkZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5hcGktbG9hZGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLWluZm9ib3guc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFya2VyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci1iYXNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1jbHVzdGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLXBvbHlnb24uc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctcG9seWxpbmUuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UuZmFjdG9yeS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWxheWVyLWJhc2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jbHVzdGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1pbmZvYm94LnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1sYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcmtlci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLW1hcmtlci1jbHVzdGVyZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlnb24uc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAuc2VydmljZS5mYWN0b3J5LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5mb1dpbmRvdyB7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGluZm8gYm94IGlzIGN1cnJlbnRseSBvcGVuLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IElzT3BlbigpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwcmltaXRpdmUgb2YgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGluZm8gd2luZG93LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvV2luZG93XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBpbmZvIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQ2xvc2UoKTogdm9pZCA7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRQb3NpdGlvbigpOiBJTGF0TG9uZztcblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBpbmZvIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgT3BlbigpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5mbyB3aW5kb3cgb3B0aW9ucyB0byBzZXQuIFRoZSBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggYW55IGV4aXN0aW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRPcHRpb25zKG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmZvIHdpbmRvdyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIEdlbyBjb29yZGluYXRlcyB0byBtb3ZlIHRoZSBhbmNob3Igb2YgdGhlIGluZm8gd2luZG93IHRvLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0UG9zaXRpb24ocG9zaXRpb246IElMYXRMb25nKTogdm9pZDtcbn1cbiIsImV4cG9ydCBlbnVtIE1hcmtlclR5cGVJZCB7XG4gICAgTm9uZSA9IDAsXG4gICAgRm9udE1hcmtlcixcbiAgICBDYW52YXNNYXJrZXIsXG4gICAgRHluYW1pY0NpcmNsZU1hcmtlcixcbiAgICBSb3RhdGVkSW1hZ2VNYXJrZXIsXG4gICAgUm91bmRlZEltYWdlTWFya2VyLFxuICAgIFNjYWxlZEltYWdlTWFya2VyLFxuICAgIEN1c3RvbVxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XG5pbXBvcnQgeyBJU2l6ZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXNpemUnO1xuaW1wb3J0IHsgTWFya2VyVHlwZUlkIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlci10eXBlLWlkJztcblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBkZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgYW4gaWNvbiBjYWNoZSBlbnRyeS5cbiAqL1xuaW50ZXJmYWNlIElNYXJrZXJJY29uQ2FjaGVFbnRyeSB7XG4gICAgLyoqXG4gICAgICogVGhlIGljb24gc3RyaW5nIG9mIHRoZSBjYWNoZSBlbnRyeS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJTWFya2VySWNvbkNhY2hlRW50cnlcbiAgICAgKi9cbiAgICBtYXJrZXJJY29uU3RyaW5nOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgU2l6ZSBvZiB0aGUgaWNvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJTWFya2VySWNvbkNhY2hlRW50cnlcbiAgICAqICovXG4gICAgbWFya2VyU2l6ZTogSVNpemU7XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBkZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgYSBtYXJrZXIuXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXJrZXIge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgY29uY3JldGUgaW1nIGVsZW1lbnRzIGZvciBtYXJrZXIgaWNvbnMgdG8gYWNjZWxlcmF0ZSBwYXRpbmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBJbWFnZUVsZW1lbnRDYWNoZTogTWFwPHN0cmluZywgSFRNTEltYWdlRWxlbWVudD4gPSBuZXcgTWFwPHN0cmluZywgSFRNTEltYWdlRWxlbWVudD4oKTtcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjYWNoZSBnZW5lcmF0ZWQgbWFya2VycyBmb3IgcGVyZm9ybWFuY2UgYW5kIHJldXNhYmlsaXR5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIE1hcmtlckNhY2hlOiBNYXA8c3RyaW5nLCBJTWFya2VySWNvbkNhY2hlRW50cnk+ID0gbmV3IE1hcDxzdHJpbmcsIElNYXJrZXJJY29uQ2FjaGVFbnRyeT4oKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXJrZXIgYmFzZWQgb24gdGhlIG1hcmtlciBpbmZvLiBJbiB0dXJuIGNhbGxzIGEgbnVtYmVyIG9mIGludGVybmFsIG1lbWJlcnMgdG9cbiAgICAgKiBjcmVhdGUgdGhlIGFjdHVhbCBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSBpY29uIGluZm9ybWF0aW9uLiBEZXBlbmRpbmcgb24gdGhlIG1hcmtlciB0eXBlLCB2YXJpb3VzIHByb3BlcnRpZXNcbiAgICAgKiBuZWVkIHRvIGJlIHByZXNlbnQuIEZvciBwZXJmb3JtYW5jZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGFuIGlkIGZvciBtYXJrZXJzIHRoYXQgYXJlIGNvbW1vbiB0byBmYWNpbGl0YXRlXG4gICAgICogcmV1c2UuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgb24gbWFya2VycyB0aGF0IHJlcXVpcmUgYXN5bmNyb25vdXNcbiAgICAgKiBwcm9jZXNzaW5nIGR1cmluZyBjcmVhdGlvbi4gRm9yIG1hcmtlcnMgdGhhdCBkbyBub3QgcmVxdWlyZSBhc3luYyBwcm9jZXNzaW5nLCB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkLlxuICAgICAqIEByZXR1cm5zIC0gYSBzdHJpbmcgb3IgYSBwcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICogYSBkYXRhIHVybCB3aXRoIHRoZSBtYXJrZXIgaW1hZ2UuXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgQ3JlYXRlTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmd8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4ge1xuICAgICAgICBzd2l0Y2ggKGljb25JbmZvLm1hcmtlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWFya2VyVHlwZUlkLkNhbnZhc01hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVDYW52YXNNYXJrZXIoaWNvbkluZm8pO1xuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuRHluYW1pY0NpcmNsZU1hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVEeW5hbWljQ2lyY2xlTWFya2VyKGljb25JbmZvKTtcbiAgICAgICAgICAgIGNhc2UgTWFya2VyVHlwZUlkLkZvbnRNYXJrZXI6IHJldHVybiBNYXJrZXIuQ3JlYXRlRm9udEJhc2VkTWFya2VyKGljb25JbmZvKTtcbiAgICAgICAgICAgIGNhc2UgTWFya2VyVHlwZUlkLlJvdGF0ZWRJbWFnZU1hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVSb3RhdGVkSW1hZ2VNYXJrZXIoaWNvbkluZm8pO1xuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuUm91bmRlZEltYWdlTWFya2VyOiByZXR1cm4gTWFya2VyLkNyZWF0ZVJvdW5kZWRJbWFnZU1hcmtlcihpY29uSW5mbyk7XG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5TY2FsZWRJbWFnZU1hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVTY2FsZWRJbWFnZU1hcmtlcihpY29uSW5mbyk7XG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5DdXN0b206IHRocm93IEVycm9yKCdDdXN0b20gTWFya2VyIENyZWF0b3JzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgbWFya2VyIHR5cGU6ICcgKyBpY29uSW5mby5tYXJrZXJUeXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGEgc2hhcmVkIGltZyBlbGVtZW50IGZvciBhIG1hcmtlciBpY29uIHRvIHByZXZlbnQgdW5lY2Vzc2FyeSBjcmVhdGlvbiBvZlxuICAgICAqIERPTSBpdGVtcy4gVGhpcyBoYXMgc3BlZCB1cCBsYXJnZSBzY2FsZSBtYWtlcnMgb24gQmluZyBNYXBzIGJ5IGFib3V0IDcwJVxuICAgICAqIEBwYXJhbSBpY29uIC0gVGhlIGljb24gc3RyaW5nICh1cmwsIGRhdGEgdXJsLCBzdmcpIGZvciB3aGljaCB0byBvYnRhaW4gdGhlIGltYWdlLlxuICAgICAqIEByZXR1cm5zIC0gVGhlIG9idGFpbmVkIGltYWdlIGVsZW1lbnQuXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgR2V0SW1hZ2VGb3JNYXJrZXIoaWNvbjogc3RyaW5nKTogSFRNTEltYWdlRWxlbWVudCB7XG4gICAgICAgIGlmIChpY29uID09IG51bGwgfHwgaWNvbiA9PT0gJycgKSB7IHJldHVybiAgbnVsbDsgfVxuXG4gICAgICAgIGxldCBpbWc6IEhUTUxJbWFnZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpbWcgPSBNYXJrZXIuSW1hZ2VFbGVtZW50Q2FjaGUuZ2V0KGljb24pO1xuICAgICAgICBpZiAoaW1nICE9IG51bGwpIHsgcmV0dXJuIGltZzsgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBpY29uO1xuICAgICAgICAgICAgTWFya2VyLkltYWdlRWxlbWVudENhY2hlLnNldChpY29uLCBpbWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhc2VkIGJhc2VkIG1hcmtlciB1c2luZyB0aGUgcG9pbnQgY29sbGVjdGlvbiBjb250YWluZWQgaW4gdGhlIGljb25JbmZvIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxuICAgICAqIEByZXR1cm5zIC0gU3RyaW5nIHdpdGggdGhlIGRhdGEgdXJsIGZvciB0aGUgbWFya2VyIGltYWdlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgQ3JlYXRlQ2FudmFzTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmcge1xuICAgICAgICBpZiAoZG9jdW1lbnQgPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignRG9jdW1lbnQgY29udGV4dCAod2luZG93LmRvY3VtZW50KSBpcyByZXF1aXJlZCBmb3IgY2FudmFzIG1hcmtlcnMuJyk7IH1cbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8uc2l6ZSA9PSBudWxsIHx8IGljb25JbmZvLnBvaW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnNpemUsIGFuZCBJTWFya2VySUNvbkluZm8ucG9pbnRzIGFyZSByZXF1aXJlZCBmb3IgY2FudmFzIG1hcmtlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwgJiYgTWFya2VyLk1hcmtlckNhY2hlLmhhcyhpY29uSW5mby5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcbiAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSBtaS5tYXJrZXJTaXplO1xuICAgICAgICAgICAgcmV0dXJuIG1pLm1hcmtlckljb25TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgYy53aWR0aCA9IGljb25JbmZvLnNpemUud2lkdGg7XG4gICAgICAgIGMuaGVpZ2h0ID0gaWNvbkluZm8uc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGlmIChpY29uSW5mby5yb3RhdGlvbikge1xuICAgICAgICAgICAgLy8gT2Zmc2V0IHRoZSBjYW52YXMgc3VjaCB0aGF0IHdlIHdpbGwgcm90YXRlIGFyb3VuZCB0aGUgY2VudGVyIG9mIG91ciBhcnJvd1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjLndpZHRoICogMC41LCBjLmhlaWdodCAqIDAuNSk7XG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhcyBieSB0aGUgZGVzaXJlZCBoZWFkaW5nXG4gICAgICAgICAgICBjdHgucm90YXRlKGljb25JbmZvLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNhbnZhcyBvZmZzZXQgYmFjayB0byBpdCdzIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jLndpZHRoICogMC41LCAtYy5oZWlnaHQgKiAwLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGljb25JbmZvLmNvbG9yIHx8ICdyZWQnO1xuXG4gICAgICAgIC8vIERyYXcgYSBwYXRoIGluIHRoZSBzaGFwZSBvZiBhbiBhcnJvdy5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoaWNvbkluZm8uZHJhd2luZ09mZnNldCkgeyBjdHgubW92ZVRvKGljb25JbmZvLmRyYXdpbmdPZmZzZXQueCwgaWNvbkluZm8uZHJhd2luZ09mZnNldC55KTsgfVxuICAgICAgICBpY29uSW5mby5wb2ludHMuZm9yRWFjaCgocDogSVBvaW50KSA9PiB7IGN0eC5saW5lVG8ocC54LCBwLnkpOyB9KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwpIHsgTWFya2VyLk1hcmtlckNhY2hlLnNldChpY29uSW5mby5pZCwgeyBtYXJrZXJJY29uU3RyaW5nOiBzLCBtYXJrZXJTaXplOiBpY29uSW5mby5zaXplIH0pOyB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaXJjbGUgbWFya2VyIGltYWdlIHVzaW5nIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBpbiB0aGUgaWNvbkluZm8gcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXG4gICAgICogQHJldHVybnMgLSBTdHJpbmcgd2l0aCB0aGUgZGF0YSB1cmwgZm9yIHRoZSBtYXJrZXIgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVEeW5hbWljQ2lyY2xlTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmcge1xuICAgICAgICBpZiAoZG9jdW1lbnQgPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignRG9jdW1lbnQgY29udGV4dCAod2luZG93LmRvY3VtZW50KSBpcyByZXF1aXJlZCBmb3IgZHluYW1pYyBjaXJjbGUgbWFya2Vycy4nKTsgfVxuICAgICAgICBpZiAoaWNvbkluZm8gPT0gbnVsbCB8fCBpY29uSW5mby5zaXplID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0lNYXJrZXJJY29uSW5mby5zaXplIGlzIHJlcXVpcmVkIGZvciBkeW5hbWljIGNpcmNsZSBtYXJrZXJzLicpOyB9XG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XG4gICAgICAgICAgICBpY29uSW5mby5zaXplID0gbWkubWFya2VyU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGg6IG51bWJlciA9IGljb25JbmZvLnN0cm9rZVdpZHRoIHx8IDA7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBTVkcgc3RyaW5nIG9mIGEgY2lyY2xlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYW5kIGNvbG9yLlxuICAgICAgICBjb25zdCBzdmc6IEFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCInLFxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZS53aWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgICBpY29uSW5mby5zaXplLndpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnXCI+PGNpcmNsZSBjeD1cIicsXG4gICAgICAgICAgICAoaWNvbkluZm8uc2l6ZS53aWR0aCAvIDIpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnXCIgY3k9XCInLFxuICAgICAgICAgICAgKGljb25JbmZvLnNpemUud2lkdGggLyAyKS50b1N0cmluZygpLFxuICAgICAgICAgICAgJ1wiIHI9XCInLFxuICAgICAgICAgICAgKChpY29uSW5mby5zaXplLndpZHRoIC8gMikgLSBzdHJva2VXaWR0aCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICdcIiBzdHJva2U9XCInLFxuICAgICAgICAgICAgaWNvbkluZm8uY29sb3IgfHwgJ3JlZCcsXG4gICAgICAgICAgICAnXCIgc3Ryb2tlLXdpZHRoPVwiJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnXCIgZmlsbD1cIicsXG4gICAgICAgICAgICBpY29uSW5mby5jb2xvciB8fCAncmVkJyxcbiAgICAgICAgICAgICdcIi8+PC9zdmc+J1xuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IHN2Zy5qb2luKCcnKTtcbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwpIHsgTWFya2VyLk1hcmtlckNhY2hlLnNldChpY29uSW5mby5pZCwgeyBtYXJrZXJJY29uU3RyaW5nOiBzLCBtYXJrZXJTaXplOiBpY29uSW5mby5zaXplIH0pOyB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmb250IGJhc2VkIG1hcmtlciBpbWFnZSAoc3VjaCBhcyBGb250LUF3ZXNvbWUpLCBieSB1c2luZyBpbmZvcm1hdGlvbiBzdXBwbGllZCBpbiB0aGUgcGFyYW1ldGVycyAoc3VjaCBhcyBGb250LUF3ZXNvbWUpLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXG4gICAgICogQHJldHVybnMgLSBTdHJpbmcgd2l0aCB0aGUgZGF0YSB1cmwgZm9yIHRoZSBtYXJrZXIgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVGb250QmFzZWRNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZyB7XG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciBmb250IGJhc2VkIG1hcmtlcnMnKTsgfVxuICAgICAgICBpZiAoaWNvbkluZm8gPT0gbnVsbCB8fCBpY29uSW5mby5mb250TmFtZSA9PSBudWxsIHx8IGljb25JbmZvLmZvbnRTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJTWFya2VySWNvbkluZm8uZm9udE5hbWUsIElNYXJrZXJJY29uSW5mby5mb250U2l6ZSBhbmQgSU1hcmtlcklDb25JbmZvLnRleHQgYXJlIHJlcXVpcmVkIGZvciBmb250IGJhc2VkIG1hcmtlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwgJiYgTWFya2VyLk1hcmtlckNhY2hlLmhhcyhpY29uSW5mby5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcbiAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSBtaS5tYXJrZXJTaXplO1xuICAgICAgICAgICAgcmV0dXJuIG1pLm1hcmtlckljb25TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgZm9udDogc3RyaW5nID0gaWNvbkluZm8uZm9udFNpemUgKyAncHggJyArIGljb25JbmZvLmZvbnROYW1lO1xuICAgICAgICBjdHguZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgLy8gUmVzaXplIGNhbnZhcyBiYXNlZCBvbiBzaWUgb2YgdGV4dC5cbiAgICAgICAgY29uc3Qgc2l6ZTogVGV4dE1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoaWNvbkluZm8udGV4dCk7XG4gICAgICAgIGMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICBjLmhlaWdodCA9IGljb25JbmZvLmZvbnRTaXplO1xuXG4gICAgICAgIGlmIChpY29uSW5mby5yb3RhdGlvbikge1xuICAgICAgICAgICAgLy8gT2Zmc2V0IHRoZSBjYW52YXMgc3VjaCB0aGF0IHdlIHdpbGwgcm90YXRlIGFyb3VuZCB0aGUgY2VudGVyIG9mIG91ciBhcnJvd1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjLndpZHRoICogMC41LCBjLmhlaWdodCAqIDAuNSk7XG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhcyBieSB0aGUgZGVzaXJlZCBoZWFkaW5nXG4gICAgICAgICAgICBjdHgucm90YXRlKGljb25JbmZvLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNhbnZhcyBvZmZzZXQgYmFjayB0byBpdCdzIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jLndpZHRoICogMC41LCAtYy5oZWlnaHQgKiAwLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgZm9udCBhcyBpdCB3aWxsIGJlIGNsZWFyZWQgYnkgdGhlIHJlc2l6ZS5cbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpY29uSW5mby5jb2xvciB8fCAncmVkJztcblxuICAgICAgICBjdHguZmlsbFRleHQoaWNvbkluZm8udGV4dCwgMCwgMCk7XG4gICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XG4gICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IGMudG9EYXRhVVJMKCk7XG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGltYWdlIG1hcmtlciBieSBhcHBseWluZyBhIHJvYXRpb24gdG8gYSBzdXBwbGllZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxuICAgICAqIEByZXR1cm5zIC0gYSBzdHJpbmcgb3IgYSBwcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICogYSBkYXRhIHVybCB3aXRoIHRoZSBtYXJrZXIgaW1hZ2UuIEluIGNhc2Ugb2YgYSBjYWNoZWQgaW1hZ2UsIHRoZSBpbWFnZSB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgdGhlIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVSb3RhdGVkSW1hZ2VNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiB7XG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciByb3RhdGVkIGltYWdlIG1hcmtlcnMnKTsgfVxuICAgICAgICBpZiAoaWNvbkluZm8gPT0gbnVsbCB8fCBpY29uSW5mby5yb3RhdGlvbiA9PSBudWxsIHx8IGljb25JbmZvLnVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnJvdGF0aW9uLCBJTWFya2VySWNvbkluZm8udXJsIGFyZSByZXF1aXJlZCBmb3Igcm90YXRlZCBpbWFnZSBtYXJrZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XG4gICAgICAgICAgICBpY29uSW5mby5zaXplID0gbWkubWFya2VyU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4gPVxuICAgICAgICAgICAgbmV3IFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIEFsbG93IGNyb3NzIGRvbWFpbiBpbWFnZSBlZGl0dGluZy5cbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBpY29uSW5mby51cmw7XG4gICAgICAgICAgICBpZiAoaWNvbkluZm8uc2l6ZSkge1xuICAgICAgICAgICAgICAgIGltYWdlLndpZHRoID0gaWNvbkluZm8uc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICBpbWFnZS5oZWlnaHQgPSBpY29uSW5mby5zaXplLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gYy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZHM6IG51bWJlciA9IGljb25JbmZvLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByb3RhdGVkIGltYWdlIHNpemUuXG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IE1hdGguY2VpbChNYXRoLmFicyhpbWFnZS53aWR0aCAqIE1hdGguY29zKHJhZHMpKSArIE1hdGguYWJzKGltYWdlLmhlaWdodCAqIE1hdGguc2luKHJhZHMpKSk7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5hYnMoaW1hZ2Uud2lkdGggKiBNYXRoLnNpbihyYWRzKSkgKyBNYXRoLmFicyhpbWFnZS5oZWlnaHQgKiBNYXRoLmNvcyhyYWRzKSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXMuXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjLndpZHRoIC8gMiwgYy5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGluIGRlZ3JlZXMuXG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShyYWRzKTtcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSwgc2luY2UgdGhlIGNvbnRleHQgaXMgcm90YXRlZCwgdGhlIGltYWdlIHdpbGwgYmUgcm90YXRlZCBhbHNvLlxuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIC1pbWFnZS53aWR0aCAvIDIsIC1pbWFnZS5oZWlnaHQgLyAyLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpY29uSW5mby5zaXplID0geyB3aWR0aDogYy53aWR0aCwgaGVpZ2h0OiBjLmhlaWdodCB9O1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCkgeyBNYXJrZXIuTWFya2VyQ2FjaGUuc2V0KGljb25JbmZvLmlkLCB7IG1hcmtlckljb25TdHJpbmc6IHMsIG1hcmtlclNpemU6IGljb25JbmZvLnNpemUgfSk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtpY29uOiBzLCBpY29uSW5mbzogaWNvbkluZm99KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcm91bmRlZCBpbWFnZSBtYXJrZXIgYnkgYXBwbHlpbmcgYSBjaXJjbGUgbWFzayB0byBhIHN1cHBsaWVkIGltYWdlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXG4gICAgICogQHBhcmFtIGljb25JbmZvIC0gQ2FsbGJhY2sgaW52b2tlZCBvbmNlIG1hcmtlciBnZW5lcmF0aW9uIGlzIGNvbXBsZXRlLiBUaGUgY2FsbGJhY2tcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSB0aGUgZGF0YSB1cmkgYW5kIHRoZSBJTWFya2VySWNvbkluZm8uXG4gICAgICogQHJldHVybnMgLSBhIHN0cmluZyBvciBhIHByb21pc2UgZm9yIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgKiBhIGRhdGEgdXJsIHdpdGggdGhlIG1hcmtlciBpbWFnZS4gSW4gY2FzZSBvZiBhIGNhY2hlZCBpbWFnZSwgdGhlIGltYWdlIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSB0aGUgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIENyZWF0ZVJvdW5kZWRJbWFnZU1hcmtlcihpY29uSW5mbzogSU1hcmtlckljb25JbmZvKTogc3RyaW5nfFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0RvY3VtZW50IGNvbnRleHQgKHdpbmRvdy5kb2N1bWVudCkgaXMgcmVxdWlyZWQgZm9yIHJvdW5kZWQgaW1hZ2UgbWFya2VycycpOyB9XG4gICAgICAgIGlmIChpY29uSW5mbyA9PSBudWxsIHx8IGljb25JbmZvLnNpemUgPT0gbnVsbCB8fCBpY29uSW5mby51cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0lNYXJrZXJJY29uSW5mby5zaXplLCBJTWFya2VySWNvbkluZm8udXJsIGFyZSByZXF1aXJlZCBmb3Igcm91bmRlZCBpbWFnZSBtYXJrZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XG4gICAgICAgICAgICBpY29uSW5mby5zaXplID0gbWkubWFya2VyU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4gPVxuICAgICAgICAgICAgbmV3IFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1czogbnVtYmVyID0gaWNvbkluZm8uc2l6ZS53aWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0OiBJUG9pbnQgPSBpY29uSW5mby5kcmF3aW5nT2Zmc2V0IHx8IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgICAvLyBBbGxvdyBjcm9zcyBkb21haW4gaW1hZ2UgZWRpdHRpbmcuXG4gICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaWNvbkluZm8udXJsO1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IGljb25JbmZvLnNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBpY29uSW5mby5zaXplLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIGNpcmNsZSB3aGljaCBjYW4gYmUgdXNlZCB0byBjbGlwIHRoZSBpbWFnZSwgdGhlbiBkcmF3IHRoZSBpbWFnZS5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhyYWRpdXMsIHJhZGl1cywgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBvZmZzZXQueCwgb2Zmc2V0LnksIGljb25JbmZvLnNpemUud2lkdGgsIGljb25JbmZvLnNpemUud2lkdGgpO1xuICAgICAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzOiBzdHJpbmcgPSBjLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoe2ljb246IHMsIGljb25JbmZvOiBpY29uSW5mb30pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzY2FsZWQgaW1hZ2UgbWFya2VyIGJ5IHNjYWxpbmcgYSBzdXBwbGllZCBpbWFnZSBieSBhIGZhY3RvciB1c2luZyBhIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIENhbGxiYWNrIGludm9rZWQgb25jZSBtYXJrZXIgZ2VuZXJhdGlvbiBpcyBjb21wbGV0ZS4gVGhlIGNhbGxiYWNrXG4gICAgICogcGFyYW1ldGVycyBhcmUgdGhlIGRhdGEgdXJpIGFuZCB0aGUgSU1hcmtlckljb25JbmZvLlxuICAgICAqIEByZXR1cm5zIC0gYSBzdHJpbmcgb3IgYSBwcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICogYSBkYXRhIHVybCB3aXRoIHRoZSBtYXJrZXIgaW1hZ2UuIEluIGNhc2Ugb2YgYSBjYWNoZWQgaW1hZ2UsIHRoZSBpbWFnZSB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgdGhlIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVTY2FsZWRJbWFnZU1hcmtlcihpY29uSW5mbzogSU1hcmtlckljb25JbmZvKTogc3RyaW5nfFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0RvY3VtZW50IGNvbnRleHQgKHdpbmRvdy5kb2N1bWVudCkgaXMgcmVxdWlyZWQgZm9yIHNjYWxlZCBpbWFnZSBtYXJrZXJzJyk7IH1cbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8uc2NhbGUgPT0gbnVsbCB8fCBpY29uSW5mby51cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0lNYXJrZXJJY29uSW5mby5zY2FsZSwgSU1hcmtlckljb25JbmZvLnVybCBhcmUgcmVxdWlyZWQgZm9yIHNjYWxlZCBpbWFnZSBtYXJrZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtaTogSU1hcmtlckljb25DYWNoZUVudHJ5ID0gTWFya2VyLk1hcmtlckNhY2hlLmdldChpY29uSW5mby5pZCk7XG4gICAgICAgICAgICBpY29uSW5mby5zaXplID0gbWkubWFya2VyU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2U6IFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+ID1cbiAgICAgICAgICAgIG5ldyBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyBjcm9zcyBkb21haW4gaW1hZ2UgZWRpdHRpbmcuXG4gICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaWNvbkluZm8udXJsO1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IGltYWdlLndpZHRoICogaWNvbkluZm8uc2NhbGU7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiBpY29uSW5mby5zY2FsZTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgYSBjaXJjbGUgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2xpcCB0aGUgaW1hZ2UsIHRoZW4gZHJhdyB0aGUgaW1hZ2UuXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgYy53aWR0aCwgYy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzOiBzdHJpbmcgPSBjLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoe2ljb246IHMsIGljb25JbmZvOiBpY29uSW5mb30pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQcm9wZXJ0eSBkZWZpbml0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgZmlyc3QgbWFya2VyIGluIGEgc2V0LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgSXNGaXJzdCgpOiBib29sZWFuO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgSXNGaXJzdCh2YWw6IGJvb2xlYW4pO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgbGFzdCBtYXJrZXIgaW4gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IElzTGFzdCgpOiBib29sZWFuO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgSXNMYXN0KHZhbDogYm9vbGVhbik7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBMb2NhdGlvbiBvZiB0aGUgbWFya2VyXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBMb2NhdGlvbigpOiBJTGF0TG9uZztcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcmtlciBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBtYXJrZXIgKGUuZy4gTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbilcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlTWFya2VyKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbGFiZWxcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRMYWJlbCgpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgdmlzaWJpbGl0eVxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEdldFZpc2libGUoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFuY2hvciBmb3IgdGhlIG1hcmtlci4gVXNlIHRoaXMgdG8gYWRqdXN0IHRoZSByb290IGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIHRvIGFjY29tb2RhdGUgdmFyaW91cyBtYXJrZXIgaW1hZ2Ugc2l6ZXMuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gYW5jaG9yIC0gUG9pbnQgY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgYW5jaG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRBbmNob3IoYW5jaG9yOiBJUG9pbnQpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZHJhZ2dhYmlsaXR5IG9mIGEgbWFya2VyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFyayB0aGUgbWFya2VyIGFzIGRyYWdnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGljb24gZm9yIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gaWNvbiAtIFN0cmluZyBjb250YWluaW5nIHRoZSBpY29uIGluIHZhcmlvdXMgZm9ybXMgKHVybCwgZGF0YSB1cmwsIGV0Yy4pXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldEljb24oaWNvbjogc3RyaW5nKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcmtlciBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYWJlbCAtIFN0cmluZyBjb250YWluaW5nIHRoZSBsYWJlbCB0byBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldExhYmVsKGxhYmVsOiBzdHJpbmcpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlbyBjb29yZGluYXRlcyB0byBzZXQgdGhlIG1hcmtlciBwb3NpdGlvbiB0by5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0UG9zaXRpb24obGF0TG5nOiBJTGF0TG9uZyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gdGl0bGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgdGl0bGUgdG8gc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcmtlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBtYXJrZXIgb3B0aW9ucyB0byBzZXQuIFRoZSBzdXBwbGllZCBvcHRpb25zIGFyZVxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSB1bmRlcmx5aW5nIG1hcmtlciBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmxpbHR5IG9mIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIEJvb2xlYW4gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgbWFya2VyIGlzIHZpc2libGUgb3Igbm90LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xuXG59XG4iLCJleHBvcnQgZW51bSBNYXBUeXBlSWQge1xuXG4gICAgLyoqIFRoZSBhZXJpYWwgbWFwIHR5cGUgd2hpY2ggdXNlcyB0b3AtZG93biBzYXRlbGxpdGUgJiBhaXJwbGFuZSBpbWFnZXJ5LiAqL1xuICAgIGFlcmlhbCxcblxuICAgIC8qKiBBIGRhcmtlciB2ZXJzaW9uIG9mIHRoZSByb2FkIG1hcHMuICovXG4gICAgY2FudmFzRGFyayxcblxuICAgIC8qKiBBIGxpZ2h0ZXIgdmVyc2lvbiBvZiB0aGUgcm9hZCBtYXBzIHdoaWNoIGFsc28gaGFzIHNvbWUgb2YgdGhlIGRldGFpbHMgc3VjaCBhcyBoaWxsIHNoYWRpbmcgZGlzYWJsZWQuICovXG4gICAgY2FudmFzTGlnaHQsXG5cbiAgICAvKiogQSBncmF5c2NhbGUgdmVyc2lvbiBvZiB0aGUgcm9hZCBtYXBzLiAqL1xuICAgIGdyYXlzY2FsZSxcblxuICAgIC8qKiBUaGUgYWVyaWFsIG1hcCB0eXBlIGluY2x1ZGluZyBsYWJsZXMgKi9cbiAgICBoeWJyaWQsXG5cbiAgICAvKiogRGlzcGxheXMgYSBibGFuayBjYW52YXMgdGhhdCB1c2VzIHRoZSBtZXJjYXRvciBtYXAgcHJvamVjdC4gSXQgYmFzaWNhbGx5IHJlbW92ZWQgdGhlIGJhc2UgbWFwcyBsYXllci4gKi9cbiAgICBtZXJjYXRvcixcblxuICAgIC8qKiBPcmRuYW5jZSBzdXJ2ZXkgbWFwIHR5cGUgKGVuLWdiIG9ubHkpLiAqL1xuICAgIG9yZG5hbmNlU3VydmV5LFxuXG4gICAgLyoqIFJvYWQgbWFwIHR5cGUuICovXG4gICAgcm9hZCxcblxuICAgIC8qKiBQcm92aWRlcyBzdHJlZXRzaWRlIHBhbm9yYW1hcyBmcm9tIHRoZSBzdHJlZXQgbGV2ZWwuICovXG4gICAgc3RyZWV0c2lkZVxuXG59XG4iLCJpbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuL21hcmtlcic7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi9wb2x5bGluZSc7XG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi9pbmZvLXdpbmRvdyc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29udHJhY3QgZm9yIGEgbWFwIGxheWVyIGltcGxlbWVudGF0aW9uLiBEZXJpdmluZyBwcm92aWRlcnMgc2hvdWxkIGltcGxlbWVudHMgdGhpcyBhYnN0cmFjdFxuICogdG8gcHJvdmlkZSBjb25jcmV0ZSBsYXllciBmdW5jdGlvbmFsaXR5IGZvciB0aGUgbWFwLlxuICpcbiAqIEBleHBvcnRcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTGF5ZXIge1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hdGl2ZSBwcmltaXRpdmUgdW5kZXJuZWF0aCB0aGUgYWJzdHJhY3Rpb24gbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbGF5ZXIgaW4gdGhlIHVuZGVybHlpbmcgcHJvdmlkZXIgKHN1Y2ggYXNcbiAgICAgKiBNaWNyb3NvZnQuTWFwcy5MYXllcikuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kcywgTGF5ZXIgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIHN0cmluZy4gVHlwZSBvZiBldmVudCB0byBhZGQgKGNsaWNrLCBtb3VzZW92ZXIsIGV0YykuIFlvdSBjYW4gdXNlIGFueSBldmVudCB0aGF0IHRoZSB1bmRlcmx5aW5nIG5hdGl2ZVxuICAgICAqIGxheWVyIHN1cHBvcnRzLlxuICAgICAqIEBwYXJhbSBmbiBmdW5jdGlvbi4gSGFuZGxlciB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcbiAgICAgKiBhcyBtYXJrZXIsIGluZm93aW5kb3csIHBvbHlsaW5lLCBwb2x5Z29uLCBldGMuLikgSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBub3QgZXhwZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAqIHRoZXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZS4gRW50aXR5IHRvIGFkZCB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkRW50aXR5KGVudGl0eTogTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIGVudGl0aWVzIHRvIHRoZSBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcbiAgICAgKiBhcyBtYXJrZXIsIGluZm93aW5kb3csIHBvbHlsaW5lLCBwb2x5Z29uLCBldGMuLikgSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBub3QgZXhwZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAqIHRoaXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRpdGllcyBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPi4gRW50aXRpZXMgdG8gYWRkIHRvIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRFbnRpdGllcyhlbnRpdHk6IEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExheWVyXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZSgpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBnb3Zlcm5pbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxheWVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0T3B0aW9ucygpOiBJTGF5ZXJPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaXMgdGhlIGxheWVyIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRWaXNpYmxlKCk6IGJvb2xlYW47XG5cbiAgICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBlbnRpdHkgZnJvbSB0aGUgY2x1c3RlciBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcbiAgICAgKiBhcyBtYXJrZXIsIGluZm93aW5kb3csIHBvbHlsaW5lLCBwb2x5Z29uLCBldGMuLikgSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBub3QgZXhwZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAqIHRoaXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSBFbnRpdHkgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBSZW1vdmVFbnRpdHkoZW50aXR5OiBNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lKTogdm9pZDtcblxuICAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuIEVudGl0aWVzIGluIHRoaXMgY29udGV4dCBzaG91bGQgYmUgbW9kZWwgYWJzdHJhY3Rpb25zIG9mIGNvbmNlcmVkIG1hcCBmdW5jdGlvbmFsaXR5IChzdWNoXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGV4cGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgKiB0aGlzZSBjb25jZXB0cywgaW5zdGVhZCwgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0IG1vZGVsIGNsYXNzZXMgc2hvdWxkIGJlIGltcGxlbWVudGVkIGZvciBlYWNoIHByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPnxBcnJheTxJbmZvV2luZG93PnxBcnJheTxQb2x5Z29uPnxBcnJheTxQb2x5bGluZT4gY29udGFpbmluZyB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLlxuICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGV4aXN0aW5nIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExheWVyXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+fEFycmF5PEluZm9XaW5kb3c+fEFycmF5PFBvbHlnb24+fEFycmF5PFBvbHlsaW5lPik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgY2x1c3RlciBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIElDbHVzdGVyT3B0aW9ucyBjb250YWluaW5nIHRoZSBvcHRpb25zIGVudW1lcmF0aW9uIGNvbnRyb2xsaW5nIHRoZSBsYXllciBiZWhhdmlvci4gVGhlIHN1cHBsaWVkIG9wdGlvbnNcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRPcHRpb25zKG9wdGlvbnM6IElMYXllck9wdGlvbnMpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY2x1c3RlciBsYXllciB2aXNpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcblxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZGVmaW5pbmcgdGhlIGNvbnRyYWN0IGZvciBhIHBvbHlnb24gaW4gdGhlIGFyY2hpdGVjdHVyZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvbHlnb24ge1xuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcm90ZWN0ZWQgX2NlbnRyb2lkOiBJTGF0TG9uZztcbiAgICBwcm90ZWN0ZWQgX2NlbnRlcjogSUxhdExvbmc7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlnb24ncyBjZW50ZXIuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IENlbnRlcigpOiBJTGF0TG9uZyB7XG4gICAgICAgIGlmICh0aGlzLl9jZW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5HZXRCb3VuZGluZ0NlbnRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9seWdvbidzIGNlbnRyb2lkLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGdldCBDZW50cm9pZCgpOiBJTGF0TG9uZyB7XG4gICAgICAgIGlmICh0aGlzLl9jZW50cm9pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IHRoaXMuR2V0UG9seWdvbkNlbnRyb2lkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRyb2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSB6b29tIGF0IHdoaWNoIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQuIElnbm9yZWQgb3IgU2hvd0xhYmVsIGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IExhYmVsTWF4Wm9vbSgpOiBudW1iZXI7XG4gICAgcHVibGljIGFic3RyYWN0IHNldCBMYWJlbE1heFpvb20odmFsOiBudW1iZXIpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgTGFiZWxNaW5ab29tKCk6IG51bWJlcjtcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IExhYmVsTWluWm9vbSh2YWw6IG51bWJlcik7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgU2hvd0xhYmVsKCk6IGJvb2xlYW47XG4gICAgcHVibGljIGFic3RyYWN0IHNldCBTaG93TGFiZWwodmFsOiBib29sZWFuKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIHRvb2x0aXBcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBTaG93VG9vbHRpcCgpOiBib29sZWFuO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGl0bGUgb2ZmIHRoZSBwb2x5Z29uXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgVGl0bGUoKTogc3RyaW5nO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgVGl0bGUodmFsOiBzdHJpbmcpO1xuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZGVsZWdhdGUgZm9yIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2dhYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBwYXRoIGNhbiBiZSBlZGl0ZWQuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBhdGggY2FuIGJlIGVkaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0RWRpdGFibGUoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2YgSUxhdExvbmcgb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5Z29uIHBhdGguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRQYXRoKCk6IEFycmF5PElMYXRMb25nPjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aHMuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIEFycmF5IG9mIElMYXRMb25nIG9iamVjdHMgZGVzY3JpYmluZyBtdWx0aXBsZSBwb2x5Z29uIHBhdGhzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0UGF0aHMoKTogQXJyYXk8QXJyYXk8SUxhdExvbmc+PjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEdldFZpc2libGUoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyBkcmFnYWJsZS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1ha2UgdGhlIHBvbHlnb24gZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB3ZXRoZXIgdGhlIHBvbHlnb24gcGF0aCBpcyBlZGl0YWJsZS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5Z29uIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUxhdExvbmd9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBUaGUgb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggaHRlIG9uZXNcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBwYXRoLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRQYXRoKHBhdGg6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PElMYXRMb25nPik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gcGF0aCBvciBwYXRocy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBwYXRocyBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9XG4gICAgICogKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWdvbnMgcGF0aChzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldFBhdGhzKHBhdGhzOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+IHwgQXJyYXk8SUxhdExvbmc+KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWdvbiB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb25zJyBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIElMYXRMb25nIG9iamVjdCBjb250YWluaW5nIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIEdldEJvdW5kaW5nQ2VudGVyKCk6IElMYXRMb25nIHtcbiAgICAgICAgbGV0IGM6IElMYXRMb25nID0ge2xhdGl0dWRlOiAwLCBsb25naXR1ZGU6IDB9O1xuICAgICAgICBsZXQgeDE6IG51bWJlciA9IDkwLCB4MjogbnVtYmVyID0gLTkwLCB5MTogbnVtYmVyID0gMTgwLCB5MjogbnVtYmVyID0gLTE4MDtcbiAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IHRoaXMuR2V0UGF0aHMoKTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguZm9yRWFjaChpbm5lciA9PiBpbm5lci5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwLmxhdGl0dWRlIDwgeDEpIHsgeDEgPSBwLmxhdGl0dWRlOyB9XG4gICAgICAgICAgICAgICAgaWYgKHAubGF0aXR1ZGUgPiB4MikgeyB4MiA9IHAubGF0aXR1ZGU7IH1cbiAgICAgICAgICAgICAgICBpZiAocC5sb25naXR1ZGUgPCB5MSkgeyB5MSA9IHAubG9uZ2l0dWRlOyB9XG4gICAgICAgICAgICAgICAgaWYgKHAubG9uZ2l0dWRlID4geTIpIHsgeTIgPSBwLmxvbmdpdHVkZTsgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYy5sYXRpdHVkZSA9IHgxICsgKHgyIC0geDEpIC8gMjtcbiAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geTEgKyAoeTIgLSB5MSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjZW50cm9pZCBvZiB0aGUgcG9seWdvbiBiYXNlZCBvbiB0aGUgcG9seWdvbiBwYXRoLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgY2VudHJvaWQgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24uXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBHZXRQb2x5Z29uQ2VudHJvaWQoKTogSUxhdExvbmcge1xuICAgICAgICBsZXQgYzogSUxhdExvbmcgPSB7bGF0aXR1ZGU6IDAsIGxvbmdpdHVkZTogMH07XG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSB0aGlzLkdldFBhdGhzKCk7XG4gICAgICAgIGNvbnN0IG9mZiA9IHBhdGhbMF1bMF07XG4gICAgICAgIGlmIChvZmYgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHR3aWNlYXJlYTogbnVtYmVyID0gMDtcbiAgICAgICAgICAgIGxldCB4OiBudW1iZXIgPSAwO1xuICAgICAgICAgICAgbGV0IHk6IG51bWJlciA9IDA7XG4gICAgICAgICAgICBsZXQgcDE6IElMYXRMb25nLCBwMjogSUxhdExvbmc7XG4gICAgICAgICAgICBsZXQgZjogbnVtYmVyO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBwYXRoLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBwYXRoW2tdLmxlbmd0aCAtIDE7IGkgPCBwYXRoW2tdLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHBhdGhba11baV07XG4gICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aFtrXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChwMS5sYXRpdHVkZSAtIG9mZi5sYXRpdHVkZSkgKiAocDIubG9uZ2l0dWRlIC0gb2ZmLmxvbmdpdHVkZSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgKHAyLmxhdGl0dWRlIC0gb2ZmLmxhdGl0dWRlKSAqIChwMS5sb25naXR1ZGUgLSBvZmYubG9uZ2l0dWRlKTtcbiAgICAgICAgICAgICAgICAgICAgdHdpY2VhcmVhICs9IGY7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gKHAxLmxhdGl0dWRlICsgcDIubGF0aXR1ZGUgLSAyICogb2ZmLmxhdGl0dWRlKSAqIGY7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gKHAxLmxvbmdpdHVkZSArIHAyLmxvbmdpdHVkZSAtIDIgKiBvZmYubG9uZ2l0dWRlKSAqIGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR3aWNlYXJlYSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGYgPSB0d2ljZWFyZWEgKiAzO1xuICAgICAgICAgICAgICAgIGMubGF0aXR1ZGUgPSB4IC8gZiArIG9mZi5sYXRpdHVkZTtcbiAgICAgICAgICAgICAgICBjLmxvbmdpdHVkZSA9IHkgLyBmICsgb2ZmLmxvbmdpdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGMubGF0aXR1ZGUgPSBvZmYubGF0aXR1ZGU7XG4gICAgICAgICAgICAgICAgYy5sb25naXR1ZGUgPSBvZmYubG9uZ2l0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBkZWZpbmluZyB0aGUgY29udHJhY3QgZm9yIGEgcG9seWxpbmUgaW4gdGhlIGFyY2hpdGVjdHVyZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvbHlsaW5lIHtcbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJvdGVjdGVkIF9jZW50cm9pZDogSUxhdExvbmc7XG4gICAgcHJvdGVjdGVkIF9jZW50ZXI6IElMYXRMb25nO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSdzIGNlbnRlci5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IENlbnRlcigpOiBJTGF0TG9uZyB7XG4gICAgICAgIGlmICh0aGlzLl9jZW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5HZXRCb3VuZGluZ0NlbnRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9seWxpbmUncyBjZW50cm9pZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IENlbnRyb2lkKCk6IElMYXRMb25nIHtcbiAgICAgICAgaWYgKHRoaXMuX2NlbnRyb2lkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NlbnRyb2lkID0gdGhpcy5HZXRQb2x5bGluZUNlbnRyb2lkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRyb2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBwcmltaXR2ZSBpbXBsZW1lbnRpbmcgdGhlIHBvbHlsaW5lLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBTaG93VG9vbHRpcCgpOiBib29sZWFuO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGl0bGUgb2ZmIHRoZSBwb2x5bGluZVxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBUaXRsZSgpOiBzdHJpbmc7XG4gICAgcHVibGljIGFic3RyYWN0IHNldCBUaXRsZSh2YWw6IHN0cmluZyk7XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2VudHJvaWQgb2YgdGhlIHBvbHlsaW5lIGJhc2VkIG9uIHRoZSBhIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aGUgY2VudHJvaWRcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBjZW50cm9pZCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWxpbmUuXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgR2V0UG9seWxpbmVDZW50cm9pZChwYXRoOiBBcnJheTxJTGF0TG9uZz4pOiBJTGF0TG9uZyB7XG4gICAgICAgIGxldCBjOiBJTGF0TG9uZyA9IHtsYXRpdHVkZTogMCwgbG9uZ2l0dWRlOiAwfTtcbiAgICAgICAgY29uc3Qgb2ZmID0gcGF0aFswXTtcbiAgICAgICAgaWYgKG9mZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgdHdpY2VhcmVhOiBudW1iZXIgPSAwO1xuICAgICAgICAgICAgbGV0IHg6IG51bWJlciA9IDA7XG4gICAgICAgICAgICBsZXQgeTogbnVtYmVyID0gMDtcbiAgICAgICAgICAgIGxldCBwMTogSUxhdExvbmcsIHAyOiBJTGF0TG9uZztcbiAgICAgICAgICAgIGxldCBmOiBudW1iZXI7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcGF0aC5sZW5ndGggLSAxOyBpIDwgcGF0aC5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgICAgICBwMSA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgcDIgPSBwYXRoW2pdO1xuICAgICAgICAgICAgICAgIGYgPSAocDEubGF0aXR1ZGUgLSBvZmYubGF0aXR1ZGUpICogKHAyLmxvbmdpdHVkZSAtIG9mZi5sb25naXR1ZGUpIC1cbiAgICAgICAgICAgICAgICAgICAgKHAyLmxhdGl0dWRlIC0gb2ZmLmxhdGl0dWRlKSAqIChwMS5sb25naXR1ZGUgLSBvZmYubG9uZ2l0dWRlKTtcbiAgICAgICAgICAgICAgICB0d2ljZWFyZWEgKz0gZjtcbiAgICAgICAgICAgICAgICB4ICs9IChwMS5sYXRpdHVkZSArIHAyLmxhdGl0dWRlIC0gMiAqIG9mZi5sYXRpdHVkZSkgKiBmO1xuICAgICAgICAgICAgICAgIHkgKz0gKHAxLmxvbmdpdHVkZSArIHAyLmxvbmdpdHVkZSAtIDIgKiBvZmYubG9uZ2l0dWRlKSAqIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHdpY2VhcmVhICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZiA9IHR3aWNlYXJlYSAqIDM7XG4gICAgICAgICAgICAgICAgYy5sYXRpdHVkZSA9IHggLyBmICsgb2ZmLmxhdGl0dWRlO1xuICAgICAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geSAvIGYgKyBvZmYubG9uZ2l0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYy5sYXRpdHVkZSA9IG9mZi5sYXRpdHVkZTtcbiAgICAgICAgICAgICAgICBjLmxvbmdpdHVkZSA9IG9mZi5sb25naXR1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZGVsZWdhdGUgZm9yIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBEZWxldGUoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgZHJhZ2dhYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEdldERyYWdnYWJsZSgpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGNhbiBiZSBlZGl0ZWQuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBhdGggY2FuIGJlIGVkaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEdldEVkaXRhYmxlKCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBwYXRoLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBJTGF0TG9uZyBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lIHBhdGguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0UGF0aCgpOiBBcnJheTxJTGF0TG9uZz47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRWaXNpYmxlKCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIGRyYWdhYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWxpbmUgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGlzIGVkaXRhYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlsaW5lIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb2x5bGluZSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xuICAgICAqIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIHBhdGguXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWxpbmVzIHBhdGguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4gfCBBcnJheTxJTGF0TG9uZz4pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWxpbmUgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNlbnRlciBvZiB0aGUgcG9seWxpbmUnIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgY2VudGVyIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgR2V0Qm91bmRpbmdDZW50ZXIoKTogSUxhdExvbmcge1xuICAgICAgICBsZXQgYzogSUxhdExvbmcgPSB7bGF0aXR1ZGU6IDAsIGxvbmdpdHVkZTogMH07XG4gICAgICAgIGxldCB4MTogbnVtYmVyID0gOTAsIHgyOiBudW1iZXIgPSAtOTAsIHkxOiBudW1iZXIgPSAxODAsIHkyOiBudW1iZXIgPSAtMTgwO1xuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSB0aGlzLkdldFBhdGgoKTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocC5sYXRpdHVkZSA8IHgxKSB7IHgxID0gcC5sYXRpdHVkZTsgfVxuICAgICAgICAgICAgICAgIGlmIChwLmxhdGl0dWRlID4geDIpIHsgeDIgPSBwLmxhdGl0dWRlOyB9XG4gICAgICAgICAgICAgICAgaWYgKHAubG9uZ2l0dWRlIDwgeTEpIHsgeTEgPSBwLmxvbmdpdHVkZTsgfVxuICAgICAgICAgICAgICAgIGlmIChwLmxvbmdpdHVkZSA+IHkyKSB7IHkyID0gcC5sb25naXR1ZGU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYy5sYXRpdHVkZSA9IHgxICsgKHgyIC0geDEpIC8gMjtcbiAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geTEgKyAoeTIgLSB5MSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjZW50cm9pZCBvZiB0aGUgcG9seWxpbmUgYmFzZWQgb24gdGhlIHBvbHlsaW5lIHBhdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBjZW50cm9pZCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWxpbmUuXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgR2V0UG9seWxpbmVDZW50cm9pZCgpOiBJTGF0TG9uZyB7XG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IHRoaXMuR2V0UGF0aCgpO1xuICAgICAgICBjb25zdCBjOiBJTGF0TG9uZyAgPSBQb2x5bGluZS5HZXRQb2x5bGluZUNlbnRyb2lkKHBhdGgpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbn1cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4vbWFya2VyJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNwaWRlckNsdXN0ZXJNYXJrZXIgZXh0ZW5kcyBNYXJrZXIge1xuXG4gICAgLyoqIFRoZSBwYXJlbnQgcHVzaHBpbiBpbiB3aGljaCB0aGUgc3BpZGVyIHB1c2hwaW4gaXMgZGVyaXZlZCBmcm9tLiAqL1xuICAgIHB1YmxpYyBQYXJlbnRNYXJrZXI6IE1hcmtlcjtcblxuICAgIC8qKiBUaGUgc3RpY2sgdGhhdCBjb25uZWN0cyB0aGUgc3BpZGVyIHB1c2hwaW4gdG8gdGhlIGNsdXN0ZXIuICovXG4gICAgcHVibGljIFN0aWNrOiBhbnk7XG5cbn1cbiIsImV4cG9ydCBlbnVtIENsdXN0ZXJQbGFjZW1lbnRNb2RlIHtcbiAgICBOb25lID0gMCxcbiAgICBNZWFuVmFsdWUsXG4gICAgRmlyc3RQaW5cbn1cbiIsImV4cG9ydCBlbnVtIENsdXN0ZXJDbGlja0FjdGlvbiB7XG4gICAgTm9uZSA9IDAsXG4gICAgWm9vbUludG9DbHVzdGVyLFxuICAgIFNwaWRlclxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi9tYXAtbGFiZWwnO1xuXG5sZXQgaWQ6IG51bWJlciA9IDA7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBpbXBsZW1lbnRpbmcgYSBjYW52YXMgb3ZlcmxheSB0byBiZSBwbGFjZWQgb24gdGhlIG1hcC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENhbnZhc092ZXJsYXkge1xuXG4gICAgLy8vXG4gICAgLy8vIGZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByb3RlY3RlZCBfcmVhZHlSZXNvbHZlcjogKHZhbDogYm9vbGVhbikgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgcHJvdGVjdGVkIF96b29tU3RhcnQ6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2NlbnRlclN0YXJ0OiBJTGF0TG9uZztcbiAgICBwdWJsaWMgX2NhbnZhc1JlYWR5OiBQcm9taXNlPGJvb2xlYW4+ID0gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUsIHJlamVjdCkgPT4geyB0aGlzLl9yZWFkeVJlc29sdmVyID0gcmVzb2x2ZTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGdldHMgcmVzb2x2ZWQgd2hlbiB0aGUgY2FudmFzIG92ZXJsYXkgaXMgcmVhZHkgZm9yIGludGVyYWN0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgQ2FudmFzUmVhZHkoKTogUHJvbWlzZTxib29sZWFuPiB7IHJldHVybiB0aGlzLl9jYW52YXNSZWFkeTsgfVxuXG4gICAgLyoqXG4gICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZSByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXG4gICAgKi9cbiAgICBwcml2YXRlIF9kcmF3Q2FsbGJhY2s6IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDYW52YXNPdmVybGF5IGNsYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRyYXdDYWxsYmFjazogKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NhbGxiYWNrID0gZHJhd0NhbGxiYWNrO1xuICAgICAgICBpZCsrO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgY2FudmFzIG92ZXJsYXkuXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXRNYXAobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBjbGljayBsb2NhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBhbnkpOiBJTGF0TG9uZztcblxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIGFzc29jaXRlZCB3aXRoIHRoZSBsYWJlbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0TWFwKCk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBNYXBMYWJlbCBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0gdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHRvb2x0aXAuXG4gICAgICogVGhpcyBtZXRob2Qgb25seSBnZW5lcmF0ZXMgdGhlIG1hcCBsYWJlbC4gQ29udGVudCBhbmQgcGxhY2VtZW50IGlzIHRoZSByZXNwb25zaWJpbGl0eVxuICAgICAqIG9mIHRoZSBjYWxsZXIuXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEdldFRvb2xUaXBPdmVybGF5KCk6IE1hcExhYmVsO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzT3ZlcmxheSBhZGRlZCB0byBtYXAsIGxvYWQgY2FudmFzLlxuICAgICAqL1xuICAgIHB1YmxpYyBPbkFkZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgdGhpcy5fY2FudmFzLmlkID0gYHhNYXBPdmVybGF5JHtpZH1gO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgY2FudmFzIHRvIHRoZSBvdmVybGF5LlxuICAgICAgICB0aGlzLlNldENhbnZhc0VsZW1lbnQodGhpcy5fY2FudmFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW52YXNPdmVybGF5IGxvYWRlZCwgYXR0YWNoIG1hcCBldmVudHMgZm9yIHVwZGF0aW5nIGNhbnZhcy5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgT25Mb2FkKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBDYW52YXNMYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCwgcmVsZWFzZSByZXNvdXJjZXMuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIE9uUmVtb3ZlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLlNldENhbnZhc0VsZW1lbnQobnVsbCk7XG4gICAgICAgIHRoaXMuUmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhd3MgdGhlIGNhbnZhcyBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXG4gICAgICogQHBhcmFtIGNsZWFyIC0gVHJ1ZSB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nLlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBSZWRyYXcoY2xlYXI6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcyA9PSBudWxsKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBieSB1cGRhdGluZyBkaW1lbnNpb25zLiBUaGlzIGFsc28gZW5zdXJlcyBjYW52YXMgc3RheXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbWFwLlxuICAgICAgICBpZiAoY2xlYXIpIHsgdGhpcy5SZXNpemUoKTsgfVxuXG4gICAgICAgIC8vIENhbGwgdGhlIGRyYXdpbmcgY2FsbGJhY2sgZnVuY3Rpb24gaWYgc3BlY2lmaWVkLlxuICAgICAgICBpZiAodGhpcy5fZHJhd0NhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Q2FsbGJhY2sodGhpcy5fY2FudmFzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBmb3IgdGhlIGxhYmVsLiBTZXR0aW5ncyB0aGlzIHRvIG51bGwgcmVtb3ZlIHRoZSBsYWJlbCBmcm9tIGh0ZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0gQSBuYXRpdmUgbWFwIG9iamVjdCBmb3IgdGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24uIEltcGxlbWVudGluZyBkZXJpdmF0aXZlcyBzaG91bGQgcmV0dXJuIHRoZVxuICAgICAqIGFjdHVhbCBuYXRpdmUgb2JqZWN0LlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRNYXAobWFwOiBhbnkpOiB2b2lkO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgY2FudmFzIHRvIHRoZSBtYXAuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IFNldENhbnZhc0VsZW1lbnQoZWw6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgbWFwIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgUmVtb3ZlRXZlbnRIYW5kbGVycygpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ2FudmFzIHNpemUgYmFzZWQgb24gdGhlIG1hcCBzaXplLlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgUmVzaXplKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDYW52YXMuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBVcGRhdGVDYW52YXMoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgdGhlIENTUyBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucyBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBVcGRhdGVQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIpIHtcbiAgICAgICAgLy8gVXBkYXRlIENTUyBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBDU1MgZGltZW5zaW9ucy5cbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IGVhY2hTZXJpZXMsIG5leHRUaWNrIH0gZnJvbSAnYXN5bmMnO1xuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9sYXllcic7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tYXJrZXInO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3BvbHlnb24nO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9wb2x5bGluZSc7XG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vaW5mby13aW5kb3cnO1xuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwU2VydmljZX0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgbWFwIGxheWVyIGZvciB0aGUgQmluZyBNYXAgUHJvdmlkZXIuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgQmluZ0xheWVyIGltcGxlbWVudHMgTGF5ZXIge1xuXG4gICAgcHJpdmF0ZSBfcGVuZGluZ0VudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPiA9IG5ldyBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPigpO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hdGl2ZSBwcmltaXRpdmUgdW5kZXJuZWF0aCB0aGUgYWJzdHJhY3Rpb24gbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBNaWNyb3NvZnQuTWFwcy5MYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcjtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEJpbmdDbHVzdGVyTGF5ZXIgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2xheWVyIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllci4gTmF0aXZlIEJpbmcgQ2x1c3RlciBMYXllciBzdXBwb3J0aW5nIHRoZSBjbHVzdGVyIGxheWVyLlxuICAgICAqIEBwYXJhbSBfbWFwcyBNYXBTZXJ2aWNlLiBNYXBTZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRvIGxldmVyYWdlIGZvciB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyLCBwcml2YXRlIF9tYXBzOiBNYXBTZXJ2aWNlKSB7IH1cblxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzLCBMYXllciBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgc3RyaW5nLiBUeXBlIG9mIGV2ZW50IHRvIGFkZCAoY2xpY2ssIG1vdXNlb3ZlciwgZXRjKS4gWW91IGNhbiB1c2UgYW55IGV2ZW50IHRoYXQgdGhlIHVuZGVybHlpbmcgbmF0aXZlXG4gICAgICogbGF5ZXIgc3VwcG9ydHMuXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX2xheWVyLCBldmVudFR5cGUsIChlKSA9PiB7XG4gICAgICAgICAgICBmbihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRpdHkgdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudGl0eSBNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lLiBFbnRpdHkgdG8gYWRkIHRvIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkRW50aXR5KGVudGl0eTogTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSk6IHZvaWQge1xuICAgICAgICBpZiAoZW50aXR5ICYmIGVudGl0eS5OYXRpdmVQcmltaXR2ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuR2V0VmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nRW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG51bWJlciBvZiBlbnRpdGllcyB0byB0aGUgbGF5ZXIuIEVudGl0aWVzIGluIHRoaXMgY29udGV4dCBzaG91bGQgYmUgbW9kZWwgYWJzdHJhY3Rpb25zIG9mIGNvbmNlcmVkIG1hcCBmdW5jdGlvbmFsaXR5IChzdWNoXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4uIEVudGl0aWVzIHRvIGFkZCB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXG4gICAgICovXG4gICAgcHVibGljIEFkZEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPik6IHZvaWQge1xuICAgICAgICAvL1xuICAgICAgICAvLyB1c2UgZWFjaFNlcmllcyBhcyBvcHBvc2VkIHRvIF9sYXllci5hZGQoW10pIHRvIHByb3ZpZGUgYSBub24tYmxvY2tpbmcgZXhwZXJpZW5jZSBmb3IgbGFyZ2VyIGRhdGEgc2V0cy5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGVudGl0aWVzICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShlbnRpdGllcykgJiYgZW50aXRpZXMubGVuZ3RoICE9PSAwICkge1xuICAgICAgICAgICAgZWFjaFNlcmllcyhbLi4uZW50aXRpZXNdLCAoZSwgbmV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLkdldFZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5hZGQoZS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nRW50aXRpZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWFwcy5EZWxldGVMYXllcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgSUNsdXN0ZXJPcHRpb25zLiBUaGUgbGF5ZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJTGF5ZXJPcHRpb25zIHtcbiAgICAgICAgY29uc3QgbzogSUxheWVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiBOdW1iZXIodGhpcy5fbGF5ZXIuZ2V0SWQoKSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuLiBUcnVlIGlzIHRoZSBsYXllciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiAge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXIuZ2V0VmlzaWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgUmVtb3ZlRW50aXR5KGVudGl0eTogTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSk6IHZvaWQge1xuICAgICAgICBpZiAoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllci5yZW1vdmUoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRpdGllcyBBcnJheTxNYXJrZXI+fEFycmF5PEluZm9XaW5kb3c+fEFycmF5PFBvbHlnb24+fEFycmF5PFBvbHlsaW5lPiBjb250YWluaW5nIHRoZSBlbnRpdGllcyB0byBhZGQgdG8gdGhlIGNsdXN0ZXIuXG4gICAgICogVGhpcyByZXBsYWNlcyBhbnkgZXhpc3RpbmcgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXG4gICAgICovXG4gICAgcHVibGljIFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+fEFycmF5PEluZm9XaW5kb3c+fEFycmF5PFBvbHlnb24+fEFycmF5PFBvbHlsaW5lPik6IHZvaWQge1xuICAgICAgICAvL1xuICAgICAgICAvLyB3ZSBhcmUgdXNpbmcgcmVtb3ZhbCBhbmQgYWRkIGFzIG9wcG9zZWQgdG8gc2V0IGFzIGZvciBsYXJnZSBudW1iZXIgb2Ygb2JqZWN0cyBpdCB5aWVsZHMgYSBub24tYmxvY2tpbmcsIHNtb290aGVyIHBlcmZvcm1hbmNlLi4uXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuX2xheWVyLnNldFByaW1pdGl2ZXMoW10pO1xuICAgICAgICB0aGlzLkFkZEVudGl0aWVzKGVudGl0aWVzKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjbHVzdGVyIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgSUNsdXN0ZXJPcHRpb25zIGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgZW51bWVyYXRpb24gY29udHJvbGxpbmcgdGhlIGxheWVyIGJlaGF2aW9yLiBUaGUgc3VwcGxpZWQgb3B0aW9uc1xuICAgICAqIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdC9leGlzdGluZyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElMYXllck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXIubWV0YWRhdGEuaWQgPSBvcHRpb25zLmlkLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY2x1c3RlciBsYXllciB2aXNpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgaWYgKHZpc2libGUgJiYgdGhpcy5fcGVuZGluZ0VudGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuQWRkRW50aXRpZXModGhpcy5fcGVuZGluZ0VudGl0aWVzLnNwbGljZSgwKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWJveCc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcbmltcG9ydCB7IElJbmZvV2luZG93QWN0aW9uIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctYWN0aW9uJztcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2ludCc7XG5pbXBvcnQgeyBNYXBUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFwLXR5cGUtaWQnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBDbHVzdGVyUGxhY2VtZW50TW9kZSB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIGhlbHBlcmZ1bmN0aW9ucyB0byBtYXAgdmFyaW91cyBpbnRlcmZhY2VzIHVzZWQgdG8gcmVwcmVzZW50IG9wdGlvbnMgYW5kIHN0cnVjdHVyZXMgaW50byB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgQmluZyBNYXBzIFY4IHNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5nQ29udmVyc2lvbnMge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX21hcE9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICAgJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgICdjcmVkZW50aWFscycsXG4gICAgICAgICdjdXN0b21pemVPdmVybGF5cycsXG4gICAgICAgICdjdXN0b21NYXBTdHlsZScsXG4gICAgICAgICdkaXNhYmxlQmlyZHNleWUnLFxuICAgICAgICAnZGlzYWJsZUtleWJvYXJkSW5wdXQnLFxuICAgICAgICAnZGlzYWJsZU1vdXNlSW5wdXQnLFxuICAgICAgICAnZGlzYWJsZVBhbm5pbmcnLFxuICAgICAgICAnZGlzYWJsZVRvdWNoSW5wdXQnLFxuICAgICAgICAnZGlzYWJsZVVzZXJJbnB1dCcsXG4gICAgICAgICdkaXNhYmxlWm9vbWluZycsXG4gICAgICAgICdkaXNhYmxlU3RyZWV0c2lkZScsXG4gICAgICAgICdlbmFibGVDbGlja2FibGVMb2dvJyxcbiAgICAgICAgJ2VuYWJsZVNlYXJjaExvZ28nLFxuICAgICAgICAnZml4ZWRNYXBQb3NpdGlvbicsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAnaW5lcnRpYUludGVuc2l0eScsXG4gICAgICAgICduYXZpZ2F0aW9uQmFyTW9kZScsXG4gICAgICAgICdzaG93QnJlYWRjcnVtYicsXG4gICAgICAgICdzaG93Q29weXJpZ2h0JyxcbiAgICAgICAgJ3Nob3dEYXNoYm9hcmQnLFxuICAgICAgICAnc2hvd01hcFR5cGVTZWxlY3RvcicsXG4gICAgICAgICdzaG93U2NhbGViYXInLFxuICAgICAgICAndGhlbWUnLFxuICAgICAgICAndGlsZUJ1ZmZlcicsXG4gICAgICAgICd1c2VJbmVydGlhJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ2NlbnRlcicsXG4gICAgICAgICd6b29tJyxcbiAgICAgICAgJ21hcFR5cGVJZCcsXG4gICAgICAgICdsaXRlTW9kZSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogVmlldyBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gQmluZyBNYXAgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF92aWV3T3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xuICAgICAgICAnYW5pbWF0ZScsXG4gICAgICAgICdib3VuZHMnLFxuICAgICAgICAnY2VudGVyJyxcbiAgICAgICAgJ2NlbnRlck9mZnNldCcsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2xhYmVsT3ZlcmxheScsXG4gICAgICAgICdtYXBUeXBlSWQnLFxuICAgICAgICAncGFkZGluZycsXG4gICAgICAgICd6b29tJ1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBJbmZvV2luZG93IG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2luZm9XaW5kb3dPcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXG4gICAgICAgICdhY3Rpb25zJyxcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ2h0bWxDb250ZW50JyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ3Bvc2l0aW9uJyxcbiAgICAgICAgJ3BpeGVsT2Zmc2V0JyxcbiAgICAgICAgJ3Nob3dDbG9zZUJ1dHRvbicsXG4gICAgICAgICdzaG93UG9pbnRlcicsXG4gICAgICAgICdwdXNocGluJyxcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgJ3RpdGxlQ2xpY2tIYW5kbGVyJyxcbiAgICAgICAgJ3R5cGVOYW1lJyxcbiAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAnaGVpZ2h0J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBNYXJrZXIgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBfbWFya2VyT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xuICAgICAgICAnYW5jaG9yJyxcbiAgICAgICAgJ2RyYWdnYWJsZScsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAnaHRtbENvbnRlbnQnLFxuICAgICAgICAnaWNvbicsXG4gICAgICAgICdpbmZvYm94JyxcbiAgICAgICAgJ3N0YXRlJyxcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgJ3RleHRPZmZzZXQnLFxuICAgICAgICAndHlwZU5hbWUnLFxuICAgICAgICAndmlzaWJsZScsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICd6SW5kZXgnXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIFBvbHlnb24gb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIFBvbHlnb24gcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xuICAgICAgICAnY3Vyc29yJyxcbiAgICAgICAgJ2ZpbGxDb2xvcicsXG4gICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdzdHJva2VDb2xvcicsXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd2aXNpYmxlJ1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBQb2x5bGluZSBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gQmluZyBNYXAgUG9seWxpbmUgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICAgJ2N1cnNvcicsXG4gICAgICAgICdzdHJva2VDb2xvcicsXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd2aXNpYmxlJ1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2NsdXN0ZXJPcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXG4gICAgICAgICdjYWxsYmFjaycsXG4gICAgICAgICdjbHVzdGVyZWRQaW5DYWxsYmFjaycsXG4gICAgICAgICdjbHVzdGVyaW5nRW5hYmxlZCcsXG4gICAgICAgICdncmlkU2l6ZScsXG4gICAgICAgICdsYXllck9mZnNldCcsXG4gICAgICAgICdwbGFjZW1lbnRNb2RlJyxcbiAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICAnekluZGV4J1xuICAgIF07XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSUluZm9XaW5kb3dBY3Rpb24gdG8gYSBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTmF2dGl2ZSBtYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlQWN0aW9uKGFjdGlvbjogSUluZm9XaW5kb3dBY3Rpb24pOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnMge1xuICAgICAgICBjb25zdCBhOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnMgPSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXI6IGFjdGlvbi5ldmVudEhhbmRsZXIsXG4gICAgICAgICAgICBsYWJlbDogYWN0aW9uLmxhYmVsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gQXJyYXkgb2YgSUluZm9XaW5kb3dBY3Rpb24gdG8gYW4gQXJyYXkgb2YgTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hBY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyAtIEFycmF5IG9mIG9iamVjdHMgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2YgbWFwcGVkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVBY3Rpb25zKGFjdGlvbnM6IEFycmF5PElJbmZvV2luZG93QWN0aW9uPik6IEFycmF5PE1pY3Jvc29mdC5NYXBzLklJbmZvYm94QWN0aW9ucz4ge1xuICAgICAgICBjb25zdCBhOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnM+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLklJbmZvYm94QWN0aW9ucz4oKTtcbiAgICAgICAgYWN0aW9ucy5mb3JFYWNoKHggPT4gYS5wdXNoKEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVBY3Rpb24oeCkpKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhbiBJQm94IG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uUmVjdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYm94IC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVCb3VuZHMoYm94OiBJQm94KTogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb25SZWN0IHtcbiAgICAgICAgY29uc3QgcjogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb25SZWN0ID1cbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uUmVjdC5mcm9tRWRnZXMoYm94Lm1heExhdGl0dWRlLCBib3gubWluTG9uZ2l0dWRlLCBib3gubWluTGF0aXR1ZGUsIGJveC5tYXhMb25naXR1ZGUpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIElDbHVzdGVyT3B0aW9ucyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlQ2x1c3Rlck9wdGlvbnMob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyB8IGFueSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fY2x1c3Rlck9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2xheWVyT2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBvLmxheWVyT2Zmc2V0ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvaW50KG9wdGlvbnMubGF5ZXJPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ3BsYWNlbWVudE1vZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBsYWNlbWVudE1vZGUgPT09IENsdXN0ZXJQbGFjZW1lbnRNb2RlLkZpcnN0UGluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnBsYWNlbWVudE1vZGUgPSBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUGxhY2VtZW50VHlwZS5GaXJzdExvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5wbGFjZW1lbnRNb2RlID0gTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclBsYWNlbWVudFR5cGUuTWVhbkF2ZXJhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhbiBJSW5mb1dpbmRvd09wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hPcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVJbmZvQm94T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMgfCBhbnkgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX2luZm9XaW5kb3dPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdwaXhlbE9mZnNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgby5vZmZzZXQgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9pbnQob3B0aW9ucy5waXhlbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgby5sb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2FjdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uYWN0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVBY3Rpb25zKG9wdGlvbnMuYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSU1hcE9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSU1hcExvYWRPcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVMb2FkT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklNYXBMb2FkT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklNYXBMb2FkT3B0aW9ucyB8IGFueSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmluZ0NvbnZlcnNpb25zLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSB8fCBCaW5nQ29udmVyc2lvbnMuX3ZpZXdPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICBvLmNlbnRlciA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLmNlbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1hcFR5cGVJZCA9PT0gTWFwVHlwZUlkLmh5YnJpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuYWVyaWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5sYWJlbE92ZXJsYXkgPSBNaWNyb3NvZnQuTWFwcy5MYWJlbE92ZXJsYXkudmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm1hcFR5cGVJZCA9PT0gTWFwVHlwZUlkLmFlcmlhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuYWVyaWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgby5sYWJlbE92ZXJsYXkgPSBNaWNyb3NvZnQuTWFwcy5MYWJlbE92ZXJsYXkuaGlkZGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWRbKDxhbnk+TWFwVHlwZUlkKVtvcHRpb25zLm1hcFR5cGVJZF1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdib3VuZHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uYm91bmRzID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUJvdW5kcyhvcHRpb25zLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSUxhdExvbmcgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGxvbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxvY2F0aW9uKGxhdGxvbmc6IElMYXRMb25nKTogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24ge1xuICAgICAgICBjb25zdCBsOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbihsYXRsb25nLmxhdGl0dWRlLCBsYXRsb25nLmxvbmdpdHVkZSk7XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSU1hcmtlck9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBtYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fbWFya2VyT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSAnYW5jaG9yJykge1xuICAgICAgICAgICAgICAgICAgICBvLmFuY2hvciA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2ludChvcHRpb25zLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoPGFueT5vKVtrXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIElNYXBPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklNYXBPcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKTogTWljcm9zb2Z0Lk1hcHMuSU1hcE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JTWFwT3B0aW9ucyB8IGFueSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fbWFwT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICBvLmNlbnRlciA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLmNlbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUlkID0gTWljcm9zb2Z0Lk1hcHMuTWFwVHlwZUlkWyg8YW55Pk1hcFR5cGVJZClbb3B0aW9ucy5tYXBUeXBlSWRdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhbiBhcnJheSBvZiBsb2NhdGlvbnMgb3IgYW4gYXJyYXkgb3IgYXJyYXlzIG9mIGxvY2F0aW9uIHRvIGFuZCBhcnJheSBvZiBhcnJheXMgb2YgQmluZyBNYXAgTG9jYXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgLSBJTGF0TG9uZyBiYXNlZCBsb2NhdGlvbnMgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyAtIGNvbnZlcnRlZCBsb2NhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQYXRocyhwYXRoczogQXJyYXk8SUxhdExvbmc+IHwgQXJyYXk8QXJyYXk8SUxhdExvbmc+Pik6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4ge1xuICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gbmV3IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4oKTtcbiAgICAgICAgaWYgKHBhdGhzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkocGF0aHMpIHx8IHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcC5wdXNoKG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1swXSkpIHtcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBhcnJheXNcbiAgICAgICAgICAgIC8vIHVzIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgY29uc3QgcDEgPSA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPigpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcDFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX3AucHVzaChuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24ocDFbaV1bal0ubGF0aXR1ZGUsIHAxW2ldW2pdLmxvbmdpdHVkZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLnB1c2goX3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGEgc2ltcGxlIGFycmF5Li4uLlxuICAgICAgICAgICAgY29uc3QgeTogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPigpO1xuICAgICAgICAgICAgY29uc3QgcDEgPSA8QXJyYXk8SUxhdExvbmc+PnBhdGhzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHkucHVzaChuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24ocDFbaV0ubGF0aXR1ZGUsIHAxW2ldLmxvbmdpdHVkZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5wdXNoKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBNYXBzIGFuIElQb2ludCBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5Qb2ludCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBvaW50KHBvaW50OiBJUG9pbnQpOiBNaWNyb3NvZnQuTWFwcy5Qb2ludCB7XG4gICAgICAgIGNvbnN0IHA6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgTWFwcyBhbiBJUG9seWdvbk9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSVBvbHlnb25PcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCBmOiAoczogc3RyaW5nLCBhOiBudW1iZXIpID0+IHN0cmluZyA9IChzLCBhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtID0gL3JnYmE/XFwoKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKlxcZCtbXFwuXFxkK10qKSpcXCkvZy5leGVjKHMpO1xuICAgICAgICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgYSA9IGEgPiAxID8gKGEgLyAxMDApIDogYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIFttWzFdLCBtWzJdLCBtWzNdLCBhXS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBudW1iZXIgPSBhID4gMSA/IGEgOiBNYXRoLmZsb29yKGEgKiAyNTUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHo6IHN0cmluZyA9IHMuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHI6IG51bWJlciA9IHBhcnNlSW50KHouc3Vic3RyKDAsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgY29uc3QgZzogbnVtYmVyID0gcGFyc2VJbnQoei5zdWJzdHIoMiwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBjb25zdCBiOiBudW1iZXIgPSBwYXJzZUludCh6LnN1YnN0cig0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgW3IgLCBnLCBiLCBhXS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fcG9seWdvbk9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ3N0cm9rZVdlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgby5zdHJva2VUaGlja25lc3MgPSBvcHRpb25zLnN0cm9rZVdlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ3N0cm9rZUNvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZUNvbG9yID0gZihvcHRpb25zLnN0cm9rZUNvbG9yLCBvcHRpb25zLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5zdHJva2VDb2xvciA9IG9wdGlvbnMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ3N0cm9rZU9wYWNpdHknKSB7fVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdmaWxsQ29sb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGxPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmZpbGxDb2xvciA9IGYob3B0aW9ucy5maWxsQ29sb3IsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5maWxsQ29sb3IgPSBvcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnZmlsbE9wYWNpdHknKSB7fVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoPGFueT5vKVtrXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgTWFwcyBhbiBJUG9seWxpbmVPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zIHtcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucyB8IGFueSA9IHt9O1xuICAgICAgICBjb25zdCBmOiAoczogc3RyaW5nLCBhOiBudW1iZXIpID0+IHN0cmluZyA9IChzLCBhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtID0gL3JnYmE/XFwoKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKlxcZCtbXFwuXFxkK10qKSpcXCkvZy5leGVjKHMpO1xuICAgICAgICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgYSA9IGEgPiAxID8gKGEgLyAxMDApIDogYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIFttWzFdLCBtWzJdLCBtWzNdLCBhXS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBudW1iZXIgPSBhID4gMSA/IGEgOiBNYXRoLmZsb29yKGEgKiAyNTUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHo6IHN0cmluZyA9IHMuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHI6IG51bWJlciA9IHBhcnNlSW50KHouc3Vic3RyKDAsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgY29uc3QgZzogbnVtYmVyID0gcGFyc2VJbnQoei5zdWJzdHIoMiwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBjb25zdCBiOiBudW1iZXIgPSBwYXJzZUludCh6LnN1YnN0cig0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgW3IgLCBnLCBiLCBhXS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSAnc3Ryb2tlV2VpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZVRoaWNrbmVzcyA9IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ3N0cm9rZUNvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZUNvbG9yID0gZihvcHRpb25zLnN0cm9rZUNvbG9yLCBvcHRpb25zLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5zdHJva2VDb2xvciA9IG9wdGlvbnMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ3N0cm9rZU9wYWNpdHknKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSU1hcE9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSVZpZXdPcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVWaWV3T3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklWaWV3T3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklWaWV3T3B0aW9ucyB8IGFueSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fdmlld09wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgby5jZW50ZXIgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5jZW50ZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2JvdW5kcycpIHtcbiAgICAgICAgICAgICAgICAgICAgby5ib3VuZHMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlQm91bmRzKG9wdGlvbnMuYm91bmRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdjZW50ZXJPZmZzZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uY2VudGVyT2Zmc2V0ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvaW50KG9wdGlvbnMuY2VudGVyT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUlkID0gTWljcm9zb2Z0Lk1hcHMuTWFwVHlwZUlkWyg8YW55Pk1hcFR5cGVJZClbb3B0aW9ucy5tYXBUeXBlSWRdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBNYXJrZXJ9IGNvbnRyYWN0IGZvciB0aGUgQmluZyBNYXBzIFY4IG1hcCBhcmNoaXRlY3R1cmUuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgQmluZ01hcmtlciBpbXBsZW1lbnRzIE1hcmtlciB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVmaW5pdGlvbnNcbiAgICAvLy9cbiAgICBwcml2YXRlIF9tZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgcHJpdmF0ZSBfaXNGaXJzdCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2lzTGFzdCA9IHRydWU7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBtYXJrZXIgaXMgdGhlIGZpcnN0IG1hcmtlciBpbiBhIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IElzRmlyc3QoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pc0ZpcnN0OyB9XG4gICAgcHVibGljIHNldCBJc0ZpcnN0KHZhbDogYm9vbGVhbikgeyB0aGlzLl9pc0ZpcnN0ID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgbWFya2VyIGlzIHRoZSBsYXN0IG1hcmtlciBpbiB0aGUgc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSXNMYXN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faXNMYXN0OyB9XG4gICAgcHVibGljIHNldCBJc0xhc3QodmFsOiBib29sZWFuKSB7IHRoaXMuX2lzTGFzdCA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTG9jYXRpb24gb2YgdGhlIG1hcmtlclxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IExvY2F0aW9uKCk6IElMYXRMb25nIHtcbiAgICAgICAgY29uc3QgbDogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSB0aGlzLl9wdXNocGluLmdldExvY2F0aW9uKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXRpdHVkZTogbC5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogbC5sb25naXR1ZGVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgbWFya2VyLCBpbiB0aGlzIGNhc2Uge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW59XG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogYW55IHsgcmV0dXJuIHRoaXMuX3B1c2hwaW47IH1cblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTWFya2VyLlxuICAgICAqIEBwYXJhbSBfcHVzaHBpbiAtIFRoZSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbn0gdW5kZXJseWluZyB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIF9tYXAgLSBUaGUgY29udGV4dCBtYXAuXG4gICAgICogQHBhcmFtIF9sYXllciAtIFRoZSBjb250ZXh0IGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wdXNocGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluLCBwcm90ZWN0ZWQgX21hcDogTWljcm9zb2Z0Lk1hcHMuTWFwLCBwcm90ZWN0ZWQgX2xheWVyOiBNaWNyb3NvZnQuTWFwcy5MYXllcikgeyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciAoZS5nLiBcImNsaWNrXCIpXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3B1c2hwaW4sIGV2ZW50VHlwZSwgKGUpID0+IHtcbiAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZU1hcmtlcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAgJiYgIXRoaXMuX2xheWVyKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAodGhpcy5fbGF5ZXIpIHsgdGhpcy5fbGF5ZXIucmVtb3ZlKHRoaXMuTmF0aXZlUHJpbWl0dmUpOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmVudGl0aWVzLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcmtlciBsYWJlbFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRMYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaHBpbi5nZXRUZXh0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgbWFya2VyIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNocGluLmdldFZpc2libGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbmNob3IgZm9yIHRoZSBtYXJrZXIuIFVzZSB0aGlzIHRvIGFkanVzdCB0aGUgcm9vdCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciB0byBhY2NvbW9kYXRlIHZhcmlvdXMgbWFya2VyIGltYWdlIHNpemVzLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGFuY2hvciAtIFBvaW50IGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIGFuY2hvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldEFuY2hvcihhbmNob3I6IElQb2ludCk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgPSB7fTtcbiAgICAgICAgby5hbmNob3IgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KTtcbiAgICAgICAgdGhpcy5fcHVzaHBpbi5zZXRPcHRpb25zKG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRyYWdnYWJpbGl0eSBvZiBhIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1hcmsgdGhlIG1hcmtlciBhcyBkcmFnZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XG4gICAgICAgIG8uZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaWNvbiBmb3IgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpY29uIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGljb24gaW4gdmFyaW91cyBmb3JtcyAodXJsLCBkYXRhIHVybCwgZXRjLilcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldEljb24oaWNvbjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xuICAgICAgICBvLmljb24gPSBpY29uO1xuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFya2VyIGxhYmVsLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxhYmVsIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGxhYmVsIHRvIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldExhYmVsKGxhYmVsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XG4gICAgICAgIG8udGV4dCA9IGxhYmVsO1xuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlbyBjb29yZGluYXRlcyB0byBzZXQgdGhlIG1hcmtlciBwb3NpdGlvbiB0by5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldFBvc2l0aW9uKGxhdExuZzogSUxhdExvbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcDogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24obGF0TG5nKTtcbiAgICAgICAgdGhpcy5fcHVzaHBpbi5zZXRMb2NhdGlvbihwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gdGl0bGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgdGl0bGUgdG8gc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgfCBhbnkgPSB7fTtcbiAgICAgICAgby50aXRsZSA9IHRpdGxlO1xuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFya2VyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTWFya2VyT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcmtlciBvcHRpb25zIHRvIHNldC4gVGhlIHN1cHBsaWVkIG9wdGlvbnMgYXJlXG4gICAgICogbWVyZ2VkIHdpdGggdGhlIHVuZGVybHlpbmcgbWFya2VyIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9ICBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcHVzaHBpbi5zZXRPcHRpb25zKG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIFRydWUgdG8gc2V0IHRoZSBtYXJrZXIgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zIHwgYW55ID0ge307XG4gICAgICAgIG8udmlzaWJsZSA9IHZpc2libGU7XG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0T3B0aW9ucyhvKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEJpbmdNYXJrZXIgfSBmcm9tICcuL2JpbmctbWFya2VyJztcbmltcG9ydCB7IFNwaWRlckNsdXN0ZXJNYXJrZXIgfSBmcm9tICcuLi9zcGlkZXItY2x1c3Rlci1tYXJrZXInO1xuXG5leHBvcnQgY2xhc3MgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgZXh0ZW5kcyBCaW5nTWFya2VyIGltcGxlbWVudHMgU3BpZGVyQ2x1c3Rlck1hcmtlciB7XG5cbiAgICAvKiogVGhlIHBhcmVudCBwdXNocGluIGluIHdoaWNoIHRoZSBzcGlkZXIgcHVzaHBpbiBpcyBkZXJpdmVkIGZyb20uICovXG4gICAgcHVibGljIFBhcmVudE1hcmtlcjogQmluZ01hcmtlcjtcblxuICAgIC8qKiBUaGUgc3RpY2sgdGhhdCBjb25uZWN0cyB0aGUgc3BpZGVyIHB1c2hwaW4gdG8gdGhlIGNsdXN0ZXIuICovXG4gICAgcHVibGljIFN0aWNrOiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZTtcblxufVxuIiwiaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcbmltcG9ydCB7IElTcGlkZXJDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXNwaWRlci1jbHVzdGVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21hcmtlcic7XG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vaW5mby13aW5kb3cnO1xuaW1wb3J0IHsgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgfSBmcm9tICcuL2Jpbmctc3BpZGVyLWNsdXN0ZXItbWFya2VyJztcbmltcG9ydCB7IEJpbmdNYXJrZXIgfSBmcm9tICcuL2JpbmctbWFya2VyJztcblxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNsdXN0ZXJpbmcgbGF5ZXIgZm9yIHRoZSBCaW5nIE1hcCBQcm92aWRlci5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5nQ2x1c3RlckxheWVyIGltcGxlbWVudHMgTGF5ZXIge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2lzQ2x1c3RlcmluZyA9IHRydWU7XG4gICAgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XG4gICAgcHJpdmF0ZSBfbWFya2VyTG9va3VwOiBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgTWFya2VyPiA9IG5ldyBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgTWFya2VyPigpO1xuICAgIHByaXZhdGUgX3BlbmRpbmdNYXJrZXJzOiBBcnJheTxNYXJrZXI+ID0gbmV3IEFycmF5PE1hcmtlcj4oKTtcbiAgICBwcml2YXRlIF9zcGlkZXJNYXJrZXJzOiBBcnJheTxCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlcj4gPSBuZXcgQXJyYXk8QmluZ1NwaWRlckNsdXN0ZXJNYXJrZXI+KCk7XG4gICAgcHJpdmF0ZSBfc3BpZGVyTWFya2VyTG9va3VwOiBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXI+ID1cbiAgICAgICAgICAgICAgICAgICAgIG5ldyBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXI+KCk7XG4gICAgcHJpdmF0ZSBfdXNlU3BpZGVyQ2x1c3RlciA9IGZhbHNlO1xuICAgIHByaXZhdGUgX21hcGNsaWNrcyA9IDA7XG4gICAgcHJpdmF0ZSBfc3BpZGVyTGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyO1xuICAgIHByaXZhdGUgX2V2ZW50czogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZD4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZD4oKTtcbiAgICBwcml2YXRlIF9jdXJyZW50Wm9vbSA9IDA7XG4gICAgcHJpdmF0ZSBfc3BpZGVyT3B0aW9uczogSVNwaWRlckNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICBjaXJjbGVTcGlyYWxTd2l0Y2hvdmVyOiA5LFxuICAgICAgICBjb2xsYXBzZUNsdXN0ZXJPbk1hcENoYW5nZTogZmFsc2UsXG4gICAgICAgIGNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2s6IDEsXG4gICAgICAgIGludm9rZUNsaWNrT25Ib3ZlcjogdHJ1ZSxcbiAgICAgICAgbWluQ2lyY2xlTGVuZ3RoOiA2MCxcbiAgICAgICAgbWluU3BpcmFsQW5nbGVTZXBlcmF0aW9uOiAyNSxcbiAgICAgICAgc3BpcmFsRGlzdGFuY2VGYWN0b3I6IDUsXG4gICAgICAgIHN0aWNrU3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgc3Ryb2tlVGhpY2tuZXNzOiAyXG4gICAgICAgIH0sXG4gICAgICAgIHN0aWNrSG92ZXJTdHlsZTogeyBzdHJva2VDb2xvcjogJ3JlZCcgfSxcbiAgICAgICAgbWFya2VyU2VsZWN0ZWQ6IG51bGwsXG4gICAgICAgIG1hcmtlclVuU2VsZWN0ZWQ6IG51bGxcbiAgICB9O1xuICAgIHByaXZhdGUgX2N1cnJlbnRDbHVzdGVyOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbiA9IG51bGw7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB1bmRlcm5lYXRoIHRoZSBhYnN0cmFjdGlvbiBsYXllci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBCaW5nQ2x1c3RlckxheWVyIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9sYXllciBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIuIE5hdGl2ZSBCaW5nIENsdXN0ZXIgTGF5ZXIgc3VwcG9ydGluZyB0aGUgY2x1c3RlciBsYXllci5cbiAgICAgKiBAcGFyYW0gX21hcHMgTWFwU2VydmljZS4gTWFwU2VydmljZSBpbXBsZW1lbnRhdGlvbiB0byBsZXZlcmFnZSBmb3IgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sYXllcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlckxheWVyLCBwcml2YXRlIF9tYXBzOiBNYXBTZXJ2aWNlKSB7IH1cblxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzLCBMYXllciBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgc3RyaW5nLiBUeXBlIG9mIGV2ZW50IHRvIGFkZCAoY2xpY2ssIG1vdXNlb3ZlciwgZXRjKS4gWW91IGNhbiB1c2UgYW55IGV2ZW50IHRoYXQgdGhlIHVuZGVybHlpbmcgbmF0aXZlXG4gICAgICogbGF5ZXIgc3VwcG9ydHMuXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9sYXllciwgZXZlbnRUeXBlLCAoZSkgPT4ge1xuICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gVXNlIHRoaXMgbWV0aG9kIHdpdGggY2F1dGlvbiBhcyBpdCB3aWxsXG4gICAgICogdHJpZ2dlciBhIHJlY2FsdWF0aW9uIG9mIHRoZSBjbHVzdGVycyAoYW5kIGFzc29jaWF0ZWQgbWFya2VycyBpZiBhcHByb3ByaXRlKSBmb3JcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIElmIHlvdSB1c2UgdGhpcyBtZXRob2QgdG8gYWRkIG1hbnkgbWFya2VycyB0byB0aGUgY2x1c3RlciwgdXNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlci4gRW50aXR5IHRvIGFkZCB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRFbnRpdHkoZW50aXR5OiBNYXJrZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGlzTWFya2VyOiBib29sZWFuID0gZW50aXR5IGluc3RhbmNlb2YgTWFya2VyO1xuICAgICAgICBpc01hcmtlciA9IGVudGl0eSBpbnN0YW5jZW9mIEJpbmdNYXJrZXIgfHwgaXNNYXJrZXI7XG4gICAgICAgIGlmIChpc01hcmtlcikge1xuICAgICAgICAgICAgaWYgKGVudGl0eS5Jc0ZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdG9wQ2x1c3RlcmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSB0aGlzLl9sYXllci5nZXRQdXNocGlucygpO1xuICAgICAgICAgICAgICAgIHAucHVzaChlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldFB1c2hwaW5zKHApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLnNldChlbnRpdHkuTmF0aXZlUHJpbWl0dmUsIGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5LklzTGFzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhcnRDbHVzdGVyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIG1hcmtlcnMgdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj4uIEVudGl0aWVzIHRvIGFkZCB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPik6IHZvaWQge1xuICAgICAgICBpZiAoZW50aXRpZXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGVudGl0aWVzKSAmJiBlbnRpdGllcy5sZW5ndGggIT09IDAgKSB7XG4gICAgICAgICAgICBjb25zdCBlOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPiA9IGVudGl0aWVzLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuc2V0KHAuTmF0aXZlUHJpbWl0dmUsIHApO1xuICAgICAgICAgICAgICAgIHJldHVybiBwLk5hdGl2ZVByaW1pdHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSB0aGlzLl9sYXllci5nZXRQdXNocGlucygpO1xuICAgICAgICAgICAgICAgIHAucHVzaCguLi5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5zZXRQdXNocGlucyhwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2goLi4uZW50aXRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBzcGlkZXIgYmVoYXZpb3IgZm9yIHRoZSBjbHVzZXJpbmcgbGF5ZXIgKHdoZW4gYSBjbHVzdGVyIG1ha2VyIGlzIGNsaWNrZWQsIGl0IGV4cGxvZGVzIGludG8gYSBzcGlkZXIgb2YgdGhlXG4gICAgICogaW5kaXZpZHVhbCB1bmRlcmx5aW5nIHBpbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMuIE9wdGlvbmFsLiBPcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIHNwaWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHVibGljIEluaXRpYWxpemVTcGlkZXJDbHVzdGVyU3VwcG9ydChvcHRpb25zPzogSVNwaWRlckNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl91c2VTcGlkZXJDbHVzdGVyKSB7IHJldHVybjsgfVxuICAgICAgICBjb25zdCBtOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcHMpLk1hcEluc3RhbmNlO1xuICAgICAgICB0aGlzLl91c2VTcGlkZXJDbHVzdGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3BpZGVyTGF5ZXIgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFpvb20gPSBtLmdldFpvb20oKTtcbiAgICAgICAgdGhpcy5TZXRTcGlkZXJPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBtLmxheWVycy5pbnNlcnQodGhpcy5fc3BpZGVyTGF5ZXIpO1xuXG4gICAgICAgIC8vL1xuICAgICAgICAvLy8gQWRkIHNwaWRlciByZWxhdGVkIGV2ZW50cy4uLi5cbiAgICAgICAgLy8vXG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG0sICdjbGljaycsIGUgPT4gdGhpcy5Pbk1hcENsaWNrKGUpKSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG0sICd2aWV3Y2hhbmdlc3RhcnQnLCBlID0+IHRoaXMuT25NYXBWaWV3Q2hhbmdlU3RhcnQoZSkpKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobSwgJ3ZpZXdjaGFuZ2VlbmQnLCBlID0+IHRoaXMuT25NYXBWaWV3Q2hhbmdlRW5kKGUpKSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX2xheWVyLCAnY2xpY2snLCBlID0+IHRoaXMuT25MYXllckNsaWNrKGUpKSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3NwaWRlckxheWVyLCAnY2xpY2snLCBlID0+IHRoaXMuT25MYXllckNsaWNrKGUpKSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3NwaWRlckxheWVyLCAnbW91c2VvdmVyJywgZSA9PiB0aGlzLk9uU3BpZGVyTW91c2VPdmVyKGUpKSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3NwaWRlckxheWVyLCAnbW91c2VvdXQnLCBlID0+IHRoaXMuT25TcGlkZXJNb3VzZU91dChlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGNsdXN0ZXJpbmcgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl91c2VTcGlkZXJDbHVzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgKDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBzKS5NYXBQcm9taXNlLnRoZW4obSA9PiB7XG4gICAgICAgICAgICAgICAgbS5sYXllcnMucmVtb3ZlKHRoaXMuX3NwaWRlckxheWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllciA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGUgPT4gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIoZSkpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnNwbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZVNwaWRlckNsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZSgwKTtcbiAgICAgICAgdGhpcy5fc3BpZGVyTWFya2Vycy5zcGxpY2UoMCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLnNwbGljZSgwKTtcbiAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hcHMuRGVsZXRlTGF5ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3QgbWFya2VyIHVzZWQgdG8gd3JhcCB0aGUgQmluZyBQdXNocGluLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTWFya2VyLiBUaGUgYWJzdHJhY3QgbWFya2VyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHB1c2hwaW4uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4pOiBNYXJrZXIge1xuICAgICAgICBjb25zdCBtOiBNYXJrZXIgPSB0aGlzLl9tYXJrZXJMb29rdXAuZ2V0KHBpbik7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9wdGlvbnMgZ292ZXJuaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJQ2x1c3Rlck9wdGlvbnMuIFRoZSBsYXllciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJQ2x1c3Rlck9wdGlvbnMge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyA9IHRoaXMuX2xheWVyLmdldE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICBncmlkU2l6ZTogby5ncmlkU2l6ZSxcbiAgICAgICAgICAgIGxheWVyT2Zmc2V0OiBvLmxheWVyT2Zmc2V0LFxuICAgICAgICAgICAgY2x1c3RlcmluZ0VuYWJsZWQ6IG8uY2x1c3RlcmluZ0VuYWJsZWQsXG4gICAgICAgICAgICBjYWxsYmFjazogby5jYWxsYmFjayxcbiAgICAgICAgICAgIGNsdXN0ZXJlZFBpbkNhbGxiYWNrOiBvLmNsdXN0ZXJlZFBpbkNhbGxiYWNrLFxuICAgICAgICAgICAgdmlzaWJsZTogby52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBvLnpJbmRleFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4uIFRydWUgaXMgdGhlIGxheWVyIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllci5nZXRPcHRpb25zKCkudmlzaWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBtYXJrZXIgdXNlZCB0byB3cmFwIHRoZSBCaW5nIFB1c2hwaW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBhYnN0cmFjdCBtYXJrZXIgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHVzaHBpbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHVibGljIEdldFNwaWRlck1hcmtlckZyb21CaW5nTWFya2VyKHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbik6IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyIHtcbiAgICAgICAgY29uc3QgbTogQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgPSB0aGlzLl9zcGlkZXJNYXJrZXJMb29rdXAuZ2V0KHBpbik7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlciAtIEVudGl0eSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgUmVtb3ZlRW50aXR5KGVudGl0eTogTWFya2VyKTogdm9pZCB7XG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBqOiBudW1iZXIgPSB0aGlzLl9tYXJrZXJzLmluZGV4T2YoZW50aXR5KTtcbiAgICAgICAgICAgIGNvbnN0IGs6IG51bWJlciA9IHRoaXMuX3BlbmRpbmdNYXJrZXJzLmluZGV4T2YoZW50aXR5KTtcbiAgICAgICAgICAgIGlmIChqID4gLTEpIHsgdGhpcy5fbWFya2Vycy5zcGxpY2UoaiwgMSk7IH1cbiAgICAgICAgICAgIGlmIChrID4gLTEpIHsgdGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKGssIDEpOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSB0aGlzLl9sYXllci5nZXRQdXNocGlucygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGk6IG51bWJlciA9IHAuaW5kZXhPZihlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldFB1c2hwaW5zKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5kZWxldGUoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRpdGllcyBBcnJheTxNYXJrZXI+IGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLiBUaGlzIHJlcGxhY2VzIGFueSBleGlzdGluZyBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHVibGljIFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+KCk7XG4gICAgICAgIHRoaXMuX21hcmtlcnMuc3BsaWNlKDApO1xuICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuY2xlYXIoKTtcbiAgICAgICAgZW50aXRpZXMuZm9yRWFjaCgoZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2Vycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQoZS5OYXRpdmVQcmltaXR2ZSwgZSk7XG4gICAgICAgICAgICAgICAgcC5wdXNoKDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHVzaHBpbnMocCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJQ2x1c3Rlck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXG4gICAgICogYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0L2V4aXN0aW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVDbHVzdGVyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0T3B0aW9ucyhvKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3BpZGVyQ2x1c3Rlck9wdGlvbnMpIHsgdGhpcy5TZXRTcGlkZXJPcHRpb25zKG9wdGlvbnMuc3BpZGVyQ2x1c3Rlck9wdGlvbnMpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY2x1c3RlciBsYXllciB2aXNpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklDbHVzdGVyTGF5ZXJPcHRpb25zID0gdGhpcy5fbGF5ZXIuZ2V0T3B0aW9ucygpO1xuICAgICAgICBvLnZpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICB0aGlzLl9sYXllci5zZXRPcHRpb25zKG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcbiAgICAgKiBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXG4gICAgICogQXMgc3VjaCwgU3RvcENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgYWRkaW5nIG1hbnkgZW50aXRpZXMgYW5kIFN0YXJ0Q2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIG9uY2UgYWRkaW5nIGlzXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU3RhcnRDbHVzdGVyaW5nKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+KCk7XG4gICAgICAgIHRoaXMuX21hcmtlcnMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgIGlmIChlLk5hdGl2ZVByaW1pdHZlICYmIGUuTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBwLnB1c2goPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ZS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHAucHVzaCg8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVyLnNldFB1c2hwaW5zKHApO1xuICAgICAgICB0aGlzLl9tYXJrZXJzID0gdGhpcy5fbWFya2Vycy5jb25jYXQodGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApKTtcbiAgICAgICAgdGhpcy5faXNDbHVzdGVyaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGFzIGFkZGluZyBhbiBlbnRpdGl5IHdpbGwgcmVjYWxjdWxhdGUgYWxsIGNsdXN0ZXJzLlxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHVibGljIFN0b3BDbHVzdGVyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5faXNDbHVzdGVyaW5nID0gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiBhIHB1c2hwaW5zIGJhc2ljIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGluIFB1c2hwaW4gdG8gY29weSBvcHRpb25zIGZyb20uXG4gICAgICogQHJldHVybnMgLSBBIGNvcHkgb2YgYSBwdXNocGlucyBiYXNpYyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIEdldEJhc2ljUHVzaHBpbk9wdGlvbnMocGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluKTogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zIHtcbiAgICAgICAgcmV0dXJuIDxNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnM+e1xuICAgICAgICAgICAgYW5jaG9yOiBwaW4uZ2V0QW5jaG9yKCksXG4gICAgICAgICAgICBjb2xvcjogcGluLmdldENvbG9yKCksXG4gICAgICAgICAgICBjdXJzb3I6IHBpbi5nZXRDdXJzb3IoKSxcbiAgICAgICAgICAgIGljb246IHBpbi5nZXRJY29uKCksXG4gICAgICAgICAgICByb3VuZENsaWNrYWJsZUFyZWE6IHBpbi5nZXRSb3VuZENsaWNrYWJsZUFyZWEoKSxcbiAgICAgICAgICAgIHN1YlRpdGxlOiBwaW4uZ2V0U3ViVGl0bGUoKSxcbiAgICAgICAgICAgIHRleHQ6IHBpbi5nZXRUZXh0KCksXG4gICAgICAgICAgICB0ZXh0T2Zmc2V0OiBwaW4uZ2V0VGV4dE9mZnNldCgpLFxuICAgICAgICAgICAgdGl0bGU6IHBpbi5nZXRUaXRsZSgpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHNwaWRlciBjbHVzdGVyIGFuZCByZXNvdHJlcyB0aGUgb3JpZ2luYWwgcGluLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIEhpZGVTcGlkZXJDbHVzdGVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9tYXBjbGlja3MgPSAwO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudENsdXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NwaWRlckxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJzLnNwbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX3NwaWRlck1hcmtlckxvb2t1cC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudENsdXN0ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbWFwY2xpY2tzID0gLTE7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3BpZGVyT3B0aW9ucy5tYXJrZXJVblNlbGVjdGVkKSB7IHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyVW5TZWxlY3RlZCgpOyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBldmVudCBoYW5kbGVyIGZvciB3aGVuIGEgc2hhcGUgaW4gdGhlIGNsdXN0ZXIgbGF5ZXIgaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlIFRoZSBtb3VzZSBldmVudCBhcmd1cm1lbnQgZnJvbSB0aGUgY2xpY2sgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHByaXZhdGUgT25MYXllckNsaWNrKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xuICAgICAgICBpZiAoZS5wcmltaXRpdmUgaW5zdGFuY2VvZiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbikge1xuICAgICAgICAgICAgY29uc3QgY3A6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluID0gPE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluPmUucHJpbWl0aXZlO1xuICAgICAgICAgICAgY29uc3Qgc2hvd05ld0NsdXN0ZXI6IGJvb2xlYW4gPSBjcCAhPT0gdGhpcy5fY3VycmVudENsdXN0ZXI7XG4gICAgICAgICAgICB0aGlzLkhpZGVTcGlkZXJDbHVzdGVyKCk7XG4gICAgICAgICAgICBpZiAoc2hvd05ld0NsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlNob3dTcGlkZXJDbHVzdGVyKDxNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbj5lLnByaW1pdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLnByaW1pdGl2ZTtcbiAgICAgICAgICAgIGlmIChwaW4ubWV0YWRhdGEgJiYgcGluLm1ldGFkYXRhLmlzQ2x1c3Rlck1hcmtlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG06IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gdGhpcy5HZXRTcGlkZXJNYXJrZXJGcm9tQmluZ01hcmtlcihwaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHA6IEJpbmdNYXJrZXIgPSBtLlBhcmVudE1hcmtlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBwcGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gcC5OYXRpdmVQcmltaXR2ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3BpZGVyT3B0aW9ucy5tYXJrZXJTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclNlbGVjdGVkKHAsIG5ldyBCaW5nTWFya2VyKHRoaXMuX2N1cnJlbnRDbHVzdGVyLCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNaWNyb3NvZnQuTWFwcy5FdmVudHMuaGFzSGFuZGxlcihwcGluLCAnY2xpY2snKSkgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMuaW52b2tlKHBwaW4sICdjbGljaycsIGUpOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwY2xpY2tzID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyU2VsZWN0ZWQpIHsgdGhpcy5fc3BpZGVyT3B0aW9ucy5tYXJrZXJTZWxlY3RlZCh0aGlzLkdldE1hcmtlckZyb21CaW5nTWFya2VyKHBpbiksIG51bGwpOyB9XG4gICAgICAgICAgICAgICAgaWYgKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5oYXNIYW5kbGVyKHBpbiwgJ2NsaWNrJykpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmludm9rZShwaW4sICdjbGljaycsIGUpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIG1hcCAob3V0c2lkZSBhIHNwaWRlciBjbHVzdGVyKS4gRGVwZW5kaW5nIG9uIHRoZVxuICAgICAqIHNwaWRlciBvcHRpb25zLCBjbG9zZXMgdGhlIGNsdXN0ZXIgb3IgaW5jcmVtZW50cyB0aGUgY2xpY2sgY291bnRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBPbk1hcENsaWNrKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyB8IE1pY3Jvc29mdC5NYXBzLklNYXBUeXBlQ2hhbmdlRXZlbnRBcmdzKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9tYXBjbGlja3MgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoKyt0aGlzLl9tYXBjbGlja3MgPj0gdGhpcy5fc3BpZGVyT3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk50aENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLkhpZGVTcGlkZXJDbHVzdGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nIGFzIHRoaXMuX21hcGNsaWNrcyBoYXMgYWxyZWFkeSBiZWVuIGluY3JlbWVudGVkIGFib3ZlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIHZpZXcgY2hhbmdlZCBlbmQgZXZlbnQuIEhpZGVzIHRoZSBzcGlkZXIgY2x1c3RlciBpZiB0aGUgem9vbSBsZXZlbCBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHByaXZhdGUgT25NYXBWaWV3Q2hhbmdlRW5kKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyB8IE1pY3Jvc29mdC5NYXBzLklNYXBUeXBlQ2hhbmdlRXZlbnRBcmdzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHo6IG51bWJlciA9ICg8TWljcm9zb2Z0Lk1hcHMuTWFwPmUudGFyZ2V0KS5nZXRab29tKCk7XG4gICAgICAgIGNvbnN0IGhhc1pvb21DaGFuZ2VkOiBib29sZWFuID0gKHogIT09IHRoaXMuX2N1cnJlbnRab29tKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFpvb20gPSB6O1xuICAgICAgICBpZiAoaGFzWm9vbUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuSGlkZVNwaWRlckNsdXN0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIGhhbmRsaW5nIHRoZSBtYXAgdmlldyBjaGFuZ2Ugc3RhcnQgZXZlbnQuIERlcGVuZGluZyBvbiB0aGUgc3BpZGVyIG9wdGlvbnMsIGhpZGVzIHRoZVxuICAgICAqIHRoZSBleHBsb2RlZCBzcGlkZXIgb3IgZG9lcyBub3RoaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBPbk1hcFZpZXdDaGFuZ2VTdGFydChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MgfCBNaWNyb3NvZnQuTWFwcy5JTWFwVHlwZUNoYW5nZUV2ZW50QXJncyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc3BpZGVyT3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk1hcENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5IaWRlU3BpZGVyQ2x1c3RlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgaW52b2tlZCBvbiBtb3VzZSBvdXQgb24gYW4gZXhwbG9kZWQgc3BpZGVyIG1hcmtlci4gUmVzZXRzIHRoZSBob3ZlciBzdHlsZSBvbiB0aGUgc3RpY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZSAtIE1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgT25TcGlkZXJNb3VzZU91dChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ZS5wcmltaXRpdmU7XG4gICAgICAgIGlmIChwaW4gaW5zdGFuY2VvZiBNaWNyb3NvZnQuTWFwcy5QdXNocGluICYmIHBpbi5tZXRhZGF0YSAmJiBwaW4ubWV0YWRhdGEuaXNDbHVzdGVyTWFya2VyKSB7XG4gICAgICAgICAgICBjb25zdCBtOiBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciA9IHRoaXMuR2V0U3BpZGVyTWFya2VyRnJvbUJpbmdNYXJrZXIocGluKTtcbiAgICAgICAgICAgIG0uU3RpY2suc2V0T3B0aW9ucyh0aGlzLl9zcGlkZXJPcHRpb25zLnN0aWNrU3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSBvdmVyIG9uIGFuIGV4cGxvZGVkIHNwaWRlciBtYXJrZXIuIFNldHMgdGhlIGhvdmVyIHN0eWxlIG9uIHRoZSBzdGljay4gQWxzbyBpbnZva2VzIHRoZSBjbGljayBldmVudFxuICAgICAqIG9uIHRoZSB1bmRlcmx5aW5nIG9yaWdpbmFsIG1hcmtlciBkZXBlbmRlbnQgb24gdGhlIHNwaWRlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlIE9uU3BpZGVyTW91c2VPdmVyKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xuICAgICAgICBjb25zdCBwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLnByaW1pdGl2ZTtcbiAgICAgICAgaWYgKHBpbiBpbnN0YW5jZW9mIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gJiYgcGluLm1ldGFkYXRhICYmIHBpbi5tZXRhZGF0YS5pc0NsdXN0ZXJNYXJrZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG06IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gdGhpcy5HZXRTcGlkZXJNYXJrZXJGcm9tQmluZ01hcmtlcihwaW4pO1xuICAgICAgICAgICAgbS5TdGljay5zZXRPcHRpb25zKHRoaXMuX3NwaWRlck9wdGlvbnMuc3RpY2tIb3ZlclN0eWxlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGlkZXJPcHRpb25zLmludm9rZUNsaWNrT25Ib3Zlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHA6IEJpbmdNYXJrZXIgPSBtLlBhcmVudE1hcmtlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBwcGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gcC5OYXRpdmVQcmltaXR2ZTtcbiAgICAgICAgICAgICAgICBpZiAoTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmhhc0hhbmRsZXIocHBpbiwgJ2NsaWNrJykpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmludm9rZShwcGluLCAnY2xpY2snLCBlKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3Igc3BpZGVyIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgSVNwaWRlckNsdXN0ZXJPcHRpb25zIGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgZW51bWVyYXRpb24gY29udHJvbGxpbmcgdGhlIHNwaWRlciBjbHVzdGVyIGJlaGF2aW9yLiBUaGUgc3VwcGxpZWQgb3B0aW9uc1xuICAgICAqIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdC9leGlzdGluZyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIFNldFNwaWRlck9wdGlvbnMob3B0aW9uczogSVNwaWRlckNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2lyY2xlU3BpcmFsU3dpdGNob3ZlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXIgPSBvcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29sbGFwc2VDbHVzdGVyT25NYXBDaGFuZ2UgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMuY29sbGFwc2VDbHVzdGVyT25NYXBDaGFuZ2UgPSBvcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTWFwQ2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk50aENsaWNrID0gb3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk50aENsaWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmludm9rZUNsaWNrT25Ib3ZlciA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5pbnZva2VDbGlja09uSG92ZXIgPSBvcHRpb25zLmludm9rZUNsaWNrT25Ib3ZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5taW5TcGlyYWxBbmdsZVNlcGVyYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5TcGlyYWxBbmdsZVNlcGVyYXRpb24gPSBvcHRpb25zLm1pblNwaXJhbEFuZ2xlU2VwZXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLnNwaXJhbERpc3RhbmNlRmFjdG9yID0gb3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5taW5DaXJjbGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5DaXJjbGVMZW5ndGggPSBvcHRpb25zLm1pbkNpcmNsZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0aWNrSG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMuc3RpY2tIb3ZlclN0eWxlID0gb3B0aW9ucy5zdGlja0hvdmVyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGlja1N0eWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5zdGlja1N0eWxlID0gb3B0aW9ucy5zdGlja1N0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFya2VyU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclNlbGVjdGVkID0gb3B0aW9ucy5tYXJrZXJTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQgPSBvcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlzaWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy52aXNpYmxlID0gb3B0aW9ucy52aXNpYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TZXRPcHRpb25zKDxJQ2x1c3Rlck9wdGlvbnM+b3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGEgY2x1c3RlciBpbnRvIGl0J3Mgb3BlbiBzcGlkZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsdXN0ZXIgVGhlIGNsdXN0ZXIgdG8gc2hvdyBpbiBpdCdzIG9wZW4gc3BpZGVyIGxheW91dC4uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxuICAgICAqL1xuICAgIHByaXZhdGUgU2hvd1NwaWRlckNsdXN0ZXIoY2x1c3RlcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5IaWRlU3BpZGVyQ2x1c3RlcigpO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2x1c3RlciA9IGNsdXN0ZXI7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXIgJiYgY2x1c3Rlci5jb250YWluZWRQdXNocGlucykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNwaWRlciBkYXRhLlxuICAgICAgICAgICAgY29uc3QgbTogTWljcm9zb2Z0Lk1hcHMuTWFwID0gKDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBzKS5NYXBJbnN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IHBpbnM6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gY2x1c3Rlci5jb250YWluZWRQdXNocGlucztcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlcjogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBjbHVzdGVyLmdldExvY2F0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJQb2ludDogTWljcm9zb2Z0Lk1hcHMuUG9pbnQgPVxuICAgICAgICAgICAgICAgIDxNaWNyb3NvZnQuTWFwcy5Qb2ludD5tLnRyeUxvY2F0aW9uVG9QaXhlbChjZW50ZXIsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xuICAgICAgICAgICAgbGV0IHN0aWNrOiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZTtcbiAgICAgICAgICAgIGxldCBhbmdsZSA9IDA7XG4gICAgICAgICAgICBjb25zdCBtYWtlU3BpcmFsOiBib29sZWFuID0gcGlucy5sZW5ndGggPiB0aGlzLl9zcGlkZXJPcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXI7XG4gICAgICAgICAgICBsZXQgbGVnUGl4ZWxMZW5ndGg6IG51bWJlcjtcbiAgICAgICAgICAgIGxldCBzdGVwQW5nbGU6IG51bWJlcjtcbiAgICAgICAgICAgIGxldCBzdGVwTGVuZ3RoOiBudW1iZXI7XG5cbiAgICAgICAgICAgIGlmIChtYWtlU3BpcmFsKSB7XG4gICAgICAgICAgICAgICAgbGVnUGl4ZWxMZW5ndGggPSB0aGlzLl9zcGlkZXJPcHRpb25zLm1pbkNpcmNsZUxlbmd0aCAvIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgc3RlcExlbmd0aCA9IDIgKiBNYXRoLlBJICogdGhpcy5fc3BpZGVyT3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ZXBBbmdsZSA9IDIgKiBNYXRoLlBJIC8gcGlucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGVnUGl4ZWxMZW5ndGggPSAodGhpcy5fc3BpZGVyT3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvciAvIHN0ZXBBbmdsZSAvIE1hdGguUEkgLyAyKSAqIHBpbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsZWdQaXhlbExlbmd0aCA8IHRoaXMuX3NwaWRlck9wdGlvbnMubWluQ2lyY2xlTGVuZ3RoKSB7IGxlZ1BpeGVsTGVuZ3RoID0gdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5DaXJjbGVMZW5ndGg7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBpbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3BpZGVyIHBpbiBsb2NhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoIW1ha2VTcGlyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBzdGVwQW5nbGUgKiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgKz0gdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5TcGlyYWxBbmdsZVNlcGVyYXRpb24gLyBsZWdQaXhlbExlbmd0aCArIGkgKiAwLjAwMDU7XG4gICAgICAgICAgICAgICAgICAgIGxlZ1BpeGVsTGVuZ3RoICs9IHN0ZXBMZW5ndGggLyBhbmdsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQ6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID1cbiAgICAgICAgICAgICAgICAgICAgbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KGNlbnRlclBvaW50LnggKyBsZWdQaXhlbExlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclBvaW50LnkgKyBsZWdQaXhlbExlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIDxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj5tLnRyeVBpeGVsVG9Mb2NhdGlvbihwb2ludCwgTWljcm9zb2Z0Lk1hcHMuUGl4ZWxSZWZlcmVuY2UuY29udHJvbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc3RpY2sgdG8gcGluLlxuICAgICAgICAgICAgICAgIHN0aWNrID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKFtjZW50ZXIsIGxvY10sIHRoaXMuX3NwaWRlck9wdGlvbnMuc3RpY2tTdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyTGF5ZXIuYWRkKHN0aWNrKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwaW4gaW4gc3BpcmFsIHRoYXQgY29udGFpbnMgc2FtZSBtZXRhZGF0YSBhcyBwYXJlbnQgcGluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IG5ldyBNaWNyb3NvZnQuTWFwcy5QdXNocGluKGxvYyk7XG4gICAgICAgICAgICAgICAgcGluLm1ldGFkYXRhID0gcGluc1tpXS5tZXRhZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICBwaW4ubWV0YWRhdGEuaXNDbHVzdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwaW4uc2V0T3B0aW9ucyh0aGlzLkdldEJhc2ljUHVzaHBpbk9wdGlvbnMocGluc1tpXSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlckxheWVyLmFkZChwaW4pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BpZGVyTWFya2VyOiBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciA9IG5ldyBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlcihwaW4sIG51bGwsIHRoaXMuX3NwaWRlckxheWVyKTtcbiAgICAgICAgICAgICAgICBzcGlkZXJNYXJrZXIuU3RpY2sgPSBzdGljaztcbiAgICAgICAgICAgICAgICBzcGlkZXJNYXJrZXIuUGFyZW50TWFya2VyID0gPEJpbmdNYXJrZXI+dGhpcy5HZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwaW5zW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJzLnB1c2goc3BpZGVyTWFya2VyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJMb29rdXAuc2V0KHBpbiwgc3BpZGVyTWFya2VyKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwY2xpY2tzID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBJbmZvV2luZG93fSBjb250cmFjdCBmb3IgdGhlIEJpbmcgTWFwcyBWOCBtYXAgYXJjaGl0ZWN0dXJlLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmdJbmZvV2luZG93IGltcGxlbWVudHMgSW5mb1dpbmRvdyB7XG5cbiAgICBwcml2YXRlIF9pc09wZW46IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGluZm8gYm94IGlzIGN1cnJlbnRseSBvcGVuLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XG4gICAgICovXG4gICAgcHVibGljIGdldCBJc09wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLl9pbmZvQm94ICYmIHRoaXMuX2luZm9Cb3guZ2V0T3B0aW9ucygpLnZpc2libGUgPT09IHRydWUpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbmF0aXZlIHByaW1pdHZlIHVuZGVybHlpbmcgdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XG4gICAgICogQHByb3BlcnR5XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBNaWNyb3NvZnQuTWFwcy5JbmZvYm94IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9Cb3g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nSW5mb1dpbmRvdy5cbiAgICAgKiBAcGFyYW0gX2luZm9Cb3ggLSBBIHtAbGluayBNaWNyb3NvZnQuTWFwcy5JbmZvYm94fSBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBtb2RlbFxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2luZm9Cb3g6IE1pY3Jvc29mdC5NYXBzLkluZm9ib3gpIHtcbiAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgSW5mb1dpbmRvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciAoZS5nLiBcImNsaWNrXCIpXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5faW5mb0JveCwgZXZlbnRUeXBlLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZXZlbnROYW1lID09PSAnaW5mb2JveENoYW5nZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3guZ2V0T3B0aW9ucygpLnZpc2libGUgPT09IHRydWUpIHsgdGhpcy5faXNPcGVuID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5mb0JveC5nZXRPcHRpb25zKCkudmlzaWJsZSA9PT0gZmFsc2UgJiYgdGhpcy5faXNPcGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIENsb3NlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMgPSB7fTtcbiAgICAgICAgby52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luZm9Cb3guc2V0T3B0aW9ucyhvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRQb3NpdGlvbigpOiBJTGF0TG9uZyB7XG4gICAgICAgIGNvbnN0IHA6IElMYXRMb25nID0ge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IHRoaXMuX2luZm9Cb3guZ2V0TG9jYXRpb24oKS5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogdGhpcy5faW5mb0JveC5nZXRMb2NhdGlvbigpLmxvbmdpdHVkZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIE9wZW4oKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94T3B0aW9ucyA9IHt9O1xuICAgICAgICBvLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbmZvQm94LnNldE9wdGlvbnMobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5mbyB3aW5kb3cgb3B0aW9ucyB0byBzZXQuIFRoZSBvcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggYW55IGV4aXN0aW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94T3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVJbmZvQm94T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5mb0JveC5zZXRPcHRpb25zKG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gR2VvIGNvb3JkaW5hdGVzIHRvIG1vdmUgdGhlIGFuY2hvciBvZiB0aGUgaW5mbyB3aW5kb3cgdG8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIFNldFBvc2l0aW9uKHBvc2l0aW9uOiBJTGF0TG9uZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBsOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2luZm9Cb3guc2V0TG9jYXRpb24obCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSUxhYmVsT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhYmVsLW9wdGlvbnMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgaW1wbGVtZW50aW5nIGEgbGFiZWwgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAuXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXBMYWJlbCB7XG4vLyBleHBvcnQgY2xhc3MgTWFwTGFiZWwgZXh0ZW5kcyBNaWNyb3NvZnQuTWFwcy5DdXN0b21PdmVybGF5IHtcbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJvdGVjdGVkIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBsYWJlbCBzdHlsZSBmb3IgdGhlIHBsYXRmb3JtXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IERlZmF1bHRMYWJlbFN0eWxlKCk6IElMYWJlbE9wdGlvbnM7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWFwTGFiZWxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgICAgIHRoaXMuU2V0KCdmb250RmFtaWx5JywgJ3NhbnMtc2VyaWYnKTtcbiAgICAgICAgdGhpcy5TZXQoJ2ZvbnRTaXplJywgMTIpO1xuICAgICAgICB0aGlzLlNldCgnZm9udENvbG9yJywgJyNmZmZmZmYnKTtcbiAgICAgICAgdGhpcy5TZXQoJ3N0cm9rZVdlaWdodCcsIDQpO1xuICAgICAgICB0aGlzLlNldCgnc3Ryb2tlQ29sb3InLCAnIzAwMDAwMCcpO1xuICAgICAgICB0aGlzLlNldCgnYWxpZ24nLCAnY2VudGVyJyk7XG4gICAgICAgIHRoaXMuU2V0VmFsdWVzKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgbGFiZWwgZnJvbSB0aGUgbWFwLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBhdHVhbGx5IGRlbGV0ZSB0aGUgbGFiZWwgaXRzZWxmLCBzb1xuICAgICAqIGl0IGNhbiBiZSByZWFkZGVkIHRvIG1hcCBsYXRlci5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5TZXRNYXAobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgY2FsbGVkIHdoZW4gdW5kZXJseWluZyBwcm9wZXJ0aWVzIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wIC0gVGhlIHByb3BlcnR5IG9yIHByb3BlcnRpZXMgdGhhdCBoYXZlIGNoYW5nZWQuXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBDaGFuZ2VkKHByb3A6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHNob3VsZFJ1bkRyYXdDYW52YXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNob3VsZFJ1bkRyYXcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3ApKSB7IHByb3AgPSBbcHJvcF07IH1cbiAgICAgICAgcHJvcC5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9udEZhbWlseSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9udFNpemUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvbnRDb2xvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb2tlV2VpZ2h0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJva2VDb2xvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSdW5EcmF3Q2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWF4Wm9vbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbWluWm9vbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnb2Zmc2V0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUnVuRHJhdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNob3VsZFJ1bkRyYXdDYW52YXMpIHsgdGhpcy5EcmF3Q2FudmFzKCk7IH1cbiAgICAgICAgaWYgKHNob3VsZFJ1bkRyYXcpIHsgdGhpcy5EcmF3KCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHNwZWNpZnlpbmcgdGhlIHNldHRpbmcuXG4gICAgICogQHJldHVybnMgLSBUaGUgdmFsdWUgb2YgdGhlIHNldHRpbmcuXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXQoa2V5OiBzdHJpbmcpOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBIG5hdGl2ZSBtYXAgb2JqZWN0IGZvciB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gSW1wbGVtZW50aW5nIGRlcml2YXRpdmVzIHNob3VsZCByZXR1cm4gdGhlXG4gICAgICogYWN0dWFsIG5hdGl2ZSBvYmplY3QuXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRNYXAoKTogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBzcGVjaWZ5aW5nIHRoZSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0KGtleTogc3RyaW5nLCB2YWw6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIEEgbmF0aXZlIG1hcCBvYmplY3QgZm9yIHRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uLiBJbXBsZW1lbnRpbmcgZGVyaXZhdGl2ZXMgc2hvdWxkIHJldHVybiB0aGVcbiAgICAgKiBhY3R1YWwgbmF0aXZlIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldE1hcChtYXA6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHNldHRpbmdzIHRvIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldHRpbmdzIGtleSB2YWx1ZSBwYWlycy5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFNldFZhbHVlcyhvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZDtcblxuICAgIC8vL1xuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYWJlbC4gVmlzaWJpbGl0eSBkZXBlbmRzIG9uIFpvb20gc2V0dGluZ3MuXG4gICAgICogQHJldHVybnMgLSBibGFuayBzdHJpbmcgaWYgdmlzaWJsZSwgJ2hpZGRlbicgaWYgaW52aXNpYmxlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgR2V0VmlzaWJsZSgpIHtcbiAgICAgICAgY29uc3QgbWluWm9vbTogbnVtYmVyID0gdGhpcy5HZXQoJ21pblpvb20nKTtcbiAgICAgICAgY29uc3QgbWF4Wm9vbTogbnVtYmVyID0gdGhpcy5HZXQoJ21heFpvb20nKTtcbiAgICAgICAgY29uc3QgaGlkZGVuOiBib29sZWFuID0gdGhpcy5HZXQoJ2hpZGRlbicpO1xuXG4gICAgICAgIGlmIChoaWRkZW4pIHtyZXR1cm4gJ2hpZGRlbic7IH1cbiAgICAgICAgaWYgKG1pblpvb20gPT09IHVuZGVmaW5lZCAmJiBtYXhab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuICcnOyB9XG4gICAgICAgIGlmICghdGhpcy5HZXRNYXAoKSkgeyByZXR1cm4gJyc7IH1cblxuICAgICAgICBjb25zdCBtYXBab29tOiBudW1iZXIgPSB0aGlzLkdldE1hcCgpLmdldFpvb20oKTtcbiAgICAgICAgaWYgKG1hcFpvb20gPCBtaW5ab29tIHx8IG1hcFpvb20gPiBtYXhab29tKSB7IHJldHVybiAnaGlkZGVuJzsgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIG9uIHRoZSBtYXAuXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgRHJhdygpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIHRvIHRoZSBjYW52YXMgMmQgY29udGV4dC5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBEcmF3Q2FudmFzICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgY29uc3Qgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB0aGlzLl9jYW52YXMuc3R5bGU7XG4gICAgICAgIHN0eWxlLnpJbmRleCA9IHRoaXMuR2V0KCd6SW5kZXgnKTtcblxuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuR2V0KCdzdHJva2VDb2xvcicpO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuR2V0KCdmb250U2l6ZScpICsgJ3B4ICcgKyB0aGlzLkdldCgnZm9udEZhbWlseScpO1xuXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvcjogc3RyaW5nID0gdGhpcy5HZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBjb25zdCBzdHJva2VXZWlnaHQ6IG51bWJlciA9IE51bWJlcih0aGlzLkdldCgnc3Ryb2tlV2VpZ2h0JykpO1xuICAgICAgICBjb25zdCB0ZXh0OiBzdHJpbmcgPSB0aGlzLkdldCgndGV4dCcpO1xuICAgICAgICBjb25zdCB0ZXh0TWVhc3VyZTogVGV4dE1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aDogbnVtYmVyID0gdGV4dE1lYXN1cmUud2lkdGg7XG4gICAgICAgIGlmICh0ZXh0ICYmIHN0cm9rZVdlaWdodCAmJiBzdHJva2VXZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdlaWdodDtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCA0LCA0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yICYmIGJhY2tncm91bmRDb2xvciAhPT0gJycpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGV4dFdpZHRoICsgOCwgKHBhcnNlSW50KGN0eC5mb250LCAxMCkgKiAyKSAtIDIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLkdldCgnZm9udENvbG9yJyk7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCA0LCA0KTtcblxuICAgICAgICBzdHlsZS5tYXJnaW5MZWZ0ID0gdGhpcy5HZXRNYXJnaW5MZWZ0KHRleHRXaWR0aCkgKyAncHgnO1xuICAgICAgICBzdHlsZS5tYXJnaW5Ub3AgPSAnLTAuNGVtJztcbiAgICAgICAgc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIC8vIEJyaW5nIGFjdHVhbCB0ZXh0IHRvcCBpbiBsaW5lIHdpdGggZGVzaXJlZCBsYXRpdHVkZS5cbiAgICAgICAgICAgIC8vIENoZWFwZXIgdGhhbiBjYWxjdWxhdGluZyBoZWlnaHQgb2YgdGV4dC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBtYXJnaW4tbGVmdCBmb3IgdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gdGV4dFdpZHRoICAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dCwgaW4gcGl4ZWxzLlxuICAgICAqIEByZXR1cm5zIC0gVGhlIG1hcmdpbi1sZWZ0LCBpbiBwaXhlbHMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgR2V0TWFyZ2luTGVmdCh0ZXh0V2lkdGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5HZXQoJ2FsaWduJykpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzogICByZXR1cm4gLXRleHRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dFdpZHRoIC8gLTI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgY2FsbGVkIHdoZW4gdGhlIGxhYmVsIGlzIGFkZGVkIHRvIHRoZSBtYXAuIEdlbmVyYXRlcyBhbmQgY29uZmlndXJlc1xuICAgICAqIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBPbkFkZCgpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGxhYmVsIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIE9uUmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzICYmIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jYW52YXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCJleHBvcnQgY2xhc3MgRXh0ZW5kZXIge1xuXG4gICAgcHJpdmF0ZSBfb2JqOiBhbnk7XG4gICAgcHJpdmF0ZSBfcHJvdG86IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKG9iajogYW55KSB7XG4gICAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgICAgdGhpcy5fcHJvdG8gPSBvYmoucHJvdG90eXBlO1xuICAgIH1cblxuICAgIEV4dGVuZChuZXdPYmo6IGFueSk6IEV4dGVuZGVyIHtcblxuICAgICAgICB0aGlzLlNldCgncHJvdG90eXBlJywgbmV3T2JqLCB0aGlzLl9vYmopO1xuXG4gICAgICAgIGZvciAoY29uc3QgeSBpbiB0aGlzLl9wcm90bykge1xuICAgICAgICAgICAgaWYgKCg8YW55PnRoaXMuX3Byb3RvKVt5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TZXQoeSwgKHRoaXMuX3Byb3RvKVt5XSwgKDxhbnk+dGhpcy5fb2JqLnByb3RvdHlwZSlbeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU2V0KHByb3BlcnR5OiBzdHJpbmcsIG5ld09iajogYW55LCBvYmo/OiBhbnkpOiBFeHRlbmRlciB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuX3Byb3RvO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIG5ld09iaik7XG4gICAgfVxuXG4gICAgTWFwKHByb3BlcnR5OiBzdHJpbmcsIG5ld1Byb3BlcnR5OiBzdHJpbmcpOiBFeHRlbmRlciB7XG4gICAgICAgIHRoaXMuU2V0KHByb3BlcnR5LCB0aGlzLl9wcm90b1tuZXdQcm9wZXJ0eV0sIHRoaXMuX29iai5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcbmltcG9ydCB7IElMYWJlbE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYWJlbC1vcHRpb25zJztcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbWFwLWxhYmVsJztcbmltcG9ydCB7IEV4dGVuZGVyIH0gZnJvbSAnLi4vZXh0ZW5kZXInO1xuXG5sZXQgaWQ6IG51bWJlciA9IDA7XG5cbi8qKlxuICogSW1wbGVtZW50cyBtYXAgYSBsYWJsZWQgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgQmluZ01hcExhYmVsIGV4dGVuZHMgTWFwTGFiZWwge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBsYWJlbCBzdHlsZSBmb3IgdGhlIHBsYXRmb3JtXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXG4gICAgICovXG4gICAgcHVibGljIGdldCBEZWZhdWx0TGFiZWxTdHlsZSgpOiBJTGFiZWxPcHRpb25zIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIGZvbnRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjMDAwMDAwJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNYXBMYWJlbFxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHByb3BlcnRpZXMgdG8gc2V0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcbiAgICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgMTI7XG4gICAgICAgIG9wdGlvbnMuZm9udENvbG9yID0gb3B0aW9ucy5mb250Q29sb3IgfHwgJyNmZmZmZmYnO1xuICAgICAgICBvcHRpb25zLnN0cm9rZVdlaWdodCA9IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0IHx8IDI7XG4gICAgICAgIG9wdGlvbnMuc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgICg8YW55PnRoaXMpLl9vcHRpb25zLmJlbmVhdGhMYWJlbHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZy5cbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBHZXQoa2V5OiBzdHJpbmcpOiBhbnkge1xuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcylba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TWFwKCk6IE1pY3Jvc29mdC5NYXBzLk1hcCB7XG4gICAgICAgIGlmICh0eXBlb2YgKDxhbnk+dGhpcykuZ2V0TWFwID09PSAnZnVuY3Rpb24nKSB7IHJldHVybiAoPGFueT50aGlzKS5nZXRNYXAoKTsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHNwZWNpZnlpbmcgdGhlIHNldHRpbmcuXG4gICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0KGtleTogc3RyaW5nLCB2YWw6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nICYmICF2YWwuaGFzT3duUHJvcGVydHkoJ2FsdGl0dWRlJykgJiYgdmFsLmhhc093blByb3BlcnR5KCdsYXRpdHVkZScpICYmIHZhbC5oYXNPd25Qcm9wZXJ0eSgnbG9uZ2l0dWRlJykpIHtcbiAgICAgICAgICAgIHZhbCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih2YWwubGF0aXR1ZGUsIHZhbC5sb25naXR1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkdldChrZXkpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMpW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLkNoYW5nZWQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBmb3IgdGhlIGxhYmVsLiBTZXR0aW5ncyB0aGlzIHRvIG51bGwgcmVtb3ZlIHRoZSBsYWJlbCBmcm9tIGh0ZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0gTWFwIHRvIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGFiZWwuXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0TWFwKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG06IE1pY3Jvc29mdC5NYXBzLk1hcCA9IHRoaXMuR2V0TWFwKCk7XG4gICAgICAgIGlmIChtYXAgPT09IG0pIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBtLmxheWVycy5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXAubGF5ZXJzLmluc2VydCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc2V0dGluZ3MgdG8gdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2V0dGluZ3Mga2V5IHZhbHVlIHBhaXJzLlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIFNldFZhbHVlcyhvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PHN0cmluZz4gPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgJiYgIW9wdGlvbnNba2V5XS5oYXNPd25Qcm9wZXJ0eSgnYWx0aXR1ZGUnKSAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0uaGFzT3duUHJvcGVydHkoJ2xhdGl0dWRlJykgJiYgb3B0aW9uc1trZXldLmhhc093blByb3BlcnR5KCdsb25naXR1ZGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24ob3B0aW9uc1trZXldLmxhdGl0dWRlLCBvcHRpb25zW2tleV0ubG9uZ2l0dWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuR2V0KGtleSkgIT09IG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAoPGFueT50aGlzKVtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAubGVuZ3RoID4gMCkgeyB0aGlzLkNoYW5nZWQocCk7IH1cbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBsYWJlbCBvbiB0aGUgbWFwLlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBEcmF3KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB2aXNpYmlsaXR5OiBzdHJpbmcgPSB0aGlzLkdldFZpc2libGUoKTtcbiAgICAgICAgY29uc3QgbTogTWljcm9zb2Z0Lk1hcHMuTWFwID0gdGhpcy5HZXRNYXAoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmICghbSkgeyByZXR1cm47IH1cbiAgICAgICAgY29uc3Qgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB0aGlzLl9jYW52YXMuc3R5bGU7XG4gICAgICAgIGlmICh2aXNpYmlsaXR5ICE9PSAnJykge1xuICAgICAgICAgICAgLy8gbGFiZWwgaXMgbm90IHZpc2libGUsIGRvbid0IGNhbGN1bGF0ZSBwb3NpdGlvbnMgZXRjLlxuICAgICAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXSA9IHZpc2liaWxpdHk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0OiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9IHRoaXMuR2V0KCdvZmZzZXQnKTtcbiAgICAgICAgY29uc3QgbGF0TG5nOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IHRoaXMuR2V0KCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoIWxhdExuZykgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKCFvZmZzZXQpIHsgb2Zmc2V0ID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KDAsIDApOyB9XG5cbiAgICAgICAgY29uc3QgcG9zOiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9IDxNaWNyb3NvZnQuTWFwcy5Qb2ludD5tLnRyeUxvY2F0aW9uVG9QaXhlbChcbiAgICAgICAgICAgIGxhdExuZyxcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xuICAgICAgICBzdHlsZVsndG9wJ10gPSAocG9zLnkgKyBvZmZzZXQueSkgKyAncHgnO1xuICAgICAgICBzdHlsZVsnbGVmdCddID0gKHBvcy54ICsgb2Zmc2V0LngpICsgJ3B4JztcbiAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXSA9IHZpc2liaWxpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgY2FsbGVkIHdoZW4gdGhlIGxhYmVsIGlzIGFkZGVkIHRvIHRoZSBtYXAuIEdlbmVyYXRlcyBhbmQgY29uZmlndXJlc1xuICAgICAqIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgT25BZGQoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLl9jYW52YXMuaWQgPSBgeE1hcExhYmVsJHtpZCsrfWA7XG4gICAgICAgIGNvbnN0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gdGhpcy5fY2FudmFzLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG4gICAgICAgICg8YW55PnRoaXMpLnNldEh0bWxFbGVtZW50KHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgY2FsbGxlZCB3aGVuIHRoZSBsYWJlbCBpcyBsb2FkZWRcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHByaXZhdGUgT25Mb2FkKCkge1xuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLkdldE1hcCgpLCAndmlld2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuQ2hhbmdlZCgncG9zaXRpb24nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuRHJhd0NhbnZhcygpO1xuICAgICAgICB0aGlzLkRyYXcoKTtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGV4dGVuZCB0aGUgQ3VzdG9tT3ZlcmxheSBpbnRvIHRoZSBNYXBMYWJlbFxuICpcbiAqIEBleHBvcnRcbiAqIEBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcoKSB7XG4gICAgbmV3IEV4dGVuZGVyKEJpbmdNYXBMYWJlbClcbiAgICAuRXh0ZW5kKG5ldyBNaWNyb3NvZnQuTWFwcy5DdXN0b21PdmVybGF5KCkpXG4gICAgLk1hcCgnb25BZGQnLCAnT25BZGQnKVxuICAgIC5NYXAoJ29uTG9hZCcsICdPbkxvYWQnKVxuICAgIC5NYXAoJ29uUmVtb3ZlJywgJ09uUmVtb3ZlJyk7XG59XG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vcG9seWdvbic7XG5pbXBvcnQgeyBCaW5nTWFwTGFiZWwgfSBmcm9tICcuL2JpbmctbGFiZWwnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIGZvciBhIHBvbHlnb24gbW9kZWwgZm9yIEJpbmcgTWFwcyBWOC5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5nUG9seWdvbiBleHRlbmRzIFBvbHlnb24gaW1wbGVtZW50cyBQb2x5Z29uIHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcml2YXRlIF9tYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfaXNFZGl0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3RpdGxlOiBzdHJpbmcgPSAnJztcbiAgICBwcml2YXRlIF9tYXhab29tOiBudW1iZXIgPSAtMTtcbiAgICBwcml2YXRlIF9taW5ab29tOiBudW1iZXIgPSAtMTtcbiAgICBwcml2YXRlIF9zaG93TGFiZWw6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9zaG93VG9vbHRpcDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2xhYmVsOiBCaW5nTWFwTGFiZWwgPSBudWxsO1xuICAgIHByaXZhdGUgX3Rvb2x0aXA6IEJpbmdNYXBMYWJlbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfaGFzVG9vbFRpcFJlY2VpdmVyOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9tb3VzZU92ZXJMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcbiAgICBwcml2YXRlIF9tb3VzZU1vdmVMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcbiAgICBwcml2YXRlIF9tb3VzZU91dExpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICBwcml2YXRlIF9vcmlnaW5hbFBhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj47XG4gICAgcHJpdmF0ZSBfZWRpdGluZ0NvbXBsZXRlRW1pdHRlcjogKGV2ZW50OiBJUG9seWdvbkV2ZW50KSA9PiB2b2lkO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTGFiZWxNYXhab29tKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9XG4gICAgcHVibGljIHNldCBMYWJlbE1heFpvb20odmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHZhbDtcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQuIElnbm9yZWQgb3IgU2hvd0xhYmVsIGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IExhYmVsTWluWm9vbSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfVxuICAgIHB1YmxpYyBzZXQgTGFiZWxNaW5ab29tKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21pblpvb20gPSB2YWw7XG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+IHsgcmV0dXJuIHRoaXMuX21ldGFkYXRhOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBwb2x5Z29uLCBpbiB0aGlzIGNhc2Uge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlBvbHlnb259XG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24geyByZXR1cm4gdGhpcy5fcG9seWdvbjsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgU2hvd0xhYmVsKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd0xhYmVsOyB9XG4gICAgcHVibGljIHNldCBTaG93TGFiZWwodmFsOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3Nob3dMYWJlbCA9IHZhbDtcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIHRvb2x0aXBcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgU2hvd1Rvb2x0aXAoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93VG9vbHRpcDsgfVxuICAgIHB1YmxpYyBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwID0gdmFsO1xuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWdvblxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGdldCBUaXRsZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGl0bGU7IH1cbiAgICBwdWJsaWMgc2V0IFRpdGxlKHZhbDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3RpdGxlID0gdmFsO1xuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBjb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nUG9seWdvbi5cbiAgICAgKiBAcGFyYW0gX3BvbHlnb24gLSBUaGUge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlBvbHlnb259IHVuZGVybHlpbmcgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSBJbnN0YW5jZSBvZiB0aGUgTWFwIFNlcnZpY2UuXG4gICAgICogQHBhcmFtIF9sYXllciAtIFRoZSBjb250ZXh0IGxheWVyLlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9wb2x5Z29uOiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uLFxuICAgICAgICBwcm90ZWN0ZWQgX21hcFNlcnZpY2U6IEJpbmdNYXBTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgX2xheWVyOiBNaWNyb3NvZnQuTWFwcy5MYXllcixcbiAgICApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbWFwID0gdGhpcy5fbWFwU2VydmljZS5NYXBJbnN0YW5jZTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gdGhpcy5HZXRQYXRocygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG5cbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFdmVudHMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ2RyYWcnLCAnZHJhZ2VuZCcsICdkcmFnc3RhcnQnLCAnbW91c2Vkb3duJywgJ21vdXNlb3V0JywgJ21vdXNlb3ZlcicsICdtb3VzZXVwJ107XG4gICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHMuaW5kZXhPZihldmVudFR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWdvbiwgZXZlbnRUeXBlLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVySWQ6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wb2x5Z29uLCAnbW91c2VvdmVyJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcklkID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fbWFwLCAnbW91c2Vtb3ZlJywgbSA9PiBmbihtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3BvbHlnb24sICdtb3VzZW91dCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVySWQpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIoaGFuZGxlcklkKTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gaWYgKGV2ZW50VHlwZSA9PT0gJ3BhdGhjaGFuZ2VkJykge1xuICAgICAgICAgICAgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlciA9IDwoZXZlbnQ6IElQb2x5Z29uRXZlbnQpID0+IHZvaWQ+Zm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVkIHRoZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyKSB7IHRoaXMuX2xheWVyLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5lbnRpdGllcy5yZW1vdmUodGhpcy5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7IHRoaXMuX2xhYmVsLkRlbGV0ZSgpOyB9XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7IHRoaXMuX3Rvb2x0aXAuRGVsZXRlKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2dhYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICAvLy9cbiAgICAgICAgLy8vIEJpbmcgcG9seWdvbnMgYXJlIG5vdCBkcmFnZ2FibGUgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8vIFNlZSBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL1xuICAgICAgICAvLy8gICAgIDdhYWFlNzQ4LTRkNWYtNGJlNS1hN2JiLTkwNDk4ZTA4YjQxYy9ob3ctY2FuLWktbWFrZS1wb2x5Z29ucG9seWxpbmUtZHJhZ2dhYmxlLWluLWJpbmctbWFwcy04P1xuICAgICAgICAvLy8gICAgIGZvcnVtPWJpbmdtYXBzXG4gICAgICAgIC8vLyBmb3IgYSBwb3NzaWJsZSBhcHByb2FjaCB0byBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgbW9kZWwuXG4gICAgICAgIC8vL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIHBhdGggY2FuIGJlIGVkaXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0RWRpdGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VkaXRhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlnb24gcGF0aC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRQYXRoKCk6IEFycmF5PElMYXRMb25nPiB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IHRoaXMuX3BvbHlnb24uZ2V0TG9jYXRpb25zKCk7XG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcbiAgICAgICAgcC5mb3JFYWNoKGwgPT4gcGF0aC5wdXNoKHsgbGF0aXR1ZGU6IGwubGF0aXR1ZGUsIGxvbmdpdHVkZTogbC5sb25naXR1ZGUgfSkpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGhzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyBtdWx0aXBsZSBwb2x5Z29uIHBhdGhzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIEdldFBhdGhzKCk6IEFycmF5PEFycmF5PElMYXRMb25nPj4ge1xuICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gdGhpcy5fcG9seWdvbi5nZXRSaW5ncygpO1xuICAgICAgICBjb25zdCBwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IG5ldyBBcnJheTxBcnJheTxJTGF0TG9uZz4+KCk7XG4gICAgICAgIHAuZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcbiAgICAgICAgICAgIHguZm9yRWFjaCh5ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB5LmxhdGl0dWRlLCBsb25naXR1ZGU6IHkubG9uZ2l0dWRlIH0pKTtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlnb24gaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29uLmdldFZpc2libGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2FibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYWtlIHRoZSBwb2x5Z29uIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICAvLy9cbiAgICAgICAgLy8vIEJpbmcgcG9seWdvbnMgYXJlIG5vdCBkcmFnZ2FibGUgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8vIFNlZSBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL1xuICAgICAgICAvLy8gICAgIDdhYWFlNzQ4LTRkNWYtNGJlNS1hN2JiLTkwNDk4ZTA4YjQxYy9ob3ctY2FuLWktbWFrZS1wb2x5Z29ucG9seWxpbmUtZHJhZ2dhYmxlLWluLWJpbmctbWFwcy04XG4gICAgICAgIC8vICAgICAgP2ZvcnVtPWJpbmdtYXBzXG4gICAgICAgIC8vLyBmb3IgYSBwb3NzaWJsZSBhcHByb2FjaCB0byBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgbW9kZWwuXG4gICAgICAgIC8vL1xuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdUaGUgYmluZyBtYXBzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRyYWdnYWJsZSBwb2x5Z29ucy4nKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3ZXRoZXIgdGhlIHBvbHlnb24gcGF0aCBpcyBlZGl0YWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5Z29uIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBpc0NoYW5nZWQgPSB0aGlzLl9pc0VkaXRhYmxlICE9PSBlZGl0YWJsZTtcbiAgICAgICAgdGhpcy5faXNFZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgICAgICBpZiAoIWlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IHRoaXMuR2V0UGF0aHMoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0RHJhd2luZ1Rvb2xzKCkudGhlbih0ID0+IHtcbiAgICAgICAgICAgICAgICB0LmVkaXQodGhpcy5fcG9seWdvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0RHJhd2luZ1Rvb2xzKCkudGhlbih0ID0+IHtcbiAgICAgICAgICAgICAgICB0LmZpbmlzaCgoZWRpdGVkUG9seWdvbjogTWljcm9zb2Z0Lk1hcHMuUG9seWdvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdGVkUG9seWdvbiAhPT0gdGhpcy5fcG9seWdvbiB8fCAhdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSB0aGlzLkdldFBhdGhzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aDogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IHRoaXMuX29yaWdpbmFsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TZXRQYXRocyhuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0aGUgbmV3IHBhdGggdG8gcGVyc2lzdCBpdCBhcHBlYXJzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lZGl0aW5nQ29tcGxldGVFbWl0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvbjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9yaWdpbmFsUGF0aDogb3JpZ2luYWxQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgTmV3UGF0aDogbmV3UGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xuICAgICAqIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0T3B0aW9ucyhvKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsICYmIHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICFvcHRpb25zLnZpc2libGUpOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5TZXRFZGl0YWJsZShvcHRpb25zLmVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5Z29ucyBwYXRoLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIFNldFBhdGgocGF0aDogQXJyYXk8SUxhdExvbmc+KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcbiAgICAgICAgcGF0aC5mb3JFYWNoKHggPT4gcC5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gW3BhdGhdO1xuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldExvY2F0aW9ucyhwKTtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gcGF0aCBvciBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoc1xuICAgICAqIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWdvbnMgcGF0aChzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRQYXRocyhwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiB8IEFycmF5PElMYXRMb25nPik6IHZvaWQge1xuICAgICAgICBpZiAocGF0aHMgPT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRSaW5ncyhuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuRGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhzWzBdKSkge1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIGFycmF5c1xuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IG5ldyBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+KCk7XG4gICAgICAgICAgICAoPEFycmF5PEFycmF5PElMYXRMb25nPj4+cGF0aHMpLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3A6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcbiAgICAgICAgICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBfcC5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcbiAgICAgICAgICAgICAgICBwLnB1c2goX3ApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocztcbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24uc2V0UmluZ3MocCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGEgc2ltcGxlIGFycmF5Li4uLlxuICAgICAgICAgICAgdGhpcy5TZXRQYXRoKDxBcnJheTxJTGF0TG9uZz4+cGF0aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIFRydWUgdG8gc2V0IHRoZSBwb2x5Z29uIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRPcHRpb25zKDxNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnM+eyB2aXNpYmxlOiB2aXNpYmxlIH0pO1xuICAgICAgICBpZiAodGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX2xhYmVsKSB7IHRoaXMuX2xhYmVsLlNldCgnaGlkZGVuJywgIXZpc2libGUpOyB9XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgbGFiZWwgZm9yIHRoZSBwb2x5Z29uXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cbiAgICAgKi9cbiAgICBwcml2YXRlIE1hbmFnZUxhYmVsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5HZXRQYXRoID09IG51bGwgfHwgdGhpcy5HZXRQYXRoKCkubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAodGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24odGhpcy5DZW50cm9pZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoby5wb3NpdGlvbiA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21pblpvb20gIT09IC0xKSB7IG8ubWluWm9vbSA9IHRoaXMuX21pblpvb207IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXhab29tICE9PSAtMSkgeyBvLm1heFpvb20gPSB0aGlzLl9tYXhab29tOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbmV3IEJpbmdNYXBMYWJlbChvKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXRNYXAodGhpcy5fbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldFZhbHVlcyhvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldCgnaGlkZGVuJywgIXRoaXMuR2V0VmlzaWJsZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSB0b29sdGlwIGZvciB0aGUgcG9seWdvblxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXG4gICAgICovXG4gICAgcHJpdmF0ZSBNYW5hZ2VUb29sdGlwKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fc2hvd1Rvb2x0aXAgJiYgdGhpcy5fdGl0bGUgIT0gbnVsbCAmJiB0aGlzLl90aXRsZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGl0bGUsXG4gICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludCgwLCAyNSksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcbiAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbmV3IEJpbmdNYXBMYWJlbChvKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldE1hcCh0aGlzLl9tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRWYWx1ZXMobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb24sICdtb3VzZW92ZXInLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLCAnbW91c2Vtb3ZlJywgKG06IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUgJiYgbS5sb2NhdGlvbiAmJiBtLnByaW1pdGl2ZSA9PT0gdGhpcy5fcG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgbS5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdXRMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2x5Z29uLCAnbW91c2VvdXQnLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcikgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7IH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF0aGlzLl9zaG93VG9vbHRpcCB8fCB0aGlzLl90aXRsZSA9PT0gJycgfHwgdGhpcy5fdGl0bGUgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdXRMaXN0ZW5lcikgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tb3VzZU91dExpc3RlbmVyKTsgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lcikgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lcik7IH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vcG9seWxpbmUnO1xuaW1wb3J0IHsgQmluZ01hcExhYmVsIH0gZnJvbSAnLi9iaW5nLWxhYmVsJztcblxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgYSBwb2x5bGluZSBtb2RlbCBmb3IgQmluZyBNYXBzIFY4LlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmdQb2x5bGluZSBleHRlbmRzIFBvbHlsaW5lIGltcGxlbWVudHMgUG9seWxpbmUge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2lzRWRpdGFibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX3RpdGxlOiBzdHJpbmcgPSAnJztcbiAgICBwcml2YXRlIF9zaG93VG9vbHRpcDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3Rvb2x0aXA6IEJpbmdNYXBMYWJlbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfaGFzVG9vbFRpcFJlY2VpdmVyOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9tb3VzZU92ZXJMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcbiAgICBwcml2YXRlIF9tb3VzZU1vdmVMaXN0ZW5lcjogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcbiAgICBwcml2YXRlIF9tb3VzZU91dExpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTmF2aXR2ZSBQb2x5bGluZSB1bmRlcmx5aW5nIHRoZSBtb2RlbFxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUgeyByZXR1cm4gdGhpcy5fcG9seWxpbmU7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIHRvb2x0aXBcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd1Rvb2x0aXA7IH1cbiAgICBwdWJsaWMgc2V0IFNob3dUb29sdGlwKHZhbDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcCA9IHZhbDtcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aXRsZSBvZmYgdGhlIHBvbHlsaW5lXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGdldCBUaXRsZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGl0bGU7IH1cbiAgICBwdWJsaWMgc2V0IFRpdGxlKHZhbDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3RpdGxlID0gdmFsO1xuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gY29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ1BvbHlnb24uXG4gICAgICogQHBhcmFtIF9wb2x5bGluZSAtIFRoZSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmV9IHVuZGVybHlpbmcgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSBfbWFwIC0gVGhlIGNvbnRleHQgbWFwLlxuICAgICAqIEBwYXJhbSBfbGF5ZXIgLSBUaGUgY29udGV4dCBsYXllci5cbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcG9seWxpbmU6IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lLCBwcm90ZWN0ZWQgX21hcDogTWljcm9zb2Z0Lk1hcHMuTWFwLCBwcm90ZWN0ZWQgX2xheWVyOiBNaWNyb3NvZnQuTWFwcy5MYXllcikge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnZHJhZycsICdkcmFnZW5kJywgJ2RyYWdzdGFydCcsICdtb3VzZWRvd24nLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJywgJ21vdXNldXAnIF07XG4gICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHMuaW5kZXhPZihldmVudFR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWxpbmUsIGV2ZW50VHlwZSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlcklkOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWxpbmUsICdtb3VzZW92ZXInLCBlID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySWQgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9tYXAsICdtb3VzZW1vdmUnLCBtID0+IGZuKG0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWxpbmUsICdtb3VzZW91dCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVySWQpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIoaGFuZGxlcklkKTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVkIHRoZSBwb2x5bGluZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXIpIHsgdGhpcy5fbGF5ZXIucmVtb3ZlKHRoaXMuTmF0aXZlUHJpbWl0dmUpOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmVudGl0aWVzLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkgeyB0aGlzLl90b29sdGlwLkRlbGV0ZSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnZ2FibGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlsaW5lIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIEdldERyYWdnYWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgLy8vXG4gICAgICAgIC8vLyBCaW5nIHBvbHlnb25zIGFyZSBub3QgZHJhZ2dhYmxlIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vLyBTZWUgaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9cbiAgICAgICAgLy8vICAgICA3YWFhZTc0OC00ZDVmLTRiZTUtYTdiYi05MDQ5OGUwOGI0MWMvaG93LWNhbi1pLW1ha2UtcG9seWdvbnBvbHlsaW5lLWRyYWdnYWJsZS1pbi1iaW5nLW1hcHMtOFxuICAgICAgICAvLy8gICAgID9mb3J1bT1iaW5nbWFwc1xuICAgICAgICAvLy8gZm9yIGEgcG9zc2libGUgYXBwcm9hY2ggdG8gYmUgaW1wbGVtZW50ZWQgaW4gdGhlIG1vZGVsLlxuICAgICAgICAvLy9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgcGF0aCBjYW4gYmUgZWRpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwYXRoIGNhbiBiZSBlZGl0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0RWRpdGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VkaXRhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIHBhdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5bGluZSBwYXRoLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRQYXRoKCk6IEFycmF5PElMYXRMb25nPiB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IHRoaXMuX3BvbHlsaW5lLmdldExvY2F0aW9ucygpO1xuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XG4gICAgICAgIHAuZm9yRWFjaChsID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiBsLmxhdGl0dWRlLCBsb25naXR1ZGU6IGwubG9uZ2l0dWRlIH0pKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZS5nZXRWaXNpYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1ha2UgdGhlIHBvbHlsaW5lIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgLy8vXG4gICAgICAgIC8vLyBCaW5nIHBvbHlnb25zIGFyZSBub3QgZHJhZ2dhYmxlIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vLyBTZWUgaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9cbiAgICAgICAgLy8vICAgICA3YWFhZTc0OC00ZDVmLTRiZTUtYTdiYi05MDQ5OGUwOGI0MWMvaG93LWNhbi1pLW1ha2UtcG9seWdvbnBvbHlsaW5lLWRyYWdnYWJsZS1pbi1iaW5nLW1hcHMtOFxuICAgICAgICAvLy8gICAgID9mb3J1bT1iaW5nbWFwc1xuICAgICAgICAvLy8gZm9yIGEgcG9zc2libGUgYXBwcm9hY2ggdG8gYmUgaW1wbGVtZW50ZWQgaW4gdGhlIG1vZGVsLlxuICAgICAgICAvLy9cbiAgICAgICAgdGhyb3cobmV3IEVycm9yKCdUaGUgYmluZyBtYXBzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRyYWdnYWJsZSBwb2x5bGluZXMuJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGlzIGVkaXRhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlsaW5lIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faXNFZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gVGhlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGh0ZSBvbmVzXG4gICAgICogYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRPcHRpb25zKG8pO1xuICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICB0aGlzLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5vcHRpb25zLnBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWxpbmUgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5bGluZXMgcGF0aC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+ID0gbmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPigpO1xuICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBwLnB1c2gobmV3IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uKHgubGF0aXR1ZGUsIHgubG9uZ2l0dWRlKSkpO1xuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRMb2NhdGlvbnMocCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWxpbmUgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9seWxpbmUuc2V0T3B0aW9ucyg8TWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucz57IHZpc2libGU6IHZpc2libGUgfSk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgdG9vbHRpcCBmb3IgdGhlIHBvbHlnb25cbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxuICAgICAqL1xuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUb29sdGlwICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxuICAgICAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoMCwgMjUpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2Jpc3F1ZScsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG5ldyBCaW5nTWFwTGFiZWwobyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAodGhpcy5fbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0VmFsdWVzKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUsICdtb3VzZW92ZXInLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGUubG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAsICdtb3VzZW1vdmUnLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSAmJiBlLmxvY2F0aW9uICYmIGUucHJpbWl0aXZlID09PSB0aGlzLl9wb2x5bGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgZS5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU91dExpc3RlbmVyID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUsICdtb3VzZW91dCcsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF0aGlzLl9zaG93VG9vbHRpcCB8fCB0aGlzLl90aXRsZSA9PT0gJycgfHwgdGhpcy5fdGl0bGUgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdXRMaXN0ZW5lcikgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tb3VzZU91dExpc3RlbmVyKSA7IH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpOyB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKTsgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IElNYXBFdmVudExvb2t1cCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcC1ldmVudC1sb29rdXAnO1xuXG4vKipcbiAqIFRoaXMgY29udHN0YW50IHRyYW5zbGF0ZXMgdGhlIGFic3RyYWN0IG1hcCBldmVudHMgaW50byB0aGVpciBjb3JyZXNwb25kaW5nIGJpbmcgbWFwXG4gKiBlcXVpdmFsZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IEJpbmdNYXBFdmVudHNMb29rdXA6IElNYXBFdmVudExvb2t1cCA9IHtcbiAgICBjbGljayA6ICAgICAgICAgICAgICdjbGljaycsXG4gICAgZGJsY2xpY2sgOiAgICAgICAgICAnZGJsY2xpY2snLFxuICAgIHJpZ2h0Y2xpY2sgOiAgICAgICAgJ3JpZ2h0Y2xpY2snLFxuICAgIHJlc2l6ZSA6ICAgICAgICAgICAgJ3Jlc2l6ZScsXG4gICAgYm91bmRzY2hhbmdlZCA6ICAgICAndmlld2NoYW5nZWVuZCcsXG4gICAgY2VudGVyY2hhbmdlZCA6ICAgICAndmlld2NoYW5nZWVuZCcsXG4gICAgem9vbWNoYW5nZWQgOiAgICAgICAndmlld2NoYW5nZWVuZCcsXG4gICAgbW91c2VvdmVyOiAgICAgICAgICAnbW91c2VvdmVyJyxcbiAgICBtb3VzZW91dCA6ICAgICAgICAgICdtb3VzZW91dCcsXG4gICAgbW91c2Vtb3ZlIDogICAgICAgICAnbW91c2Vtb3ZlJyxcbiAgICBpbmZvd2luZG93Y2xvc2U6ICAgICdpbmZvYm94Q2hhbmdlZCdcbn07XG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLWNvbnZlcnNpb25zJztcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9jYW52YXMtb3ZlcmxheSc7XG5pbXBvcnQgeyBNYXBMYWJlbCB9IGZyb20gJy4uL21hcC1sYWJlbCc7XG5pbXBvcnQgeyBCaW5nTWFwTGFiZWwgfSBmcm9tICcuL2JpbmctbGFiZWwnO1xuaW1wb3J0IHsgRXh0ZW5kZXIgfSBmcm9tICcuLi9leHRlbmRlcic7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50aW5nIGEgY2FudmFzIG92ZXJsYXkgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAgZm9yIEJpbmcgTWFwcy5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBCaW5nQ2FudmFzT3ZlcmxheSBleHRlbmRzIENhbnZhc092ZXJsYXkge1xuXG4gICAgLy8vXG4gICAgLy8vIGZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX3ZpZXdDaGFuZ2VFdmVudDogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcbiAgICBwcml2YXRlIF92aWV3Q2hhbmdlRW5kRXZlbnQ6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XG4gICAgcHJpdmF0ZSBfbWFwUmVzaXplRXZlbnQ6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEJpbmdDYW52YXNPdmVybGF5IGNsYXNzLlxuICAgICAqIEBwYXJhbSBkcmF3Q2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gYmVcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXG4gICAgICogQG1lbWJlcm9mIEJpbmdDYW52YXNPdmVybGF5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCkge1xuICAgICAgICBzdXBlcihkcmF3Q2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBjbGljayBsb2NhdGlvblxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuIEV4cGVjdGVkIHRvIGltcGxlbWVudCB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzfS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NhbnZhc092ZXJsYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKTogSUxhdExvbmcge1xuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sb2NhdGlvbi5sYXRpdHVkZSwgbG9uZ2l0dWRlOiBlLmxvY2F0aW9uLmxvbmdpdHVkZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCBhc3NvY2l0ZWQgd2l0aCB0aGUgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIEdldE1hcCgpOiBNaWNyb3NvZnQuTWFwcy5NYXAge1xuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIE1hcExhYmVsIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbHRpcC5cbiAgICAgKiBUaGlzIG1ldGhvZCBvbmx5IGdlbmVyYXRlcyB0aGUgbWFwIGxhYmVsLiBDb250ZW50IGFuZCBwbGFjZW1lbnQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5XG4gICAgICogb2YgdGhlIGNhbGxlci4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbCB1bnRpbCBPbkxvYWQgaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGFiZWwgdG8gYmUgdXNlZCBmb3IgdGhlIHRvb2x0aXAuXG4gICAgICogQG1lbWJlcm9mIEJpbmdDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRUb29sVGlwT3ZlcmxheSgpOiBNYXBMYWJlbCB7XG4gICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XG4gICAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgb2Zmc2V0OiBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoMCwgMjUpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcbiAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxhYmVsOiBNYXBMYWJlbCA9IG5ldyBCaW5nTWFwTGFiZWwobyk7XG4gICAgICAgIGxhYmVsLlNldE1hcCh0aGlzLkdldE1hcCgpKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbnZhc092ZXJsYXkgbG9hZGVkLCBhdHRhY2ggbWFwIGV2ZW50cyBmb3IgdXBkYXRpbmcgY2FudmFzLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NhbnZhc092ZXJsYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgT25Mb2FkKCkge1xuICAgICAgICBjb25zdCBtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXAgdmlldyBpbmZvcm1hdGlvbi5cbiAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gbWFwLmdldFpvb20oKTtcbiAgICAgICAgdGhpcy5fY2VudGVyU3RhcnQgPSA8SUxhdExvbmc+bWFwLmdldENlbnRlcigpO1xuXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgY2FudmFzLlxuICAgICAgICB0aGlzLlJlZHJhdyh0cnVlKTtcblxuICAgICAgICAvLyBXaGVuIHRoZSBtYXAgbW92ZXMsIG1vdmUgdGhlIGNhbnZhcyBhY2NvcmRpbmdseS5cbiAgICAgICAgdGhpcy5fdmlld0NoYW5nZUV2ZW50ID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobWFwLCAndmlld2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAobWFwLmdldE1hcFR5cGVJZCgpID09PSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuc3RyZWV0c2lkZSkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgdGhlIGNhbnZhcyBpZiB0aGUgbWFwIGlzIGluIFN0cmVldHNpZGUgbW9kZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlLWRyYXdpbmcgdGhlIGNhbnZhcyBhcyBpdCBtb3ZlcyB3b3VsZCBiZSB0b28gc2xvdy4gSW5zdGVhZCwgc2NhbGUgYW5kIHRyYW5zbGF0ZSBjYW52YXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBjb25zdCB6b29tQ3VycmVudDogbnVtYmVyID0gbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJDdXJyZW50OiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IG1hcC5nZXRDZW50ZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBtYXAgc2NhbGUgYmFzZWQgb24gem9vbSBsZXZlbCBkaWZmZXJlbmNlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlOiBudW1iZXIgPSBNYXRoLnBvdygyLCB6b29tQ3VycmVudCAtIHRoaXMuX3pvb21TdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlZCBkaW1lbnNpb25zIG9mIHRoZSBjYW52YXMuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3V2lkdGg6IG51bWJlciA9IG1hcC5nZXRXaWR0aCgpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0OiBudW1iZXIgPSBtYXAuZ2V0SGVpZ2h0KCkgKiBzY2FsZTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgb2YgY2FudmFzIGJhc2VkIG9uIHpvb20gYW5kIGNlbnRlciBvZmZzZXRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsUG9pbnRzOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Qb2ludD4gPSA8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+Pm1hcC50cnlMb2NhdGlvblRvUGl4ZWwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKHRoaXMuX2NlbnRlclN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlckN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgXSwgTWljcm9zb2Z0Lk1hcHMuUGl4ZWxSZWZlcmVuY2UuY29udHJvbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WDogbnVtYmVyID0gcGl4ZWxQb2ludHNbMV0ueCAtIHBpeGVsUG9pbnRzWzBdLng7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WTogbnVtYmVyID0gcGl4ZWxQb2ludHNbMV0ueSAtIHBpeGVsUG9pbnRzWzBdLnk7XG4gICAgICAgICAgICAgICAgY29uc3QgeDogbnVtYmVyID0gKC0obmV3V2lkdGggLSBtYXAuZ2V0V2lkdGgoKSkgLyAyKSAtIGNlbnRlck9mZnNldFg7XG4gICAgICAgICAgICAgICAgY29uc3QgeTogbnVtYmVyID0gKC0obmV3SGVpZ2h0IC0gbWFwLmdldEhlaWdodCgpKSAvIDIpIC0gY2VudGVyT2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FudmFzIENTUyBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucy5cbiAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZVBvc2l0aW9uKHgsIHksIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXaGVuIHRoZSBtYXAgc3RvcHMgbW92aW5nLCByZW5kZXIgbmV3IGRhdGEgb24gdGhlIGNhbnZhcy5cbiAgICAgICAgdGhpcy5fdmlld0NoYW5nZUVuZEV2ZW50ID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobWFwLCAndmlld2NoYW5nZWVuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLlVwZGF0ZUNhbnZhcygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxuICAgICAgICB0aGlzLl9tYXBSZXNpemVFdmVudCA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG1hcCwgJ21hcHJlc2l6ZScsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLlVwZGF0ZUNhbnZhcygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgdGhlIG92ZXJsYXkgdG8gcmVhZHkgc3RhdGVcbiAgICAgICAgdGhpcy5fcmVhZHlSZXNvbHZlcih0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIE1hcCB0byBhc3NvY2lhdGVkIHdpdGggdGhlIGxhYmVsLlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRNYXAobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbTogTWljcm9zb2Z0Lk1hcHMuTWFwID0gdGhpcy5HZXRNYXAoKTtcbiAgICAgICAgaWYgKG1hcCA9PT0gbSkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIG0ubGF5ZXJzLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcC5sYXllcnMuaW5zZXJ0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgY2FudmFzIHRvIHRoZSBtYXAuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHJvdGVjdGVkIFNldENhbnZhc0VsZW1lbnQoZWw6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gICAgICAgICg8YW55PnRoaXMpLnNldEh0bWxFbGVtZW50KGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIG1hcCBldmVudCBoYW5kbGVycy5cbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIFJlbW92ZUV2ZW50SGFuZGxlcnMoKTogdm9pZCB7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgbWFwLlxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl92aWV3Q2hhbmdlRXZlbnQpO1xuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl92aWV3Q2hhbmdlRW5kRXZlbnQpO1xuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tYXBSZXNpemVFdmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ2FudmFzIHNpemUgYmFzZWQgb24gdGhlIG1hcCBzaXplLlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgUmVzaXplKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xuXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBieSB1cGRhdGluZyBkaW1lbnNpb25zLiBUaGlzIGFsc28gZW5zdXJlcyBjYW52YXMgc3RheXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBtYXAuZ2V0V2lkdGgoKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IG1hcC5nZXRIZWlnaHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDYW52YXMuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBVcGRhdGVDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XG5cbiAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIGNhbnZhcyBpZiBpdCBpc24ndCBpbiBzdHJlZXRzaWRlIG1vZGUuXG4gICAgICAgIGlmIChtYXAuZ2V0TWFwVHlwZUlkKCkgIT09IE1pY3Jvc29mdC5NYXBzLk1hcFR5cGVJZC5zdHJlZXRzaWRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyBSZXNldCBDU1MgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMgb2YgY2FudmFzLlxuICAgICAgICAgICAgdGhpcy5VcGRhdGVQb3NpdGlvbigwLCAwLCBtYXAuZ2V0V2lkdGgoKSwgbWFwLmdldEhlaWdodCgpKTtcblxuICAgICAgICAgICAgLy8gUmVkcmF3IHRoZSBjYW52YXMuXG4gICAgICAgICAgICB0aGlzLlJlZHJhdyh0cnVlKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IG1hcCB2aWV3IGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlclN0YXJ0ID0gPElMYXRMb25nPm1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHRoZSBPdmVybGF5VmlldyBpbnRvIHRoZSBDYW52YXNPdmVybGF5XG4gKlxuICogQGV4cG9ydFxuICogQG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gTWl4aW5DYW52YXNPdmVybGF5KCkge1xuXG4gICAgbmV3IEV4dGVuZGVyKEJpbmdDYW52YXNPdmVybGF5KVxuICAgIC5FeHRlbmQobmV3IE1pY3Jvc29mdC5NYXBzLkN1c3RvbU92ZXJsYXkoKSlcbiAgICAuTWFwKCdvbkFkZCcsICdPbkFkZCcpXG4gICAgLk1hcCgnb25Mb2FkJywgJ09uTG9hZCcpXG4gICAgLk1hcCgnb25SZW1vdmUnLCAnT25SZW1vdmUnKTtcbn1cbiIsImV4cG9ydCBsZXQgZ29vZ2xlOiBhbnk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR29vZ2xlTWFwIGV4dGVuZHMgTVZDT2JqZWN0IHtcbiAgZGF0YT86IERhdGE7XG4gIGNvbnN0cnVjdG9yKGVsOiBIVE1MRWxlbWVudCwgb3B0cz86IE1hcE9wdGlvbnMpOiB2b2lkO1xuICBwYW5UbyhsYXRMbmc6IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcbiAgc2V0Wm9vbSh6b29tOiBudW1iZXIpOiB2b2lkO1xuICBnZXRDZW50ZXIoKTogTGF0TG5nO1xuICBzZXRDZW50ZXIobGF0TG5nOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbCk6IHZvaWQ7XG4gIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHM7XG4gIGdldFpvb20oKTogbnVtYmVyO1xuICBnZXREaXYoKTogSFRNTERpdkVsZW1lbnQ7XG4gIGdldFByb2plY3Rpb24oKTogYW55O1xuICBzZXRPcHRpb25zKG9wdGlvbnM6IE1hcE9wdGlvbnMpOiB2b2lkO1xuICBwYW5Ub0JvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kc3xMYXRMbmdCb3VuZHNMaXRlcmFsKTogdm9pZDtcbiAgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzfExhdExuZ0JvdW5kc0xpdGVyYWwpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExhdExuZyB7XG4gIGNvbnN0cnVjdG9yKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlcik6IHZvaWQ7XG4gIGxhdCgpOiBudW1iZXI7XG4gIGxuZygpOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2VyIGV4dGVuZHMgTVZDT2JqZWN0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IE1hcmtlck9wdGlvbnMpOiB2b2lkO1xuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xuICBzZXRQb3NpdGlvbihsYXRMbmc6IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcbiAgc2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQ7XG4gIHNldExhYmVsKGxhYmVsOiBzdHJpbmd8TWFya2VyTGFiZWwpOiB2b2lkO1xuICBzZXRQb3NpdGlvbihsYXRsbmc6IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcbiAgc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XG4gIHNldEljb24oaWNvbjogc3RyaW5nKTogdm9pZDtcbiAgc2V0T3BhY2l0eShvcGFjaXR5OiBudW1iZXIpOiB2b2lkO1xuICBzZXRPcHRpb25zKG9wdGlvbnM6IE1hcmtlck9wdGlvbnMpOiB2b2lkO1xuICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xuICBzZXRaSW5kZXgoekluZGV4OiBudW1iZXIpOiB2b2lkO1xuICBnZXRMYWJlbCgpOiBNYXJrZXJMYWJlbDtcbiAgZ2V0UG9zaXRpb24oKTogTGF0TG5nO1xuICBnZXRWaXNpYmxlKCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2VyT3B0aW9ucyB7XG4gIHBvc2l0aW9uOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbDtcbiAgdGl0bGU/OiBzdHJpbmc7XG4gIG1hcD86IEdvb2dsZU1hcDtcbiAgbGFiZWw/OiBzdHJpbmd8TWFya2VyTGFiZWw7XG4gIGRyYWdnYWJsZT86IGJvb2xlYW47XG4gIGNsaWNrYWJsZT86IGJvb2xlYW47XG4gIGljb24/OiBzdHJpbmc7XG4gIG9wYWNpdHk/OiBudW1iZXI7XG4gIHZpc2libGU/OiBib29sZWFuO1xuICB6SW5kZXg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya2VyTGFiZWwge1xuICBjb2xvcjogc3RyaW5nO1xuICBmb250RmFtaWx5OiBzdHJpbmc7XG4gIGZvbnRTaXplOiBzdHJpbmc7XG4gIGZvbnRXZWlnaHQ6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsdXN0ZXJTdHlsZSB7XG4gIHVybD86IHN0cmluZztcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICB3aWR0aD86IG51bWJlcjtcbiAgYW5jaG9yPzogQXJyYXk8bnVtYmVyPjtcbiAgdGV4dENvbG9yPzogc3RyaW5nO1xuICB0ZXh0U2l6ZT86IG51bWJlcjtcbiAgYmFja2dyb3VuZFBvc2l0aW9uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtlckNsdXN0ZXJlciB7XG4gIGlzWm9vbU9uQ2xpY2soKTogYm9vbGVhbjtcbiAgaXNBdmVyYWdlQ2VudGVyKCk6IGJvb2xlYW47XG4gIGdldE1hcmtlcnMoKTogQXJyYXk8TWFya2VyPjtcbiAgZ2V0VG90YWxNYXJrZXJzKCk6IG51bWJlcjtcbiAgc2V0TWF4Wm9vbShtYXhab29tOiBudW1iZXIpOiB2b2lkO1xuICBnZXRNYXhab29tKCk6IG51bWJlcjtcbiAgYWRkTWFya2VycyhtYXJrZXJzOiBBcnJheTxNYXJrZXI+LCBvcHRfbm9kcmF3PzogYm9vbGVhbik6IHZvaWQ7XG4gIGFkZE1hcmtlcihtYXJrZXI6IE1hcmtlciwgb3B0X25vZHJhdz86IGJvb2xlYW4pOiB2b2lkO1xuICByZW1vdmVNYXJrZXJzKG1hcmtlcnM6IEFycmF5PE1hcmtlcj4sIG9wdF9ub2RyYXc/OiBib29sZWFuKTogdm9pZDtcbiAgcmVtb3ZlTWFya2VyKG1hcmtlcjogTWFya2VyLCBvcHRfbm9kcmF3PzogYm9vbGVhbik6IHZvaWQ7XG4gIGdldFRvdGFsQ2x1c3RlcnMoKTogbnVtYmVyO1xuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xuICBnZXRHcmlkU2l6ZSgpOiBudW1iZXI7XG4gIHNldEdyaWRTaXplKGdyaWRTaXplOiBudW1iZXIpOiB2b2lkO1xuICBnZXRNaW5DbHVzdGVyU2l6ZSgpOiBudW1iZXI7XG4gIHNldE1pbkNsdXN0ZXJTaXplKG1pbkNsdXN0ZXJTaXplOiBudW1iZXIpOiB2b2lkO1xuICBjbGVhck1hcmtlcnMoKTogdm9pZDtcbiAgc2V0U3R5bGVzKHN0eWxlczogQXJyYXk8Q2x1c3RlclN0eWxlPik6IHZvaWQ7XG4gIGdldFN0eWxlcygpOiBBcnJheTxDbHVzdGVyU3R5bGU+O1xuICBzZXRDYWxjdWxhdG9yKGNhbGxiYWNrOiAobWFya2VyczogQXJyYXk8TWFya2VyPiwgbnVtU3R5bGVzOiBudW1iZXIpID0+IHsgdGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyfSk6IHZvaWQ7XG4gIGdldENhbGN1bGF0b3IoKTogKG1hcmtlcnM6IEFycmF5PE1hcmtlcj4sIG51bVN0eWxlczogbnVtYmVyKSA9PiB7IHRleHQ6IHN0cmluZywgaW5kZXg6IG51bWJlcn07XG4gIHJlc2V0Vmlld3BvcnQoaGlkZT86IGJvb2xlYW4pOiB2b2lkO1xuICByZWRyYXcoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaXJjbGUgZXh0ZW5kcyBNVkNPYmplY3Qge1xuICBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzO1xuICBnZXRDZW50ZXIoKTogTGF0TG5nO1xuICBnZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcbiAgZ2V0RWRpdGFibGUoKTogYm9vbGVhbjtcbiAgZ2V0TWFwKCk6IEdvb2dsZU1hcDtcbiAgZ2V0UmFkaXVzKCk6IG51bWJlcjtcbiAgZ2V0VmlzaWJsZSgpOiBib29sZWFuO1xuICBzZXRDZW50ZXIoY2VudGVyOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbCk6IHZvaWQ7XG4gIHNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xuICBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQ7XG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XG4gIHNldE9wdGlvbnMob3B0aW9uczogQ2lyY2xlT3B0aW9ucyk6IHZvaWQ7XG4gIHNldFJhZGl1cyhyYWRpdXM6IG51bWJlcik6IHZvaWQ7XG4gIHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY2xlT3B0aW9ucyB7XG4gIGNlbnRlcj86IExhdExuZ3xMYXRMbmdMaXRlcmFsO1xuICBjbGlja2FibGU/OiBib29sZWFuO1xuICBkcmFnZ2FibGU/OiBib29sZWFuO1xuICBlZGl0YWJsZT86IGJvb2xlYW47XG4gIGZpbGxDb2xvcj86IHN0cmluZztcbiAgZmlsbE9wYWNpdHk/OiBudW1iZXI7XG4gIG1hcD86IEdvb2dsZU1hcDtcbiAgcmFkaXVzPzogbnVtYmVyO1xuICBzdHJva2VDb2xvcj86IHN0cmluZztcbiAgc3Ryb2tlT3BhY2l0eT86IG51bWJlcjtcbiAgc3Ryb2tlUG9zaXRpb24/OiAnQ0VOVEVSJ3wnSU5TSURFJ3wnT1VUU0lERSc7XG4gIHN0cm9rZVdlaWdodD86IG51bWJlcjtcbiAgdmlzaWJsZT86IGJvb2xlYW47XG4gIHpJbmRleD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXRMbmdCb3VuZHMge1xuICBjb250YWlucyhsYXRMbmc6IExhdExuZyk6IGJvb2xlYW47XG4gIGVxdWFscyhvdGhlcjogTGF0TG5nQm91bmRzfExhdExuZ0JvdW5kc0xpdGVyYWwpOiBib29sZWFuO1xuICBleHRlbmQocG9pbnQ6IExhdExuZyk6IHZvaWQ7XG4gIGdldENlbnRlcigpOiBMYXRMbmc7XG4gIGdldE5vcnRoRWFzdCgpOiBMYXRMbmc7XG4gIGdldFNvdXRoV2VzdCgpOiBMYXRMbmc7XG4gIGludGVyc2VjdHMob3RoZXI6IExhdExuZ0JvdW5kc3xMYXRMbmdCb3VuZHNMaXRlcmFsKTogYm9vbGVhbjtcbiAgaXNFbXB0eSgpOiBib29sZWFuO1xuICB0b0pTT04oKTogTGF0TG5nQm91bmRzTGl0ZXJhbDtcbiAgdG9TcGFuKCk6IExhdExuZztcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xuICB0b1VybFZhbHVlKHByZWNpc2lvbj86IG51bWJlcik6IHN0cmluZztcbiAgdW5pb24ob3RoZXI6IExhdExuZ0JvdW5kc3xMYXRMbmdCb3VuZHNMaXRlcmFsKTogTGF0TG5nQm91bmRzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExhdExuZ0JvdW5kc0xpdGVyYWwge1xuICBlYXN0OiBudW1iZXI7XG4gIG5vcnRoOiBudW1iZXI7XG4gIHNvdXRoOiBudW1iZXI7XG4gIHdlc3Q6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXRMbmdMaXRlcmFsIHtcbiAgbGF0OiBudW1iZXI7XG4gIGxuZzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vdXNlRXZlbnQgeyBsYXRMbmc6IExhdExuZzsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcE9wdGlvbnMge1xuICBjZW50ZXI/OiBMYXRMbmd8TGF0TG5nTGl0ZXJhbDtcbiAgem9vbT86IG51bWJlcjtcbiAgbWluWm9vbT86IG51bWJlcjtcbiAgbWF4Wm9vbT86IG51bWJlcjtcbiAgZGlzYWJsZURvdWJsZUNsaWNrWm9vbT86IGJvb2xlYW47XG4gIGRpc2FibGVEZWZhdWx0VUk/OiBib29sZWFuO1xuICBzY3JvbGx3aGVlbD86IGJvb2xlYW47XG4gIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcbiAgZHJhZ2dhYmxlQ3Vyc29yPzogc3RyaW5nO1xuICBkcmFnZ2luZ0N1cnNvcj86IHN0cmluZztcbiAga2V5Ym9hcmRTaG9ydGN1dHM/OiBib29sZWFuO1xuICBzdHlsZXM/OiBNYXBUeXBlU3R5bGVbXTtcbiAgem9vbUNvbnRyb2w/OiBib29sZWFuO1xuICB6b29tQ29udHJvbE9wdGlvbnM/OiBab29tQ29udHJvbE9wdGlvbnM7XG4gIHN0cmVldFZpZXdDb250cm9sPzogYm9vbGVhbjtcbiAgc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zPzogU3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zO1xuICBzY2FsZUNvbnRyb2w/OiBib29sZWFuO1xuICBzY2FsZUNvbnRyb2xPcHRpb25zPzogU2NhbGVDb250cm9sT3B0aW9ucztcbiAgbWFwVHlwZUNvbnRyb2w/OiBib29sZWFuO1xuICBtYXBUeXBlQ29udHJvbE9wdGlvbnM/OiBNYXBUeXBlQ29udHJvbE9wdGlvbnM7XG4gIHBhbkNvbnRyb2w/OiBib29sZWFuO1xuICBwYW5Db250cm9sT3B0aW9ucz86IFBhbkNvbnRyb2xPcHRpb25zO1xuICByb3RhdGVDb250cm9sPzogYm9vbGVhbjtcbiAgcm90YXRlQ29udHJvbE9wdGlvbnM/OiBSb3RhdGVDb250cm9sT3B0aW9ucztcbiAgZnVsbHNjcmVlbkNvbnRyb2w/OiBib29sZWFuO1xuICBmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnM/OiBGdWxsc2NyZWVuQ29udHJvbE9wdGlvbnM7XG4gIG1hcFR5cGVJZD86IHN0cmluZ3xNYXBUeXBlSWQ7XG4gIGNsaWNrYWJsZUljb25zPzogYm9vbGVhbjtcbiAgZ2VzdHVyZUhhbmRsaW5nPzogJ2Nvb3BlcmF0aXZlJ3wnZ3JlZWR5J3wnbm9uZSd8J2F1dG8nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcFR5cGVTdHlsZSB7XG4gIGVsZW1lbnRUeXBlPzogJ2FsbCd8J2dlb21ldHJ5J3wnZ2VvbWV0cnkuZmlsbCd8J2dlb21ldHJ5LnN0cm9rZSd8J2xhYmVscyd8J2xhYmVscy5pY29uJ3xcbiAgICAgICdsYWJlbHMudGV4dCd8J2xhYmVscy50ZXh0LmZpbGwnfCdsYWJlbHMudGV4dC5zdHJva2UnO1xuICBmZWF0dXJlVHlwZT86ICdhZG1pbmlzdHJhdGl2ZSd8J2FkbWluaXN0cmF0aXZlLmNvdW50cnknfCdhZG1pbmlzdHJhdGl2ZS5sYW5kX3BhcmNlbCd8XG4gICAgICAnYWRtaW5pc3RyYXRpdmUubG9jYWxpdHknfCdhZG1pbmlzdHJhdGl2ZS5uZWlnaGJvcmhvb2QnfCdhZG1pbmlzdHJhdGl2ZS5wcm92aW5jZSd8J2FsbCd8XG4gICAgICAnbGFuZHNjYXBlJ3wnbGFuZHNjYXBlLm1hbl9tYWRlJ3wnbGFuZHNjYXBlLm5hdHVyYWwnfCdsYW5kc2NhcGUubmF0dXJhbC5sYW5kY292ZXInfFxuICAgICAgJ2xhbmRzY2FwZS5uYXR1cmFsLnRlcnJhaW4nfCdwb2knfCdwb2kuYXR0cmFjdGlvbid8J3BvaS5idXNpbmVzcyd8J3BvaS5nb3Zlcm5tZW50J3xcbiAgICAgICdwb2kubWVkaWNhbCd8J3BvaS5wYXJrJ3wncG9pLnBsYWNlX29mX3dvcnNoaXAnfCdwb2kuc2Nob29sJ3wncG9pLnNwb3J0c19jb21wbGV4J3wncm9hZCd8XG4gICAgICAncm9hZC5hcnRlcmlhbCd8J3JvYWQuaGlnaHdheSd8J3JvYWQuaGlnaHdheS5jb250cm9sbGVkX2FjY2Vzcyd8J3JvYWQubG9jYWwnfCd0cmFuc2l0J3xcbiAgICAgICd0cmFuc2l0LmxpbmUnfCd0cmFuc2l0LnN0YXRpb24nfCd0cmFuc2l0LnN0YXRpb24uYWlycG9ydCd8J3RyYW5zaXQuc3RhdGlvbi5idXMnfFxuICAgICAgJ3RyYW5zaXQuc3RhdGlvbi5yYWlsJ3wnd2F0ZXInO1xuICBzdHlsZXJzOiBNYXBUeXBlU3R5bGVyW107XG59XG5cbi8qKlxuICogIElmIG1vcmUgdGhhbiBvbmUga2V5IGlzIHNwZWNpZmllZCBpbiBhIHNpbmdsZSBNYXBUeXBlU3R5bGVyLCBhbGwgYnV0IG9uZSB3aWxsIGJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFwVHlwZVN0eWxlciB7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBnYW1tYT86IG51bWJlcjtcbiAgaHVlPzogc3RyaW5nO1xuICBpbnZlcnRfbGlnaHRuZXNzPzogYm9vbGVhbjtcbiAgbGlnaHRuZXNzPzogbnVtYmVyO1xuICBzYXR1cmF0aW9uPzogbnVtYmVyO1xuICB2aXNpYmlsaXR5Pzogc3RyaW5nO1xuICB3ZWlnaHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5mb1dpbmRvdyBleHRlbmRzIE1WQ09iamVjdCB7XG4gIGNvbnN0cnVjdG9yKG9wdHM/OiBJbmZvV2luZG93T3B0aW9ucyk6IHZvaWQ7XG4gIGNsb3NlKCk6IHZvaWQ7XG4gIGdldENvbnRlbnQoKTogc3RyaW5nfE5vZGU7XG4gIGdldFBvc2l0aW9uKCk6IExhdExuZztcbiAgZ2V0WkluZGV4KCk6IG51bWJlcjtcbiAgb3BlbihtYXA/OiBHb29nbGVNYXAsIGFuY2hvcj86IE1WQ09iamVjdCk6IHZvaWQ7XG4gIHNldENvbnRlbnQoY29udGVudDogc3RyaW5nfE5vZGUpOiB2b2lkO1xuICBzZXRPcHRpb25zKG9wdGlvbnM6IEluZm9XaW5kb3dPcHRpb25zKTogdm9pZDtcbiAgc2V0UG9zaXRpb24ocG9zaXRpb246IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcbiAgc2V0WkluZGV4KHpJbmRleDogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNVkNPYmplY3QgeyBhZGRMaXN0ZW5lcihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pOiBNYXBzRXZlbnRMaXN0ZW5lcjsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcHNFdmVudExpc3RlbmVyIHsgcmVtb3ZlKCk6IHZvaWQ7IH1cblxuZXhwb3J0IGludGVyZmFjZSBTaXplIHtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB3aWR0aFVuaXQ/OiBzdHJpbmcsIGhlaWdodFVuaXQ/OiBzdHJpbmcpOiB2b2lkO1xuICBlcXVhbHMob3RoZXI6IFNpemUpOiBib29sZWFuO1xuICB0b1N0cmluZygpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5mb1dpbmRvd09wdGlvbnMge1xuICBjb250ZW50Pzogc3RyaW5nfE5vZGU7XG4gIGRpc2FibGVBdXRvUGFuPzogYm9vbGVhbjtcbiAgbWF4V2lkdGg/OiBudW1iZXI7XG4gIHBpeGVsT2Zmc2V0PzogU2l6ZTtcbiAgcG9zaXRpb24/OiBMYXRMbmd8TGF0TG5nTGl0ZXJhbDtcbiAgekluZGV4PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGVxdWFscyhvdGhlcjogUG9pbnQpOiBib29sZWFuO1xuICB0b1N0cmluZygpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR29vZ2xlU3ltYm9sIHtcbiAgYW5jaG9yPzogUG9pbnQ7XG4gIGZpbGxDb2xvcj86IHN0cmluZztcbiAgZmlsbE9wYWNpdHk/OiBzdHJpbmc7XG4gIGxhYmVsT3JpZ2luPzogUG9pbnQ7XG4gIHBhdGg/OiBzdHJpbmc7XG4gIHJvdGF0aW9uPzogbnVtYmVyO1xuICBzY2FsZT86IG51bWJlcjtcbiAgc3Ryb2tlQ29sb3I/OiBzdHJpbmc7XG4gIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XG4gIHN0cm9rZVdlaWdodD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJY29uU2VxdWVuY2Uge1xuICBmaXhlZFJvdGF0aW9uPzogYm9vbGVhbjtcbiAgaWNvbj86IEdvb2dsZVN5bWJvbDtcbiAgb2Zmc2V0Pzogc3RyaW5nO1xuICByZXBlYXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9seWxpbmVPcHRpb25zIHtcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcbiAgZWRpdGFibGU/OiBib29sZWFuO1xuICBnZW9kZXNpYz86IGJvb2xlYW47XG4gIGljb24/OiBBcnJheTxJY29uU2VxdWVuY2U+O1xuICBtYXA/OiBHb29nbGVNYXA7XG4gIHBhdGg/OiBBcnJheTxMYXRMbmc+fEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPjtcbiAgc3Ryb2tlQ29sb3I/OiBzdHJpbmc7XG4gIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XG4gIHN0cm9rZVdlaWdodD86IG51bWJlcjtcbiAgdmlzaWJsZT86IGJvb2xlYW47XG4gIHpJbmRleD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2x5bGluZSBleHRlbmRzIE1WQ09iamVjdCB7XG4gIGdldERyYWdnYWJsZSgpOiBib29sZWFuO1xuICBnZXRFZGl0YWJsZSgpOiBib29sZWFuO1xuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xuICBnZXRQYXRoKCk6IEFycmF5PExhdExuZz47XG4gIGdldFZpc2libGUoKTogYm9vbGVhbjtcbiAgc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XG4gIHNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZDtcbiAgc2V0TWFwKG1hcDogR29vZ2xlTWFwKTogdm9pZDtcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQb2x5bGluZU9wdGlvbnMpOiB2b2lkO1xuICBzZXRQYXRoKHBhdGg6IEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPik6IHZvaWQ7XG4gIHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XG59XG5cbi8qKlxuICogUG9seU1vdXNlRXZlbnQgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgdHJpZ2dlcnMgbW91c2UgZXZlbnRzIG9uIGEgcG9seWxpbmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUG9seU1vdXNlRXZlbnQgZXh0ZW5kcyBNb3VzZUV2ZW50IHtcbiAgZWRnZTogbnVtYmVyO1xuICBwYXRoOiBudW1iZXI7XG4gIHZlcnRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvbHlnb25PcHRpb25zIHtcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcbiAgZWRpdGFibGU/OiBib29sZWFuO1xuICBmaWxsQ29sb3I/OiBzdHJpbmc7XG4gIGZpbGxPcGFjaXR5PzogbnVtYmVyO1xuICBnZW9kZXNpYz86IGJvb2xlYW47XG4gIGljb24/OiBBcnJheTxJY29uU2VxdWVuY2U+O1xuICBtYXA/OiBHb29nbGVNYXA7XG4gIHBhdGhzPzogQXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+fEFycmF5PEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPj47XG4gIHN0cm9rZUNvbG9yPzogc3RyaW5nO1xuICBzdHJva2VPcGFjaXR5PzogbnVtYmVyO1xuICBzdHJva2VXZWlnaHQ/OiBudW1iZXI7XG4gIHZpc2libGU/OiBib29sZWFuO1xuICB6SW5kZXg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9seWdvbiBleHRlbmRzIE1WQ09iamVjdCB7XG4gIHpJbmRleDogbnVtYmVyO1xuICBnZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcbiAgZ2V0RWRpdGFibGUoKTogYm9vbGVhbjtcbiAgZ2V0TWFwKCk6IEdvb2dsZU1hcDtcbiAgZ2V0UGF0aCgpOiBBcnJheTxMYXRMbmc+O1xuICBnZXRQYXRocygpOiBBcnJheTxBcnJheTxMYXRMbmc+PjtcbiAgZ2V0VmlzaWJsZSgpOiBib29sZWFuO1xuICBzZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcbiAgc2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkO1xuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xuICBzZXRQYXRoKHBhdGg6IEFycmF5PExhdExuZz58QXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+KTogdm9pZDtcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQb2x5Z29uT3B0aW9ucyk6IHZvaWQ7XG4gIHNldFBhdGhzKHBhdGhzOiBBcnJheTxBcnJheTxMYXRMbmd8TGF0TG5nTGl0ZXJhbD4+fEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPik6IHZvaWQ7XG4gIHNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS21sTGF5ZXIgZXh0ZW5kcyBNVkNPYmplY3Qge1xuICBnZXREZWZhdWx0Vmlld3BvcnQoKTogTGF0TG5nQm91bmRzO1xuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xuICBnZXRNZXRhZGF0YSgpOiBLbWxMYXllck1ldGFkYXRhO1xuICBnZXRTdGF0dXMoKTogS21sTGF5ZXJTdGF0dXM7XG4gIGdldFVybCgpOiBzdHJpbmc7XG4gIGdldFpJbmRleCgpOiBudW1iZXI7XG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XG4gIHNldE9wdGlvbnMob3B0aW9uczogS21sTGF5ZXJPcHRpb25zKTogdm9pZDtcbiAgc2V0VXJsKHVybDogc3RyaW5nKTogdm9pZDtcbiAgc2V0WkluZGV4KHpJbmRleDogbnVtYmVyKTogdm9pZDtcbn1cblxuLyoqXG4gKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZT9obD1kZSNLbWxMYXllclN0YXR1c1xuICovXG5leHBvcnQgdHlwZSBLbWxMYXllclN0YXR1cyA9ICdET0NVTUVOVF9OT1RfRk9VTkQnIHxcbiAgICAnRE9DVU1FTlRfVE9PX0xBUkdFJyB8ICdGRVRDSF9FUlJPUicgfCAnSU5WQUxJRF9ET0NVTUVOVCcgfCAnSU5WQUxJRF9SRVFVRVNUJyB8XG4gICAgJ0xJTUlUU19FWENFRURFRCcgfCAnT0snIHwgJ1RJTUVEX09VVCcgfCAnVU5LTk9XTic7XG5cbi8qKlxuICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2U/aGw9ZGUjS21sTGF5ZXJNZXRhZGF0YVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEttbExheWVyTWV0YWRhdGEge1xuICBhdXRob3I6IEttbEF1dGhvcjtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgaGFzU2NyZWVuT3ZlcmxheXM6IGJvb2xlYW47XG4gIG5hbWU6IHN0cmluZztcbiAgc25pcHBldDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEttbEF1dGhvciB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdXJpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS21sTGF5ZXJPcHRpb25zIHtcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcbiAgbWFwPzogR29vZ2xlTWFwO1xuICBwcmVzZXJ2ZVZpZXdwb3J0PzogYm9vbGVhbjtcbiAgc2NyZWVuT3ZlcmxheXM/OiBib29sZWFuO1xuICBzdXBwcmVzc0luZm9XaW5kb3dzPzogYm9vbGVhbjtcbiAgdXJsPzogc3RyaW5nO1xuICB6SW5kZXg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS21sRmVhdHVyZURhdGEge1xuICBhdXRob3I6IEttbEF1dGhvcjtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgaW5mb1dpbmRvd0h0bWw6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzbmlwcGV0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS21sTW91c2VFdmVudCBleHRlbmRzIE1vdXNlRXZlbnQge1xuICBmZWF0dXJlRGF0YTogS21sRmVhdHVyZURhdGE7XG4gIHBpeGVsT2Zmc2V0OiBTaXplO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGEgZXh0ZW5kcyBNVkNPYmplY3Qge1xuICBmZWF0dXJlczogRmVhdHVyZVtdO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogRGF0YU9wdGlvbnMpOiB2b2lkO1xuICBhZGRHZW9Kc29uKGdlb0pzb246IE9iamVjdCwgb3B0aW9ucz86IEdlb0pzb25PcHRpb25zKTogRmVhdHVyZVtdO1xuICByZW1vdmUoZmVhdHVyZTogRmVhdHVyZSk6IHZvaWQ7XG4gIHNldENvbnRyb2xQb3NpdGlvbihjb250cm9sUG9zaXRpb246IENvbnRyb2xQb3NpdGlvbik6IHZvaWQ7XG4gIHNldENvbnRyb2xzKGNvbnRyb2xzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gIHNldERyYXdpbmdNb2RlKGRyYXdpbmdNb2RlOiBzdHJpbmcpOiB2b2lkO1xuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xuICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAvKlxuICAqIFRzbGludCBjb25maWd1cmF0aW9uIGNoZWNrLXBhcmFtZXRlcnMgd2lsbCBwcm9tcHQgZXJyb3JzIGZvciB0aGVzZSBsaW5lcyBvZiBjb2RlLlxuICAqIGh0dHBzOi8vcGFsYW50aXIuZ2l0aHViLmlvL3RzbGludC9ydWxlcy9uby11bnVzZWQtdmFyaWFibGUvXG4gICovXG4gIHNldFN0eWxlKHN0eWxlOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgZm9yRWFjaChjYWxsYmFjazogKGZlYXR1cmU6IEZlYXR1cmUpID0+IHZvaWQpOiB2b2lkO1xuICAvKiB0c2xpbnQ6ZW5hYmxlICovXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmVhdHVyZSBleHRlbmRzIE1WQ09iamVjdCB7XG4gIGlkPzogbnVtYmVyfHN0cmluZ3x1bmRlZmluZWQ7XG4gIGdlb21ldHJ5OiBHZW9tZXRyeTtcbiAgcHJvcGVydGllczogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFPcHRpb25zIHtcbiAgY29udHJvbFBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xuICBjb250cm9scz86IHN0cmluZ1tdO1xuICBkcmF3aW5nTW9kZT86IHN0cmluZztcbiAgZmVhdHVyZUZhY3Rvcnk/OiAoZ2VvbWV0cnk6IEdlb21ldHJ5KSA9PiBGZWF0dXJlO1xuICBtYXA/OiBHb29nbGVNYXA7XG4gIHN0eWxlPzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhTW91c2VFdmVudCBleHRlbmRzIE1vdXNlRXZlbnQge1xuICBmZWF0dXJlOiBGZWF0dXJlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlb0pzb25PcHRpb25zIHtcbiAgaWRQcm9wZXJ0eU5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW9tZXRyeSB7XG4gIHR5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJZGVudGlmaWVycyB1c2VkIHRvIHNwZWNpZnkgdGhlIHBsYWNlbWVudCBvZiBjb250cm9scyBvbiB0aGUgbWFwLiBDb250cm9scyBhcmVcbiAqIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gb3RoZXIgY29udHJvbHMgaW4gdGhlIHNhbWUgbGF5b3V0IHBvc2l0aW9uLiBDb250cm9scyB0aGF0XG4gKiBhcmUgYWRkZWQgZmlyc3QgYXJlIHBvc2l0aW9uZWQgY2xvc2VyIHRvIHRoZSBlZGdlIG9mIHRoZSBtYXAuXG4gKi9cbmV4cG9ydCBlbnVtIENvbnRyb2xQb3NpdGlvbiB7XG4gIEJPVFRPTV9DRU5URVIsXG4gIEJPVFRPTV9MRUZULFxuICBCT1RUT01fUklHSFQsXG4gIExFRlRfQk9UVE9NLFxuICBMRUZUX0NFTlRFUixcbiAgTEVGVF9UT1AsXG4gIFJJR0hUX0JPVFRPTSxcbiAgUklHSFRfQ0VOVEVSLFxuICBSSUdIVF9UT1AsXG4gIFRPUF9DRU5URVIsXG4gIFRPUF9MRUZULFxuICBUT1BfUklHSFRcbn1cblxuZXhwb3J0IGVudW0gTWFwVHlwZUlkIHtcbiAgLyoqIFRoaXMgbWFwIHR5cGUgZGlzcGxheXMgYSB0cmFuc3BhcmVudCBsYXllciBvZiBtYWpvciBzdHJlZXRzIG9uIHNhdGVsbGl0ZSBpbWFnZXMuICovXG4gIGh5YnJpZCxcbiAgLyoqIFRoaXMgbWFwIHR5cGUgZGlzcGxheXMgYSBub3JtYWwgc3RyZWV0IG1hcC4gKi9cbiAgcm9hZG1hcCxcbiAgLyoqIFRoaXMgbWFwIHR5cGUgZGlzcGxheXMgc2F0ZWxsaXRlIGltYWdlcy4gKi9cbiAgc2F0ZWxsaXRlLFxuICAvKiogVGhpcyBtYXAgdHlwZSBkaXNwbGF5cyBtYXBzIHdpdGggcGh5c2ljYWwgZmVhdHVyZXMgc3VjaCBhcyB0ZXJyYWluIGFuZCB2ZWdldGF0aW9uLiAqL1xuICB0ZXJyYWluXG59XG5cbi8qKioqKiBDb250cm9scyAqKioqKi9cbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBtYXAgdHlwZSBjb250cm9sLiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYXBUeXBlQ29udHJvbE9wdGlvbnMge1xuICAvKiogSURzIG9mIG1hcCB0eXBlcyB0byBzaG93IGluIHRoZSBjb250cm9sLiAqL1xuICBtYXBUeXBlSWRzPzogKE1hcFR5cGVJZHxzdHJpbmcpW107XG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxuICAgKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyBUT1BfUklHSFQuXG4gICAqL1xuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcbiAgLyoqIFN0eWxlIGlkLiBVc2VkIHRvIHNlbGVjdCB3aGF0IHN0eWxlIG9mIG1hcCB0eXBlIGNvbnRyb2wgdG8gZGlzcGxheS4gKi9cbiAgc3R5bGU/OiBNYXBUeXBlQ29udHJvbFN0eWxlO1xufVxuXG5leHBvcnQgZW51bSBNYXBUeXBlQ29udHJvbFN0eWxlIHtcbiAgREVGQVVMVCxcbiAgRFJPUERPV05fTUVOVSxcbiAgSE9SSVpPTlRBTF9CQVJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdmVydmlld01hcENvbnRyb2xPcHRpb25zIHtcbiAgb3BlbmVkPzogYm9vbGVhbjtcbn1cblxuLyoqIE9wdGlvbnMgZm9yIHRoZSByZW5kZXJpbmcgb2YgdGhlIHBhbiBjb250cm9sLiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYW5Db250cm9sT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxuICAgKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyBUT1BfTEVGVC5cbiAgICovXG4gIHBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xufVxuXG4vKiogT3B0aW9ucyBmb3IgdGhlIHJlbmRlcmluZyBvZiB0aGUgcm90YXRlIGNvbnRyb2wuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdGF0ZUNvbnRyb2xPcHRpb25zIHtcbiAgLyoqXG4gICAqIFBvc2l0aW9uIGlkLiBVc2VkIHRvIHNwZWNpZnkgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIG9uIHRoZSBtYXAuXG4gICAqIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIFRPUF9MRUZULlxuICAgKi9cbiAgcG9zaXRpb24/OiBDb250cm9sUG9zaXRpb247XG59XG5cbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBzY2FsZSBjb250cm9sLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTY2FsZUNvbnRyb2xPcHRpb25zIHtcbiAgLyoqIFN0eWxlIGlkLiBVc2VkIHRvIHNlbGVjdCB3aGF0IHN0eWxlIG9mIHNjYWxlIGNvbnRyb2wgdG8gZGlzcGxheS4gKi9cbiAgc3R5bGU/OiBTY2FsZUNvbnRyb2xTdHlsZTtcbn1cblxuZXhwb3J0IGVudW0gU2NhbGVDb250cm9sU3R5bGUge1xuICBERUZBVUxUXG59XG5cbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBTdHJlZXQgVmlldyBwZWdtYW4gY29udHJvbCBvbiB0aGUgbWFwLiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJlZXRWaWV3Q29udHJvbE9wdGlvbnMge1xuICAvKipcbiAgICogUG9zaXRpb24gaWQuIFVzZWQgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgb24gdGhlIG1hcC4gVGhlXG4gICAqIGRlZmF1bHQgcG9zaXRpb24gaXMgZW1iZWRkZWQgd2l0aGluIHRoZSBuYXZpZ2F0aW9uICh6b29tIGFuZCBwYW4pIGNvbnRyb2xzLlxuICAgKiBJZiB0aGlzIHBvc2l0aW9uIGlzIGVtcHR5IG9yIHRoZSBzYW1lIGFzIHRoYXQgc3BlY2lmaWVkIGluIHRoZVxuICAgKiB6b29tQ29udHJvbE9wdGlvbnMgb3IgcGFuQ29udHJvbE9wdGlvbnMsIHRoZSBTdHJlZXQgVmlldyBjb250cm9sIHdpbGwgYmVcbiAgICogZGlzcGxheWVkIGFzIHBhcnQgb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBkaXNwbGF5ZWRcbiAgICogc2VwYXJhdGVseS5cbiAgICovXG4gIHBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xufVxuXG4vKiogT3B0aW9ucyBmb3IgdGhlIHJlbmRlcmluZyBvZiB0aGUgem9vbSBjb250cm9sLiAqL1xuZXhwb3J0IGludGVyZmFjZSBab29tQ29udHJvbE9wdGlvbnMge1xuICAvKipcbiAgICogUG9zaXRpb24gaWQuIFVzZWQgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgb24gdGhlIG1hcC5cbiAgICogVGhlIGRlZmF1bHQgcG9zaXRpb24gaXMgVE9QX0xFRlQuXG4gICAqL1xuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcbiAgc3R5bGU/OiBab29tQ29udHJvbFN0eWxlO1xufVxuXG5leHBvcnQgZW51bSBab29tQ29udHJvbFN0eWxlIHtcbiAgREVGQVVMVCxcbiAgTEFSR0UsXG4gIFNNQUxMXG59XG5cbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBmdWxsc2NyZWVuIGNvbnRyb2wuICovXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGxzY3JlZW5Db250cm9sT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxuICAgKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyBSSUdIVF9UT1AuXG4gICAqL1xuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgT3ZlcmxheVZpZXcge1xuICAgIHB1YmxpYyBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIHB1YmxpYyBnZXQoa2V5OiBzdHJpbmcpOiBhbnk7XG4gICAgcHVibGljIHNldFZhbHVlcyhvcHRpb25zOiBhbnkpOiB2b2lkO1xuICAgIHB1YmxpYyBnZXRQYW5lcygpOiBhbnk7XG4gICAgcHVibGljIGdldFByb2plY3Rpb24oKTogYW55O1xuICAgIHB1YmxpYyBnZXRNYXAoKTogR29vZ2xlTWFwO1xufVxuIiwiaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pYm94JztcbmltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4vZ29vZ2xlLW1hcC10eXBlcyc7XG5pbXBvcnQgeyBNYXBUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFwLXR5cGUtaWQnO1xuXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgaGVscGVyZnVuY3Rpb25zIHRvIG1hcCB2YXJpb3VzIGludGVyZmFjZXMgdXNlZCB0byByZXByZXNlbnQgb3B0aW9ucyBhbmQgc3RydWN0dXJlcyBpbnRvIHRoZVxuICogY29ycmVzcG9uZGluZyBHb29nbGUgTWFwcyBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgR29vZ2xlQ29udmVyc2lvbnMge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBHb29nbGUgTWFwIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9tYXBPcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXG4gICAgICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICAgICAnY2VudGVyJyxcbiAgICAgICAgJ2NsaWNrYWJsZUljb25zJyxcbiAgICAgICAgJ2N1c3RvbU1hcFN0eWxlR29vZ2xlJyxcbiAgICAgICAgJ2Rpc2FibGVEZWZhdWx0VUknLFxuICAgICAgICAnZGlzYWJsZURvdWJsZUNsaWNrWm9vbScsXG4gICAgICAgICdkcmFnZ2FibGUnLFxuICAgICAgICAnZHJhZ2dhYmxlQ3Vyc29yJyxcbiAgICAgICAgJ2RyYWdnaW5nQ3Vyc29yJyxcbiAgICAgICAgJ2Rpc2FibGVab29taW5nJyxcbiAgICAgICAgJ2Z1bGxzY3JlZW5Db250cm9sJyxcbiAgICAgICAgJ2Z1bGxzY3JlZW5Db250cm9sT3B0aW9ucycsXG4gICAgICAgICdnZXN0dXJlSGFuZGxpbmcnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdrZXlib2FyZFNob3J0Y3V0cycsXG4gICAgICAgICdtYXBUeXBlQ29udHJvbCcsXG4gICAgICAgICdtYXBUeXBlQ29udHJvbE9wdGlvbnMnLFxuICAgICAgICAnbWFwVHlwZUlkJyxcbiAgICAgICAgJ21heFpvb20nLFxuICAgICAgICAnbWluWm9vbScsXG4gICAgICAgICdub0NsZWFyJyxcbiAgICAgICAgJ3BhbkNvbnRyb2wnLFxuICAgICAgICAncGFuQ29udHJvbE9wdGlvbnMnLFxuICAgICAgICAncm90YXRlQ29udHJvbCcsXG4gICAgICAgICdyb3RhdGVDb250cm9sT3B0aW9ucycsXG4gICAgICAgICdzY2FsZUNvbnRyb2wnLFxuICAgICAgICAnc2NhbGVDb250cm9sT3B0aW9ucycsXG4gICAgICAgICdzY3JvbGx3aGVlbCcsXG4gICAgICAgICdzaG93TWFwVHlwZVNlbGVjdG9yJyxcbiAgICAgICAgJ3N0cmVldFZpZXcnLFxuICAgICAgICAnc3RyZWV0Vmlld0NvbnRyb2wnLFxuICAgICAgICAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJyxcbiAgICAgICAgJ3N0eWxlcycsXG4gICAgICAgICd0aWx0JyxcbiAgICAgICAgJ3pvb20nLFxuICAgICAgICAnem9vbUNvbnRyb2wnLFxuICAgICAgICAnem9vbUNvbnRyb2xPcHRpb25zJ1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBJbmZvV2luZG93IG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBHb29nbGUgTWFwIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9pbmZvV2luZG93T3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xuICAgICAgICAnYWN0aW9ucycsXG4gICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICdodG1sQ29udGVudCcsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdwb3NpdGlvbicsXG4gICAgICAgICdwaXhlbE9mZnNldCcsXG4gICAgICAgICdzaG93Q2xvc2VCdXR0b24nLFxuICAgICAgICAnc2hvd1BvaW50ZXInLFxuICAgICAgICAncHVzaHBpbicsXG4gICAgICAgICd0aXRsZScsXG4gICAgICAgICd0aXRsZUNsaWNrSGFuZGxlcicsXG4gICAgICAgICd0eXBlTmFtZScsXG4gICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ2hlaWdodCdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogTWFya2VyIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBHb29nbGUgTWFwIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9tYXJrZXJPcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXG4gICAgICAgICdhbmNob3InLFxuICAgICAgICAncG9zaXRpb24nLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICAndGV4dCcsXG4gICAgICAgICdsYWJlbCcsXG4gICAgICAgICdkcmFnZ2FibGUnLFxuICAgICAgICAnaWNvbicsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAnaWNvbkluZm8nLFxuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAndmlzaWJsZSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQ2x1c3RlciBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gR29vZ2xlIE1hcCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBfY2x1c3Rlck9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICAgJ2NhbGxiYWNrJyxcbiAgICAgICAgJ2NsdXN0ZXJlZFBpbkNhbGxiYWNrJyxcbiAgICAgICAgJ2NsdXN0ZXJpbmdFbmFibGVkJyxcbiAgICAgICAgJ2dyaWRTaXplJyxcbiAgICAgICAgJ2xheWVyT2Zmc2V0JyxcbiAgICAgICAgJ3BsYWNlbWVudE1vZGUnLFxuICAgICAgICAndmlzaWJsZScsXG4gICAgICAgICd6SW5kZXgnXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIFBvbHlnb24gb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BvbHlnb25PcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXG4gICAgICAgICdjbGlja2FibGUnLFxuICAgICAgICAnZHJhZ2dhYmxlJyxcbiAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgJ2ZpbGxDb2xvcicsXG4gICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdnZW9kZXNpYycsXG4gICAgICAgICdwYXRocycsXG4gICAgICAgICdzdHJva2VDb2xvcicsXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgJ3pJbmRleCdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogUG9seWxpbmUgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xuICAgICAgICAnY2xpY2thYmxlJyxcbiAgICAgICAgJ2RyYWdnYWJsZScsXG4gICAgICAgICdlZGl0YWJsZScsXG4gICAgICAgICdnZW9kZXNpYycsXG4gICAgICAgICdzdHJva2VDb2xvcicsXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgJ3pJbmRleCdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyBhbiBJQm94IG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLkxhdExuZ0JvdW5kc0xpdGVyYWwgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGJvdW5kcyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVCb3VuZHMoYm91bmRzOiBJQm94KTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzTGl0ZXJhbCB7XG4gICAgICAgIGNvbnN0IGI6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0JvdW5kc0xpdGVyYWwgPSB7XG4gICAgICAgICAgICBlYXN0OiBib3VuZHMubWF4TG9uZ2l0dWRlLFxuICAgICAgICAgICAgbm9ydGg6IGJvdW5kcy5tYXhMYXRpdHVkZSxcbiAgICAgICAgICAgIHNvdXRoOiBib3VuZHMubWluTGF0aXR1ZGUsXG4gICAgICAgICAgICB3ZXN0OiBib3VuZHMubWluTG9uZ2l0dWRlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIElJbmZvV2luZG93T3B0aW9ucyBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93T3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVJbmZvV2luZG93T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93T3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLkluZm9XaW5kb3dPcHRpb25zIHwgYW55ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gR29vZ2xlQ29udmVyc2lvbnMuX2luZm9XaW5kb3dPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdodG1sQ29udGVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgby5jb250ZW50ID0gKDxhbnk+b3B0aW9ucylba107XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoby5jb250ZW50ID09IG51bGwgfHwgby5jb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09ICcnICYmIG9wdGlvbnMuZGVzY3JpcHRpb24gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgby5jb250ZW50ID0gYCR7b3B0aW9ucy50aXRsZX06ICR7b3B0aW9ucy5kZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kZXNjcmlwdGlvbiAhPT0gJycpIHsgby5jb250ZW50ID0gb3B0aW9ucy5kZXNjcmlwdGlvbjsgfVxuICAgICAgICAgICAgZWxzZSB7IG8uY29udGVudCA9IG9wdGlvbnMudGl0bGU7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIElMYXRMb25nIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGxvbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTG9jYXRpb24obGF0bG9uZzogSUxhdExvbmcpOiBHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsIHtcbiAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCA9IHsgbGF0OiBsYXRsb25nLmxhdGl0dWRlLCBsbmc6IGxhdGxvbmcubG9uZ2l0dWRlIH07XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCBvYmplY3QgdG8gYSBJTGF0TG9uZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0bG5nIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxhdExuZyhsYXRsbmc6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwpOiBJTGF0TG9uZyB7XG4gICAgICAgIGNvbnN0IGw6IElMYXRMb25nID0geyBsYXRpdHVkZTogbGF0bG5nLmxhdCwgbG9uZ2l0dWRlOiBsYXRsbmcubG5nIH07XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gSUxhdExvbmcgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuTGF0TG5nIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRsb25nIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxhdGxvbmc6IElMYXRMb25nKTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nIHtcbiAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRsb25nLmxhdGl0dWRlLCBsYXRsb25nLmxvbmdpdHVkZSk7XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcHMgYW4gR29vZ2xlTWFwVHlwZXMuTGF0TG5nIG9iamVjdCB0byBhIElMYXRMb25nIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRsbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTGF0TG5nT2JqZWN0KGxhdGxuZzogR29vZ2xlTWFwVHlwZXMuTGF0TG5nKTogSUxhdExvbmcge1xuICAgICAgICBjb25zdCBsOiBJTGF0TG9uZyA9IHsgbGF0aXR1ZGU6IGxhdGxuZy5sYXQoKSwgbG9uZ2l0dWRlOiBsYXRsbmcubG5nKCkgfTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhbiBJTGF0TG9uZyBhcnJheSB0byBhIGFycmF5IG9mIEdvb2dsZU1hcFR5cGVzLkxhdExuZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0bG9uZ0FycmF5IC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0QXJyYXkobGF0bG9uZ0FycmF5OiBBcnJheTxJTGF0TG9uZz4pOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+IHtcbiAgICAgICAgLy8gdXNlIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZSBpbiBjYXNlIHdlIGRlYWwgd2l0aCBsYXJnZSBudW1iZXJzIG9mIHBvaW50cyBhbmQgcGF0aHMuLi5cbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF0bG9uZ0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwLnB1c2goR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGF0bG9uZ0FycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIE1hcFR5cGVJZCBvYmplY3QgdG8gYSBHb29nbGUgbWFwdHlwZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwVHlwZUlkIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZU1hcFR5cGVJZChtYXBUeXBlSWQ6IE1hcFR5cGVJZCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAobWFwVHlwZUlkKSB7XG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5yb2FkOiByZXR1cm4gR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkW0dvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZC5yb2FkbWFwXTtcbiAgICAgICAgICAgIGNhc2UgTWFwVHlwZUlkLmdyYXlzY2FsZTogcmV0dXJuIEdvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZFtHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWQudGVycmFpbl07XG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5oeWJyaWQ6IHJldHVybiBHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWRbR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkLmh5YnJpZF07XG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5vcmRuYW5jZVN1cnZleTogcmV0dXJuIEdvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZFtHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWQudGVycmFpbl07XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkW0dvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZC5zYXRlbGxpdGVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhbiBJTWFya2VyT3B0aW9ucyBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIHRoZSBtYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLk1hcmtlck9wdGlvbnMgfCBhbnkgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBHb29nbGVDb252ZXJzaW9ucy5fbWFya2VyT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdGxuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KG9wdGlvbnNba10pO1xuICAgICAgICAgICAgICAgICAgICBvLnBvc2l0aW9uID0gbGF0bG5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGFuIElNYXBPcHRpb25zIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLk1hcE9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IEdvb2dsZU1hcFR5cGVzLk1hcE9wdGlvbnMge1xuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXBPcHRpb25zID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gR29vZ2xlQ29udmVyc2lvbnMuX21hcE9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgby5jZW50ZXIgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLmNlbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUlkID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFwVHlwZUlkKG9wdGlvbnMubWFwVHlwZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2Rpc2FibGVab29taW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvLmdlc3R1cmVIYW5kbGluZyA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgby56b29tQ29udHJvbCA9ICBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ3Nob3dNYXBUeXBlU2VsZWN0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2N1c3RvbU1hcFN0eWxlR29vZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICBvLnN0eWxlcyA9IDxHb29nbGVNYXBUeXBlcy5NYXBUeXBlU3R5bGVbXT48YW55PiBvcHRpb25zLmN1c3RvbU1hcFN0eWxlR29vZ2xlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoPGFueT5vKVtrXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFuIGFycmF5IG9mIGxvY2F0aW9ucyBvciBhbiBhcnJheSBvciBhcnJheXMgb2YgbG9jYXRpb24gdG8gYW5kIGFycmF5IG9mIGFycmF5cyBvZiBCaW5nIE1hcCBMb2NhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRocyAtIElMYXRMb25nIGJhc2VkIGxvY2F0aW9ucyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIC0gY29udmVydGVkIGxvY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUGF0aHMocGF0aHM6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PEFycmF5PElMYXRMb25nPj4pOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gbmV3IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+KCk7XG4gICAgICAgIGlmIChwYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBhdGhzKSB8fCBwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHAucHVzaChuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGhzWzBdKSkge1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIGFycmF5c1xuICAgICAgICAgICAgLy8gdXNlIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZSBpbiBjYXNlIHdlIGRlYWwgd2l0aCBsYXJnZSBudW1iZXJzIG9mIHBvaW50cyBhbmQgcGF0aHMuLi5cbiAgICAgICAgICAgIGNvbnN0IHAxID0gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cGF0aHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcC5wdXNoKEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0QXJyYXkocDFbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhIHNpbXBsZSBhcnJheS4uLi5cbiAgICAgICAgICAgIHAucHVzaChHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdEFycmF5KDxBcnJheTxJTGF0TG9uZz4+cGF0aHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgTWFwcyBhbiBJUG9seWdvbk9wdGlvbnMgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlnb25PcHRpb25zIHwgYW55ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gR29vZ2xlQ29udmVyc2lvbnMuX3BvbHlnb25PcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdwYXRocycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aHMpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0aHMgPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0aHMgPSBuZXcgQXJyYXk8QXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbD4+KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZm9yIGxvb3AgZm9yIHBlcmZvcm1hbmNlIGluIGNhc2Ugd2UgZGVhbCB3aXRoIGxhcmdlIG51bWJlcnMgb2YgcG9pbnRzIGFuZCBwYXRocy4uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwMSA9IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+Pm9wdGlvbnMucGF0aHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRoc1tpXSA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsPigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcDFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRoc1tpXVtqXSA9IHtsYXQ6IHAxW2ldW2pdLmxhdGl0dWRlLCBsbmc6IHAxW2ldW2pdLmxvbmdpdHVkZX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRocyA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmdMaXRlcmFsPigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZSBpbiBjYXNlIHdlIGRlYWwgd2l0aCBsYXJnZSBudW1iZXJzIG9mIHBvaW50cyBhbmQgcGF0aHMuLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcDEgPSA8QXJyYXk8SUxhdExvbmc+Pm9wdGlvbnMucGF0aHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRoc1tpXSA9IHtsYXQ6IHAxW2ldLmxhdGl0dWRlLCBsbmc6IHAxW2ldLmxvbmdpdHVkZX07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE1hcHMgYW4gSVBvbHlsaW5lT3B0aW9ucyBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucyB8IGFueSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEdvb2dsZUNvbnZlcnNpb25zLl9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgR29vZ2xlQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNvbnZlcnNpb25zJztcbmltcG9ydCB7IEdvb2dsZU1hcFNlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcblxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEge0BsaW5rIEluZm9XaW5kb3d9fSBtb2RlbCBmb3IgR29vZ2xlIE1hcHMuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgR29vZ2xlSW5mb1dpbmRvdyBpbXBsZW1lbnRzIEluZm9XaW5kb3cge1xuXG4gICAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBpbmZvIGJveCBpcyBjdXJyZW50bHkgb3Blbi5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBJbmZvV0dvb2dsZUluZm9XaW5kb3dpbmRvd1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5faXNPcGVuID09PSB0cnVlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLkluZm9XaW5kb3cge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvdztcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gY29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlSW5mb1dpbmRvdy5cbiAgICAgKiBAcGFyYW0gX2luZm9XaW5kb3cgLSBBIHtAbGluayBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93fSBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcFNlcnZpY2V9LlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW5mb1dpbmRvdzogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvdywgcHJpdmF0ZSBfbWFwU2VydmljZTogR29vZ2xlTWFwU2VydmljZSkgeyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgSW5mb1dpbmRvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciAoZS5nLiBcImNsaWNrXCIpXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb1dpbmRvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93LmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ2Nsb3NlY2xpY2snKSB7IHRoaXMuX2lzT3BlbiA9IGZhbHNlOyB9XG4gICAgICAgICAgICBmbihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9XaW5kb3dcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIENsb3NlKCkge1xuICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvdy5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbmZvIHdpbmRvd1xuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBpbmZvIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRQb3NpdGlvbigpOiBJTGF0TG9uZyB7XG4gICAgICAgIHJldHVybiBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMYXRMbmdPYmplY3QodGhpcy5faW5mb1dpbmRvdy5nZXRQb3NpdGlvbigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgaW5mbyB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbYW5jaG9yXSAtIE9wdGlvbmFsIEFuY2hvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBPcGVuKGFuY2hvcj86IGFueSkge1xuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbihtID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pbmZvV2luZG93Lm9wZW4obSwgYW5jaG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBzZXQuIFRoaXMgb2JqZWN0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb1dpbmRvd1xuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvd09wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVJbmZvV2luZG93T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvdy5zZXRPcHRpb25zKG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBHZW8gY29vcmRpbmF0ZXMgYXQgd2hpY2ggdG8gYW5jaG9yIHRoZSBpbmZvIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRQb3NpdGlvbihwb3NpdGlvbjogSUxhdExvbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvdy5zZXRQb3NpdGlvbihsKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMnO1xuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcblxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIE1hcmtlcn0gY29udHJhY3QgZm9yIHRoZSBHb29nbGUgTWFwcyBtYXAgYXJjaGl0ZWN0dXJlLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZU1hcmtlciBpbXBsZW1lbnRzIE1hcmtlciB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfbWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgIHByaXZhdGUgX2lzRmlyc3QgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9pc0xhc3QgPSB0cnVlO1xuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgbWFya2VyIGlzIHRoZSBmaXJzdCBtYXJrZXIgaW4gYSBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGdldCBJc0ZpcnN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faXNGaXJzdDsgfVxuICAgIHB1YmxpYyBzZXQgSXNGaXJzdCh2YWw6IGJvb2xlYW4pIHsgdGhpcy5faXNGaXJzdCA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgbGFzdCBtYXJrZXIgaW4gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IElzTGFzdCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2lzTGFzdDsgfVxuICAgIHB1YmxpYyBzZXQgSXNMYXN0KHZhbDogYm9vbGVhbikgeyB0aGlzLl9pc0xhc3QgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcmtlciBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+IHsgcmV0dXJuIHRoaXMuX21ldGFkYXRhOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBtYXJrZXIsIGluIHRoaXMgY2FzZSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbn1cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBHb29nbGVNYXBUeXBlcy5NYXJrZXIgeyByZXR1cm4gdGhpcy5fbWFya2VyOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBMb2NhdGlvbiBvZiB0aGUgbWFya2VyXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTG9jYXRpb24oKTogSUxhdExvbmcge1xuICAgICAgICBjb25zdCBsOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhdGl0dWRlOiBsLmxhdCgpLFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBsLmxuZygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVNYXJrZXIuXG4gICAgICogQHBhcmFtIF9tYXJrZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXJrZXI6IEdvb2dsZU1hcFR5cGVzLk1hcmtlcikgeyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciAoZS5nLiBcImNsaWNrXCIpXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWFya2VyLmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgZm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVNYXJrZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFya2VyIGxhYmVsXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIEdldExhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXIuZ2V0TGFiZWwoKS50ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIG1hcmtlciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXIuZ2V0VmlzaWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFuY2hvciBmb3IgdGhlIG1hcmtlci4gVXNlIHRoaXMgdG8gYWRqdXN0IHRoZSByb290IGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIHRvIGFjY29tb2RhdGUgdmFyaW91cyBtYXJrZXIgaW1hZ2Ugc2l6ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5jaG9yIC0gUG9pbnQgY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgYW5jaG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRBbmNob3IoYW5jaG9yOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkXG4gICAgICAgIC8vIFRPRE86IHdlIG5lZWQgdG8gc3dpdGNoIHRoZSBtb2RlbCB0byBjb21wbGV4IGljb25zIGZvciBnb29nbGUgdG9cbiAgICAgICAgLy8gc3VwcG9ydCBhbmNob3JzLCBzaXplcyBhbmQgb3JpZ2lucy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbWFya2Vyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRyYWdnYWJpbGl0eSBvZiBhIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1hcmsgdGhlIG1hcmtlciBhcyBkcmFnZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaWNvbiBmb3IgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpY29uIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGljb24gaW4gdmFyaW91cyBmb3JtcyAodXJsLCBkYXRhIHVybCwgZXRjLilcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0SWNvbihpY29uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldEljb24oaWNvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFya2VyIGxhYmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGxhYmVsIHRvIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0TGFiZWwobGFiZWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0TGFiZWwobGFiZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcmtlciBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRMbmcgLSBHZW8gY29vcmRpbmF0ZXMgdG8gc2V0IHRoZSBtYXJrZXIgcG9zaXRpb24gdG8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldFBvc2l0aW9uKGxhdExuZzogSUxhdExvbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGF0TG5nKTtcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldFBvc2l0aW9uKHApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcmtlciB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSB0aXRsZSB0byBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldFRpdGxlKHRpdGxlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldFRpdGxlKHRpdGxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIG9wdGlvbnMgdG8gc2V0LiBUaGUgc3VwcGxpZWQgb3B0aW9ucyBhcmVcbiAgICAgKiBtZXJnZWQgd2l0aCB0aGUgdW5kZXJseWluZyBtYXJrZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldE9wdGlvbnMobyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIG1hcmtlciB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXG4gICAgICovXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbWFwLWxhYmVsJztcbmltcG9ydCB7IElMYWJlbE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYWJlbC1vcHRpb25zJztcbmltcG9ydCB7IEV4dGVuZGVyIH0gZnJvbSAnLi4vZXh0ZW5kZXInO1xuXG5cbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xuXG4vKipcbiAqIEltcGxlbWVudHMgbWFwIGEgbGFibGVkIHRvIGJlIHBsYWNlZCBvbiB0aGUgbWFwLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZU1hcExhYmVsIGV4dGVuZHMgTWFwTGFiZWwge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBsYWJlbCBzdHlsZSBmb3IgdGhlIHBsYXRmb3JtXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwTGFiZWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IERlZmF1bHRMYWJlbFN0eWxlKCk6IElMYWJlbE9wdGlvbnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgICAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDMsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogJyMwMDAwMDAnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hcExhYmVsXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuICAgICAgICBvcHRpb25zLmZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAxMjtcbiAgICAgICAgb3B0aW9ucy5mb250Q29sb3IgPSBvcHRpb25zLmZvbnRDb2xvciB8fCAnI2ZmZmZmZic7XG4gICAgICAgIG9wdGlvbnMuc3Ryb2tlV2VpZ2h0ID0gb3B0aW9ucy5zdHJva2VXZWlnaHQgfHwgMztcbiAgICAgICAgb3B0aW9ucy5zdHJva2VDb2xvciA9IG9wdGlvbnMuc3Ryb2tlQ29sb3IgfHwgJyMwMDAwMDAnO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZy5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIEdldChrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIHJldHVybiAoPGFueT50aGlzKS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcExhYmVsXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRNYXAoKTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwIHtcbiAgICAgICAgcmV0dXJuICg8YW55PnRoaXMpLmdldE1hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cbiAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIFNldChrZXk6IHN0cmluZywgdmFsOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyAmJiB2YWwuaGFzT3duUHJvcGVydHkoJ2xhdGl0dWRlJykgJiYgdmFsLmhhc093blByb3BlcnR5KCdsb25naXR1ZGUnKSkge1xuICAgICAgICAgICAgdmFsID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh2YWwubGF0aXR1ZGUsIHZhbC5sb25naXR1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkdldChrZXkpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMpLnNldChrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIE1hcCB0byBhc3NvY2lhdGVkIHdpdGggdGhlIGxhYmVsLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0TWFwKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKTogdm9pZCB7XG4gICAgICAgICg8YW55PnRoaXMpLnNldE1hcChtYXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc2V0dGluZ3MgdG8gdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2V0dGluZ3Mga2V5IHZhbHVlIHBhaXJzLlxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0VmFsdWVzKG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nICYmICBvcHRpb25zW2tleV0uaGFzT3duUHJvcGVydHkoJ2xhdGl0dWRlJykgJiYgIG9wdGlvbnNba2V5XS5oYXNPd25Qcm9wZXJ0eSgnbG9uZ2l0dWRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyggb3B0aW9uc1trZXldLmxhdGl0dWRlLCAgb3B0aW9uc1trZXldLmxvbmdpdHVkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLkdldChrZXkpID09PSBvcHRpb25zW2tleV0pIHsgZGVsZXRlIG9wdGlvbnNba2V5XTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICg8YW55PnRoaXMpLnNldFZhbHVlcyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBsYWJlbCBvbiB0aGUgbWFwLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIERyYXcoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSAoPGFueT50aGlzKS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHk6IHN0cmluZyA9IHRoaXMuR2V0VmlzaWJsZSgpO1xuICAgICAgICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFRoZSBtYXAgcHJvamVjdGlvbiBpcyBub3QgcmVhZHkgeWV0IHNvIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhbnZhcykge1xuICAgICAgICAgICAgLy8gb25BZGQgaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB0aGlzLl9jYW52YXMuc3R5bGU7XG4gICAgICAgIGlmICh2aXNpYmlsaXR5ICE9PSAnJykge1xuICAgICAgICAgICAgLy8gbGFiZWwgaXMgbm90IHZpc2libGUsIGRvbid0IGNhbGN1bGF0ZSBwb3NpdGlvbnMgZXRjLlxuICAgICAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXSA9IHZpc2liaWxpdHk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHRoaXMuR2V0KCdvZmZzZXQnKTtcbiAgICAgICAgbGV0IGxhdExuZzogR29vZ2xlTWFwVHlwZXMuTGF0TG5nfEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgPSB0aGlzLkdldCgncG9zaXRpb24nKTtcbiAgICAgICAgaWYgKCFsYXRMbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmICghKGxhdExuZyBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHsgbGF0TG5nID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRMbmcubGF0LCBsYXRMbmcubG5nKTsgfVxuICAgICAgICBpZiAoIW9mZnNldCkgeyBvZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMCk7IH1cblxuICAgICAgICBjb25zdCBwb3MgPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdExuZyk7XG4gICAgICAgIHN0eWxlWyd0b3AnXSA9IChwb3MueSArIG9mZnNldC55KSArICdweCc7XG4gICAgICAgIHN0eWxlWydsZWZ0J10gPSAocG9zLnggKyBvZmZzZXQueCkgKyAncHgnO1xuICAgICAgICBzdHlsZVsndmlzaWJpbGl0eSddID0gdmlzaWJpbGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBjYWxsZWQgd2hlbiB0aGUgbGFiZWwgaXMgYWRkZWQgdG8gdGhlIG1hcC4gR2VuZXJhdGVzIGFuZCBjb25maWd1cmVzXG4gICAgICogdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBMYWJlbFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIE9uQWRkKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3Qgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB0aGlzLl9jYW52YXMuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cbiAgICAgICAgdGhpcy5EcmF3Q2FudmFzKCk7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gKDxhbnk+dGhpcykuZ2V0UGFuZXMoKTtcbiAgICAgICAgaWYgKHBhbmVzKSB7XG4gICAgICAgICAgICBwYW5lcy5vdmVybGF5TGF5ZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICAvLyA0OiBmbG9hdFBhbmUgKGluZm93aW5kb3cpXG4gICAgICAgICAgICAgICAgLy8gMzogb3ZlcmxheU1vdXNlVGFyZ2V0IChtb3VzZSBldmVudHMpXG4gICAgICAgICAgICAgICAgLy8gMjogbWFya2VyTGF5ZXIgKG1hcmtlciBpbWFnZXMpXG4gICAgICAgICAgICAgICAgLy8gMTogb3ZlcmxheUxheWVyIChwb2x5Z29ucywgcG9seWxpbmVzLCBncm91bmQgb3ZlcmxheXMsIHRpbGUgbGF5ZXIgb3ZlcmxheXMpXG4gICAgICAgICAgICAgICAgLy8gMDogbWFwUGFuZSAobG93ZXN0IHBhbmUgYWJvdmUgdGhlIG1hcCB0aWxlcylcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHRoZSBPdmVybGF5VmlldyBpbnRvIHRoZSBNYXBMYWJlbFxuICpcbiAqIEBleHBvcnRcbiAqIEBtZXRob2RcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBNaXhpbk1hcExhYmVsV2l0aE92ZXJsYXlWaWV3KCkge1xuXG4gICAgbmV3IEV4dGVuZGVyKEdvb2dsZU1hcExhYmVsKVxuICAgICAgICAuRXh0ZW5kKG5ldyBnb29nbGUubWFwcy5PdmVybGF5VmlldylcbiAgICAgICAgLk1hcCgnY2hhbmdlZCcsICdDaGFuZ2VkJylcbiAgICAgICAgLk1hcCgnb25BZGQnLCAnT25BZGQnKVxuICAgICAgICAuTWFwKCdkcmF3JywgJ0RyYXcnKVxuICAgICAgICAuTWFwKCdvblJlbW92ZScsICdPblJlbW92ZScpO1xufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWdvbkV2ZW50IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1ldmVudCc7XG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMnO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3BvbHlnb24nO1xuaW1wb3J0IHsgR29vZ2xlTWFwTGFiZWwgfSBmcm9tICcuL2dvb2dsZS1sYWJlbCc7XG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcyc7XG5cbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIGZvciBhIHBvbHlnb24gbW9kZWwgZm9yIEdvb2dsZSBNYXBzLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlnb24gZXh0ZW5kcyBQb2x5Z29uIGltcGxlbWVudHMgUG9seWdvbiB7XG5cbiAgICBwcml2YXRlIF90aXRsZTogc3RyaW5nID0gJyc7XG4gICAgcHJpdmF0ZSBfc2hvd0xhYmVsOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfc2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9tYXhab29tOiBudW1iZXIgPSAtMTtcbiAgICBwcml2YXRlIF9taW5ab29tOiBudW1iZXIgPSAtMTtcbiAgICBwcml2YXRlIF9sYWJlbDogR29vZ2xlTWFwTGFiZWwgPSBudWxsO1xuICAgIHByaXZhdGUgX3Rvb2x0aXA6IEdvb2dsZU1hcExhYmVsID0gbnVsbDtcbiAgICBwcml2YXRlIF90b29sdGlwVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2hhc1Rvb2xUaXBSZWNlaXZlcjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX29yaWdpbmFsUGF0aDogQXJyYXk8QXJyYXk8SUxhdExvbmc+PjtcbiAgICBwcml2YXRlIF9tb3VzZU92ZXJMaXN0ZW5lcjogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuICAgIHByaXZhdGUgX21vdXNlT3V0TGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgICBwcml2YXRlIF9tb3VzZU1vdmVMaXN0ZW5lcjogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICBwcml2YXRlIF9lZGl0aW5nQ29tcGxldGVFbWl0dGVyOiAoZXZlbnQ6IElQb2x5Z29uRXZlbnQpID0+IHZvaWQgPSBudWxsO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTGFiZWxNYXhab29tKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9XG4gICAgcHVibGljIHNldCBMYWJlbE1heFpvb20odmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHZhbDtcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQuIElnbm9yZWQgb3IgU2hvd0xhYmVsIGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IExhYmVsTWluWm9vbSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfVxuICAgIHB1YmxpYyBzZXQgTGFiZWxNaW5ab29tKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21pblpvb20gPSB2YWw7XG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEdvb2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgcG9seWdvbiwgaW4gdGhpcyBjYXNlIHtAbGluayBHb29nbGVNYXBUeXBlcy5Qb2x5Z29ufVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLlBvbHlnb24geyByZXR1cm4gdGhpcy5fcG9seWdvbjsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGdldCBTaG93TGFiZWwoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93TGFiZWw7IH1cbiAgICBwdWJsaWMgc2V0IFNob3dMYWJlbCh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fc2hvd0xhYmVsID0gdmFsO1xuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd1Rvb2x0aXA7IH1cbiAgICBwdWJsaWMgc2V0IFNob3dUb29sdGlwKHZhbDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcCA9IHZhbDtcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aXRsZSBvZmYgdGhlIHBvbHlnb25cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXG4gICAgICogQHByb3BlcnR5XG4gICAgICovXG4gICAgcHVibGljIGdldCBUaXRsZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGl0bGU7IH1cbiAgICBwdWJsaWMgc2V0IFRpdGxlKHZhbDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3RpdGxlID0gdmFsO1xuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBjb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVQb2x5Z29uLlxuICAgICAqIEBwYXJhbSBfcG9seWdvbiAtIFRoZSB7QGxpbmsgR29vZ2xlTWFwVHlwZXMuUG9seWdvbn0gdW5kZXJseWluZyB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlnb246IEdvb2dsZU1hcFR5cGVzLlBvbHlnb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gdGhpcy5HZXRQYXRocygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFtcbiAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAnZGJsY2xpY2snLFxuICAgICAgICAgICAgJ2RyYWcnLCAnZHJhZ2VuZCcsXG4gICAgICAgICAgICAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAnbW91c2VvdXQnLFxuICAgICAgICAgICAgJ21vdXNlb3ZlcicsXG4gICAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgICAncmlnaHRjbGljaydcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHN1cHBvcnRlZEV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uLmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdwYXRoY2hhbmdlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXIgPSA8KGV2ZW50OiBJUG9seWdvbkV2ZW50KSA9PiB2b2lkPmZuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRNYXAobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5EZWxldGUoKTsgfVxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkgeyB0aGlzLl90b29sdGlwLkRlbGV0ZSgpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdnYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbi5nZXREcmFnZ2FibGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gcGF0aCBjYW4gYmUgZWRpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwYXRoIGNhbiBiZSBlZGl0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIEdldEVkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbi5nZXRFZGl0YWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlnb24gcGF0aC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXG4gICAgICovXG4gICAgcHVibGljIEdldFBhdGgoKTogQXJyYXk8SUxhdExvbmc+IHtcbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IHRoaXMuX3BvbHlnb24uZ2V0UGF0aCgpO1xuICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XG4gICAgICAgIHAuZm9yRWFjaCh4ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB4LmxhdCgpLCBsb25naXR1ZGU6IHgubG5nKCkgfSkpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGhzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyBtdWx0aXBsZSBwb2x5Z29uIHBhdGhzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0UGF0aHMoKTogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gdGhpcy5fcG9seWdvbi5nZXRQYXRocygpO1xuICAgICAgICBjb25zdCBwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IG5ldyBBcnJheTxBcnJheTxJTGF0TG9uZz4+KCk7XG4gICAgICAgIHAuZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcbiAgICAgICAgICAgIHguZm9yRWFjaCh5ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB5LmxhdCgpLCBsb25naXR1ZGU6IHkubG5nKCkgfSkpO1xuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbi5nZXRWaXNpYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWdvbiBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5Z29uIHBhdGggaXMgZWRpdGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdGFibGUgLSBUcnVlIHRvIG1ha2UgcG9seWdvbiBwYXRoIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX3BvbHlnb24uZ2V0RWRpdGFibGUoKTtcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIGlmIChwcmV2aW91cyAmJiAhZWRpdGFibGUgJiYgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcih7XG4gICAgICAgICAgICAgICAgQ2xpY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgUG9seWdvbjogdGhpcyxcbiAgICAgICAgICAgICAgICBPcmlnaW5hbFBhdGg6IHRoaXMuX29yaWdpbmFsUGF0aCxcbiAgICAgICAgICAgICAgICBOZXdQYXRoOiB0aGlzLkdldFBhdGhzKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gdGhpcy5HZXRQYXRocygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xuICAgICAqIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygby5lZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuU2V0RWRpdGFibGUoby5lZGl0YWJsZSk7XG4gICAgICAgICAgICBkZWxldGUgby5lZGl0YWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0T3B0aW9ucyhvKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsICYmIHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICFvcHRpb25zLnZpc2libGUpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRQYXRoKHBhdGg6IEFycmF5PElMYXRMb25nPik6IHZvaWQge1xuICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKTtcbiAgICAgICAgcGF0aC5mb3JFYWNoKHggPT4gcC5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoeC5sYXRpdHVkZSwgeC5sb25naXR1ZGUpKSk7XG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0UGF0aChwKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gW3BhdGhdO1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NlbnRyb2lkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9seWdvbiBwYXRoIG9yIHBhdGhzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhzIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ31cbiAgICAgKiAob3IgYXJyYXkgb2YgYXJyYXlzKSBkZXNjcmliaW5nIHRoZSBwb2x5Z29ucyBwYXRoKHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0UGF0aHMocGF0aHM6IEFycmF5PEFycmF5PElMYXRMb25nPj4gfCBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHBhdGhzID09IG51bGwpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24uc2V0UGF0aHMobmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5EZWxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNbMF0pKSB7XG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3IgYXJyYXlzXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiA9IG5ldyBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PigpO1xuICAgICAgICAgICAgKDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBhdGhzKS5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9wOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKTtcbiAgICAgICAgICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBfcC5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoeC5sYXRpdHVkZSwgeC5sb25naXR1ZGUpKSk7XG4gICAgICAgICAgICAgICAgcC5wdXNoKF9wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRQYXRocyhwKTtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBhdGhzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2VudHJvaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhIHNpbXBsZSBhcnJheS4uLi5cbiAgICAgICAgICAgIHRoaXMuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+PnBhdGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWdvbiB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICBpZiAodGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX2xhYmVsKSB7IHRoaXMuX2xhYmVsLlNldCgnaGlkZGVuJywgIXZpc2libGUpOyB9XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgbGFiZWwgZm9yIHRoZSBwb2x5Z29uXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwcml2YXRlIE1hbmFnZUxhYmVsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5HZXRQYXRoID09IG51bGwgfHwgdGhpcy5HZXRQYXRoKCkubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAodGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdCh0aGlzLkNlbnRyb2lkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvLnBvc2l0aW9uID09IG51bGwpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbWluWm9vbSAhPT0gLTEpIHsgby5taW5ab29tID0gdGhpcy5fbWluWm9vbTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21heFpvb20gIT09IC0xKSB7IG8ubWF4Wm9vbSA9IHRoaXMuX21heFpvb207IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgby5tYXAgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG8uekluZGV4ID0gdGhpcy5OYXRpdmVQcmltaXR2ZS56SW5kZXggPyB0aGlzLk5hdGl2ZVByaW1pdHZlLnpJbmRleCArIDEgOiAxMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBuZXcgR29vZ2xlTWFwTGFiZWwobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXRWYWx1ZXMobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICF0aGlzLkdldFZpc2libGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgdG9vbHRpcCBmb3IgdGhlIHBvbHlnb25cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqL1xuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUb29sdGlwICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxuICAgICAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMjUpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2Jpc3F1ZScsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgby5tYXAgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG8uekluZGV4ID0gMTAwMDAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBuZXcgR29vZ2xlTWFwTGFiZWwobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldFZhbHVlcyhvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdmVyTGlzdGVuZXIgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlbW92ZScsIChlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkgeyB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU91dExpc3RlbmVyID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5hZGRMaXN0ZW5lcignbW91c2VvdXQnLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoIXRoaXMuX3Nob3dUb29sdGlwIHx8IHRoaXMuX3RpdGxlID09PSAnJyB8fCB0aGlzLl90aXRsZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU91dExpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpOyB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKTsgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7IH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMnO1xuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xuaW1wb3J0IHsgR29vZ2xlTWFwTGFiZWwgfSBmcm9tICcuL2dvb2dsZS1sYWJlbCc7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL3BvbHlsaW5lJztcblxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEgcG9seWxpbmUgbW9kZWwgZm9yIEdvb2dsZSBNYXBzLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlsaW5lIGV4dGVuZHMgUG9seWxpbmUgaW1wbGVtZW50cyBQb2x5bGluZSB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfdGl0bGU6IHN0cmluZyA9ICcnO1xuICAgIHByaXZhdGUgX3Nob3dUb29sdGlwOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdG9vbHRpcDogR29vZ2xlTWFwTGFiZWwgPSBudWxsO1xuICAgIHByaXZhdGUgX3Rvb2x0aXBWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfaGFzVG9vbFRpcFJlY2VpdmVyOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfbW91c2VPdmVyTGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgICBwcml2YXRlIF9tb3VzZU91dExpc3RlbmVyOiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gICAgcHJpdmF0ZSBfbW91c2VNb3ZlTGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgICBwcml2YXRlIF9tZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgbWFya2VyLCBpbiB0aGlzIGNhc2Uge0BsaW5rIEdvb2dsZU1BcFR5cGVzLlBvbHlsaW5lfVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lIHsgcmV0dXJuIHRoaXMuX3BvbHlsaW5lOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxuICAgICAqIEBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgU2hvd1Rvb2x0aXAoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93VG9vbHRpcDsgfVxuICAgIHB1YmxpYyBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwID0gdmFsO1xuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWdvblxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cbiAgICAgKiBAcHJvcGVydHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IFRpdGxlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl90aXRsZTsgfVxuICAgIHB1YmxpYyBzZXQgVGl0bGUodmFsOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdGl0bGUgPSB2YWw7XG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBjb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlUG9seWdvbi5cbiAgICAgKiBAcGFyYW0gX3BvbHlsaW5lIC0gVGhlIHtAbGluayBHb29nbGVNQXBUeXBlcy5Qb2x5bGluZX0gdW5kZXJseWluZyB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wb2x5bGluZTogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZGVsZWdhdGUgZm9yIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFtcbiAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAnZGJsY2xpY2snLFxuICAgICAgICAgICAgJ2RyYWcnLCAnZHJhZ2VuZCcsXG4gICAgICAgICAgICAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAnbW91c2VvdXQnLFxuICAgICAgICAgICAgJ21vdXNlb3ZlcicsXG4gICAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgICAncmlnaHRjbGljaydcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHN1cHBvcnRlZEV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2x5bGluZS5hZGRMaXN0ZW5lcihldmVudFR5cGUsIGZuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZWQgdGhlIHBvbHlsaW5lLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7IHRoaXMuX3Rvb2x0aXAuRGVsZXRlKCk7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIGRyYWdnYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWxpbmUgaXMgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXREcmFnZ2FibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZS5nZXREcmFnZ2FibGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIHBhdGggY2FuIGJlIGVkaXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0RWRpdGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZS5nZXRFZGl0YWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIHBhdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5bGluZSBwYXRoLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIEdldFBhdGgoKTogQXJyYXk8SUxhdExvbmc+IHtcbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPiA9IHRoaXMuX3BvbHlsaW5lLmdldFBhdGgoKTtcbiAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8SUxhdExvbmc+ID0gbmV3IEFycmF5PElMYXRMb25nPigpO1xuICAgICAgICBwLmZvckVhY2goeCA9PiBwYXRoLnB1c2goeyBsYXRpdHVkZTogeC5sYXQoKSwgbG9uZ2l0dWRlOiB4LmxuZygpIH0pKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lLmdldFZpc2libGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIGRyYWdhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWxpbmUgZHJhZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGlzIGVkaXRhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlsaW5lIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWxpbmUgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUxhdExvbmd9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBUaGUgb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggaHRlIG9uZXNcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldE9wdGlvbnMobyk7XG4gICAgICAgIGlmIChvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+Pm9wdGlvbnMucGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb2x5bGluZSBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lcyBwYXRoLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXG4gICAgICovXG4gICAgcHVibGljIFNldFBhdGgocGF0aDogQXJyYXk8SUxhdExvbmc+KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpO1xuICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBwLnB1c2gobmV3IGdvb2dsZS5tYXBzLkxhdExuZyh4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmUuc2V0UGF0aChwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIFRydWUgdG8gc2V0IHRoZSBwb2x5bGluZSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vL1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHRvb2x0aXAgZm9yIHRoZSBwb2x5bGluZVxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVxuICAgICAqL1xuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUb29sdGlwICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxuICAgICAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMjUpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2Jpc3F1ZScsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgby5tYXAgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG8uekluZGV4ID0gMTAwMDAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBuZXcgR29vZ2xlTWFwTGFiZWwobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldFZhbHVlcyhvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdmVyTGlzdGVuZXIgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmFkZExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlbW92ZScsIChlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkgeyB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU91dExpc3RlbmVyID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5hZGRMaXN0ZW5lcignbW91c2VvdXQnLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoIXRoaXMuX3Nob3dUb29sdGlwIHx8IHRoaXMuX3RpdGxlID09PSAnJyB8fCB0aGlzLl90aXRsZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU91dExpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpOyB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKTsgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7IH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IElNYXBFdmVudExvb2t1cCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcC1ldmVudC1sb29rdXAnO1xuXG4vKipcbiAqIFRoaXMgY29udHN0YW50IHRyYW5zbGF0ZXMgdGhlIGFic3RyYWN0IG1hcCBldmVudHMgaW50byB0aGVpciBjb3JyZXNwb25kaW5nIGdvb2dsZSBtYXBcbiAqIGVxdWl2YWxlbnRzLlxuICovXG5leHBvcnQgY29uc3QgR29vZ2xlTWFwRXZlbnRzTG9va3VwOiBJTWFwRXZlbnRMb29rdXAgPSB7XG4gICAgY2xpY2sgOiAgICAgICAgICAgICAnY2xpY2snLFxuICAgIGRibGNsaWNrIDogICAgICAgICAgJ2RibGNsaWNrJyxcbiAgICByaWdodGNsaWNrIDogICAgICAgICdyaWdodGNsaWNrJyxcbiAgICByZXNpemUgOiAgICAgICAgICAgICdyZXNpemUnLFxuICAgIGJvdW5kc2NoYW5nZWQgOiAgICAgJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICBjZW50ZXJjaGFuZ2VkIDogICAgICdjZW50ZXJfY2hhbmdlZCcsXG4gICAgem9vbWNoYW5nZWQgOiAgICAgICAnem9vbV9jaGFuZ2VkJyxcbiAgICBtb3VzZW92ZXI6ICAgICAgICAgICdtb3VzZW92ZXInLFxuICAgIG1vdXNlb3V0IDogICAgICAgICAgJ21vdXNlb3V0JyxcbiAgICBtb3VzZW1vdmUgOiAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgIGluZm93aW5kb3djbG9zZTogICAgJ2Nsb3NlY2xpY2snXG59O1xuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1jb252ZXJzaW9ucyc7XG5pbXBvcnQgeyBDYW52YXNPdmVybGF5IH0gZnJvbSAnLi4vY2FudmFzLW92ZXJsYXknO1xuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tYXAtbGFiZWwnO1xuaW1wb3J0IHsgR29vZ2xlTWFwTGFiZWwgfSBmcm9tICcuL2dvb2dsZS1sYWJlbCc7XG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcyc7XG5pbXBvcnQgeyBFeHRlbmRlciB9IGZyb20gJy4uL2V4dGVuZGVyJztcbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGluZyBhIGNhbnZhcyBvdmVybGF5IHRvIGJlIHBsYWNlZCBvbiB0aGUgbWFwIGZvciBHb29nbGUgTWFwcy5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBHb29nbGVDYW52YXNPdmVybGF5IGV4dGVuZHMgQ2FudmFzT3ZlcmxheSB7XG5cbiAgICAvLy9cbiAgICAvLy8gZmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfdmlld0NoYW5nZUVuZEV2ZW50OiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lcjtcbiAgICBwcml2YXRlIF9tYXBSZXNpemVFdmVudDogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBHb29nbGVDYW52YXNPdmVybGF5IGNsYXNzLlxuICAgICAqIEBwYXJhbSBkcmF3Q2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gYmVcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkcmF3Q2FsbGJhY2s6IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyKGRyYXdDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIGNsaWNrIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KTogSUxhdExvbmcge1xuICAgICAgICBpZiAoIWUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaWYgKCFlLmxhdExuZykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBpZiAoIWUubGF0TG5nLmxhdCB8fCAhZS5sYXRMbmcubG5nKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCBhc3NvY2l0ZWQgd2l0aCB0aGUgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TWFwKCk6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCB7XG4gICAgICAgIHJldHVybiAoPGFueT50aGlzKS5nZXRNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTWFwTGFiZWwgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB0b29sdGlwLlxuICAgICAqIFRoaXMgbWV0aG9kIG9ubHkgZ2VuZXJhdGVzIHRoZSBtYXAgbGFiZWwuIENvbnRlbnQgYW5kIHBsYWNlbWVudCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBvZiB0aGUgY2FsbGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGFiZWwgdG8gYmUgdXNlZCBmb3IgdGhlIHRvb2x0aXAuXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHVibGljIEdldFRvb2xUaXBPdmVybGF5KCk6IE1hcExhYmVsIHtcbiAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcbiAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICBvZmZzZXQ6IG5ldyBnb29nbGUubWFwcy5Qb2ludCgwLCAyNSksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiaXNxdWUnLFxuICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udENvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgby56SW5kZXggPSAxMDAwMDA7XG4gICAgICAgIGNvbnN0IGxhYmVsOiBNYXBMYWJlbCA9IG5ldyBHb29nbGVNYXBMYWJlbChvKTtcbiAgICAgICAgbGFiZWwuU2V0TWFwKHRoaXMuR2V0TWFwKCkpO1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBvdmVybGF5IGlzIGFkZGVkIHRvIHRoZSBtYXAuIFRyaWdnZXJzIE9ubG9hZC4uLi5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxuICAgICAqL1xuICAgIHB1YmxpYyBPbkFkZCgpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuT25BZGQoKTtcbiAgICAgICAgdGhpcy5PbkxvYWQoKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMDAnO1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgY2FudmFzIGFib3ZlIHByaW1pdGl2ZXMgc3VjaCBhcyBwb2x5Z29ucy5cblxuICAgICAgICAvLyBzZXQgdGhlIG92ZXJsYXkgdG8gcmVhZHkgc3RhdGVcbiAgICAgICAgdGhpcy5fcmVhZHlSZXNvbHZlcih0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIGNhbnZhcyBuZWVkcyB0byBiZSByZWRyYXduLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBkbyB0aGUgYWN0dWFsXG4gICAgICogdXBkYXRlLCBpdCBzaW1wbHkgc2NhbGVzIHRoZSBjYW52YXMuIFRoZSBhY3R1YWwgcmVkcmF3IGhhcHBlbnMgb25jZSB0aGUgbWFwIGlzIGlkbGUuXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJseVxuICAgICAqIEBtZXRob2RcbiAgICAgKi9cbiAgICBwdWJsaWMgT25EcmF3KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBpc1N0cmVldFZpZXc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgPSB0aGlzLkdldE1hcCgpO1xuXG4gICAgICAgIGlmIChpc1N0cmVldFZpZXcpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgdGhlIGNhbnZhcyBpZiB0aGUgbWFwIGlzIGluIFN0cmVldHNpZGUgbW9kZS5cbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmUtZHJhd2luZyB0aGUgY2FudmFzIGFzIGl0IG1vdmVzIHdvdWxkIGJlIHRvbyBzbG93LiBJbnN0ZWFkLCBzY2FsZSBhbmQgdHJhbnNsYXRlIGNhbnZhcyBlbGVtZW50LlxuICAgICAgICAgICAgLy8gVXBvbiBpZGxlIG9yIGRyYWcgZW5kLCB3ZSBjYW4gdGhlbiByZWRyYXcgdGhlIGNhbnZhcy4uLi5cbiAgICAgICAgICAgIGNvbnN0IHpvb21DdXJyZW50OiBudW1iZXIgPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgY29uc3QgY2VudGVyQ3VycmVudDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gbWFwLmdldENlbnRlcigpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbWFwIHNjYWxlIGJhc2VkIG9uIHpvb20gbGV2ZWwgZGlmZmVyZW5jZS5cbiAgICAgICAgICAgIGNvbnN0IHNjYWxlOiBudW1iZXIgPSBNYXRoLnBvdygyLCB6b29tQ3VycmVudCAtIHRoaXMuX3pvb21TdGFydCk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVkIGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcy5cbiAgICAgICAgICAgIGNvbnN0IGVsOiBIVE1MRGl2RWxlbWVudCA9IG1hcC5nZXREaXYoKTtcbiAgICAgICAgICAgIGNvbnN0IHc6IG51bWJlciA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgaDogbnVtYmVyID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGg6IG51bWJlciA9IHcgKiBzY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodDogbnVtYmVyID0gaCAqIHNjYWxlO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgb2Zmc2V0IG9mIGNhbnZhcyBiYXNlZCBvbiB6b29tIGFuZCBjZW50ZXIgb2Zmc2V0cy5cbiAgICAgICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSAoPGFueT50aGlzKS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBjYyA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoY2VudGVyQ3VycmVudCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FudmFzIENTUyBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucy5cbiAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9zaXRpb24oY2MueCAtIG5ld1dpZHRoIC8gMiwgY2MueSAtIG5ld0hlaWdodCAvIDIsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FudmFzT3ZlcmxheSBsb2FkZWQsIGF0dGFjaCBtYXAgZXZlbnRzIGZvciB1cGRhdGluZyBjYW52YXMuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybGF5XG4gICAgICovXG4gICAgcHVibGljIE9uTG9hZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaXNTdHJlZXRWaWV3OiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IG1hcCB2aWV3IGluZm9ybWF0aW9uLlxuICAgICAgICB0aGlzLl96b29tU3RhcnQgPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBjb25zdCBjOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHRoaXMuX2NlbnRlclN0YXJ0ID0ge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IGMubGF0KCksXG4gICAgICAgICAgICBsb25naXR1ZGU6IGMubG5nKClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXaGVuIHRoZSBtYXAgc3RvcHMgbW92aW5nLCByZW5kZXIgbmV3IGRhdGEgb24gdGhlIGNhbnZhcy5cbiAgICAgICAgdGhpcy5fdmlld0NoYW5nZUVuZEV2ZW50ID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnaWRsZScsIChlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlQ2FudmFzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXG4gICAgICAgIHRoaXMuX21hcFJlc2l6ZUV2ZW50ID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAncmVzaXplJywgKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5VcGRhdGVDYW52YXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlcyB0aGUgY25hdmFzIG92ZXJsYXkgd2l0aCBhIG1hcC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0TWFwKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKTogdm9pZCB7XG4gICAgICAgICg8YW55PnRoaXMpLnNldE1hcChtYXApO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIGNhbnZhcyB0byB0aGUgbWFwLlxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBTZXRDYW52YXNFbGVtZW50KGVsOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBwYW5lcyA9ICg8YW55PnRoaXMpLmdldFBhbmVzKCk7XG4gICAgICAgIGlmIChwYW5lcykge1xuICAgICAgICAgICAgaWYgKGVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYW5lcy5vdmVybGF5TGF5ZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIC8vIDQ6IGZsb2F0UGFuZSAoaW5mb3dpbmRvdylcbiAgICAgICAgICAgICAgICAvLyAzOiBvdmVybGF5TW91c2VUYXJnZXQgKG1vdXNlIGV2ZW50cylcbiAgICAgICAgICAgICAgICAvLyAyOiBtYXJrZXJMYXllciAobWFya2VyIGltYWdlcylcbiAgICAgICAgICAgICAgICAvLyAxOiBvdmVybGF5TGF5ZXIgKHBvbHlnb25zLCBwb2x5bGluZXMsIGdyb3VuZCBvdmVybGF5cywgdGlsZSBsYXllciBvdmVybGF5cylcbiAgICAgICAgICAgICAgICAvLyAwOiBtYXBQYW5lIChsb3dlc3QgcGFuZSBhYm92ZSB0aGUgbWFwIHRpbGVzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFuZXMub3ZlcmxheUxheWVyLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIG1hcCBldmVudCBoYW5kbGVycy5cbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIFJlbW92ZUV2ZW50SGFuZGxlcnMoKTogdm9pZCB7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgbWFwLlxuICAgICAgICBpZiAodGhpcy5fdmlld0NoYW5nZUVuZEV2ZW50KSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX3ZpZXdDaGFuZ2VFbmRFdmVudCk7IH1cbiAgICAgICAgaWYgKHRoaXMuX21hcFJlc2l6ZUV2ZW50KSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21hcFJlc2l6ZUV2ZW50KTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIENhbnZhcyBzaXplIGJhc2VkIG9uIHRoZSBtYXAgc2l6ZS5cbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIFJlc2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgPSAoPGFueT50aGlzKS5nZXRNYXAoKTtcblxuICAgICAgICAvLyBDbGVhciBjYW52YXMgYnkgdXBkYXRpbmcgZGltZW5zaW9ucy4gVGhpcyBhbHNvIGVuc3VyZXMgY2FudmFzIHN0YXlzIHRoZSBzYW1lIHNpemUgYXMgdGhlIG1hcC5cbiAgICAgICAgY29uc3QgZWw6IEhUTUxEaXZFbGVtZW50ID0gbWFwLmdldERpdigpO1xuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDYW52YXMuXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBVcGRhdGVDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XG5cbiAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIGNhbnZhcyBpZiBpdCBpc24ndCBpbiBzdHJlZXRzaWRlIG1vZGUuXG4gICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyBSZXNldCBDU1MgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMgb2YgY2FudmFzLlxuICAgICAgICAgICAgY29uc3QgZWw6IEhUTUxEaXZFbGVtZW50ID0gbWFwLmdldERpdigpO1xuICAgICAgICAgICAgY29uc3QgdzogbnVtYmVyID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoOiBudW1iZXIgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJQb2ludCA9ICg8YW55PnRoaXMpLmdldFByb2plY3Rpb24oKS5mcm9tTGF0TG5nVG9EaXZQaXhlbChtYXAuZ2V0Q2VudGVyKCkpO1xuICAgICAgICAgICAgdGhpcy5VcGRhdGVQb3NpdGlvbigoY2VudGVyUG9pbnQueCAtIHcgLyAyKSwgKGNlbnRlclBvaW50LnkgLSBoIC8gMiksIHcsIGgpO1xuXG4gICAgICAgICAgICAvLyBSZWRyYXcgdGhlIGNhbnZhcy5cbiAgICAgICAgICAgIHRoaXMuUmVkcmF3KHRydWUpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICB0aGlzLl96b29tU3RhcnQgPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgY29uc3QgYzogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgdGhpcy5fY2VudGVyU3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGMubGF0KCksXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBjLmxuZygpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBleHRlbmQgdGhlIE92ZXJsYXlWaWV3IGludG8gdGhlIENhbnZhc092ZXJsYXlcbiAqXG4gKiBAZXhwb3J0XG4gKiBAbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNaXhpbkNhbnZhc092ZXJsYXkoKSB7XG5cbiAgICBuZXcgRXh0ZW5kZXIoR29vZ2xlQ2FudmFzT3ZlcmxheSlcbiAgICAgICAgLkV4dGVuZChuZXcgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpXG4gICAgICAgIC5NYXAoJ29uQWRkJywgJ09uQWRkJylcbiAgICAgICAgLk1hcCgnZHJhdycsICdPbkRyYXcnKVxuICAgICAgICAuTWFwKCdvblJlbW92ZScsICdPblJlbW92ZScpO1xufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4vbWFya2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuL2luZm9ib3guc2VydmljZSc7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuL2xheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuL2NsdXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4vcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4vcG9seWxpbmUuc2VydmljZSc7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIGZhY3RvcnkgdG8gY3JlYXRlIGFsbCB0aGUgaW1wbGVtZW50YXRpb24gc3BlY2lmYyBzZXJ2aWNlcyBmb3IgYSBtYXAgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1hcFNlcnZpY2VGYWN0b3J5IHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1hcCBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50aW5nIGEgc3BlY2lmaWMgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgYWJzdHJhY3QgQ3JlYXRlKCk6IE1hcFNlcnZpY2U7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjbHVzdGVyIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGggdW5kZXJseWluZyBtYXAgYXJjaHRpY3R1cmUuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgYWJzdHJhY3QgQ3JlYXRlQ2x1c3RlclNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2U7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBpbmZvIGJveCBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSB7QGxpbmsgTWFya2VyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcmtlciBhcmNodGljdHVyZS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJbmZvQm94U2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZUZhY3RvcnlcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBDcmVhdGVJbmZvQm94U2VydmljZShtYXA6IE1hcFNlcnZpY2UsIG1hcmtlcjogTWFya2VyU2VydmljZSk6IEluZm9Cb3hTZXJ2aWNlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgYWJzdHJhY3QgQ3JlYXRlTGF5ZXJTZXJ2aWNlKG1hcDogTWFwU2VydmljZSk6IExheWVyU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1hcmtlciBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKiBAcGFyYW0gY2x1c3RlcnMgIC0ge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBNYXJrZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIGFic3RyYWN0IENyZWF0ZU1hcmtlclNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSwgY2x1c3RlcnM6IENsdXN0ZXJTZXJ2aWNlKTogTWFya2VyU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlnb24gc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWdvblNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgYWJzdHJhY3QgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcG9seWxpbmUgc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWxpbmVTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lU2VydmljZShtYXA6IE1hcFNlcnZpY2UsIGxheWVyczogTGF5ZXJTZXJ2aWNlKTogUG9seWxpbmVTZXJ2aWNlO1xuXG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvaW50JztcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pYm94JztcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlnb24nO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9tb2RlbHMvcG9seWxpbmUnO1xuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL21vZGVscy9pbmZvLXdpbmRvdyc7XG5pbXBvcnQgeyBDYW52YXNPdmVybGF5IH0gZnJvbSAnLi4vbW9kZWxzL2NhbnZhcy1vdmVybGF5JztcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0byBpbXBsZW1lbnQgbWFwIGFwaS4gQSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUgY3JlYXRlZCBmb3IgZWFjaFxuICogTWFwIHByb3ZpZGVyIHN1cHBvcnRlZCAoZS5nLiBCaW5nLCBHb29sZ2UsIEVTUkkpXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXBTZXJ2aWNlIHtcblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgcHJvcGVydGllc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTWFwIGNvbnRyb2wgaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0IE1hcEluc3RhbmNlKCk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIHtAbGluayBNYXBJbnN0YW5jZX0gaWYgeW91XG4gICAgICogYXJlIG5vdCBzdXJlIGlmIGFuZCB3aGVuIHRoZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXQgTWFwUHJvbWlzZSgpOiBQcm9taXNlPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXBzIHBoeXNpY2FsIHNpemUuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldCBNYXBTaXplKCk6IElTaXplO1xuXG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHMgYW5kIE1hcFNlcnZpY2UgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGdlbyBsb2NhdGlvbnMgZmlsbGluZyB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvdW50IC0gbnVtYmVyIG9mIGxvY2F0aW9ucyB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gYm91bmRzICAtIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIGdlbyBsb2NhdGlvbnMuXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIEdldFJhbmRvbkxvY2F0aW9ucyhjb3VudDogbnVtYmVyLCBib3VuZHM6IElCb3gpOiBBcnJheTxJTGF0TG9uZz4ge1xuICAgICAgICBjb25zdCBhOiBBcnJheTxJTGF0TG9uZz4gPSBbXTtcbiAgICAgICAgY29uc3QgX2dldFJhbmRvbUxvY2F0aW9uID0gKGI6IElCb3gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhdDogbnVtYmVyID0gTWF0aC5yYW5kb20oKSAqIChiLm1heExhdGl0dWRlIC0gYi5taW5MYXRpdHVkZSkgKyBiLm1pbkxhdGl0dWRlO1xuICAgICAgICAgICAgbGV0IGxuZzogbnVtYmVyID0gMDtcbiAgICAgICAgICAgIGlmIChjcm9zc2VzRGF0ZUxpbmUpIHtcbiAgICAgICAgICAgICAgICBsbmcgPSBNYXRoLnJhbmRvbSgpICogKGIubWluTG9uZ2l0dWRlICsgMzYwIC0gYi5tYXhMb25naXR1ZGUpICsgYi5tYXhMb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgaWYgKGxuZyA+IDE4MCkgeyBsbmcgPSBsbmcgLSAzNjA7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxuZyA9IE1hdGgucmFuZG9tKCkgKiAoYi5tYXhMb25naXR1ZGUgLSBiLm1pbkxvbmdpdHVkZSkgKyBiLm1pbkxvbmdpdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHA6IElMYXRMb25nID0geyBsYXRpdHVkZTogbGF0LCBsb25naXR1ZGU6IGxuZyB9O1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjcm9zc2VzRGF0ZUxpbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoYm91bmRzID09IG51bGwpIHsgYm91bmRzID0gPElCb3g+e1xuICAgICAgICAgICAgICAgIG1heExhdGl0dWRlOiAzNjAsXG4gICAgICAgICAgICAgICAgbWluTGF0aXR1ZGU6IDAsXG4gICAgICAgICAgICAgICAgbWF4TG9uZ2l0dWRlOiAxNzAsXG4gICAgICAgICAgICAgICAgbWluTG9uZ2l0dWRlOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZHMuY2VudGVyLmxvbmdpdHVkZSA8IGJvdW5kcy5taW5Mb25naXR1ZGUgIHx8IGJvdW5kcy5jZW50ZXIubG9uZ2l0dWRlID4gYm91bmRzLm1heExvbmdpdHVkZSkgeyBjcm9zc2VzRGF0ZUxpbmUgPSB0cnVlOyB9XG4gICAgICAgIGlmICghY291bnQgfHwgY291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtfZ2V0UmFuZG9tTG9jYXRpb24oYm91bmRzKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBjb3VudDsgcisrKSB7IGEucHVzaChfZ2V0UmFuZG9tTG9jYXRpb24oYm91bmRzKSk7IH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhcyBvdmVybGF5IGxheWVyIHRvIHBlcmZvcm0gY3VzdG9tIGRyYXdpbmcgb3ZlciB0aGUgbWFwIHdpdGggb3V0XG4gICAgICogc29tZSBvZiB0aGUgb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIGdvaW5nIHRocm91Z2ggdGhlIE1hcCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSBkcmF3Q2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gYmVcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIENhbnZhc092ZXJsYXl9IG9iamVjdC5cbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVDYW52YXNPdmVybGF5KGRyYXdDYWxsYmFjazogKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHZvaWQpOiBQcm9taXNlPENhbnZhc092ZXJsYXk+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjbHVzdGVyIGxheWVyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElDbHVzdGVyT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIExheWVyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBuYXRpdmUgbGF5ZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBDcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZvcm1hdGlvbiB3aW5kb3cgZm9yIGEgbWFwIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgSW5mb1dpbmRvd30gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0dmllIGluZm9ib3ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBDcmVhdGVJbmZvV2luZG93KG9wdGlvbnM/OiBJSW5mb1dpbmRvd09wdGlvbnMpOiBQcm9taXNlPEluZm9XaW5kb3c+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBsYXllciB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci4gU2VlIHtAbGluayBJTGF5ZXJPcHRpb25zfVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBMYXllcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIGxheWVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgQ3JlYXRlTGF5ZXIob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cbiAgICAgKiBAcGFyYW0gbWFwT3B0aW9ucyAtIE1hcCBvcHRpb25zXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgbWFwIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IENyZWF0ZU1hcChlbDogSFRNTEVsZW1lbnQsIG1hcE9wdGlvbnM6IElNYXBPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgbWFya2VyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbb3B0aW9ucz08SU1hcmtlck9wdGlvbnM+e31dIC0gT3B0aW9ucyBmb3IgdGhlIG1hcmtlci4gU2VlIHtAbGluayBJTWFya2VyT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIE1hcmtlcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHB1c2hwaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBDcmVhdGVNYXJrZXIob3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBQcm9taXNlPE1hcmtlcj47XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcG9seWdvbiB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBwb2x5Z29uLiBTZWUge0BsaW5rIElQb2x5Z29uT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlnb259IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBDcmVhdGVQb2x5Z29uKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj47XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcG9seWxpbmUgd2l0aGluIHRoZSBtYXAgY29udGV4dFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWxpbmUuIFNlZSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlsaW5lfSBvYmplY3QgKG9yIGFuIGFycmF5IHRoZXJlb2YgZm9yIGNvbXBsZXggcGF0aHMpLFxuICAgICAqIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBuYXRpdmUgcG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj47XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVyIC0gTGF5ZXIgdG8gZGVsZXRlLiBTZWUge0BsaW5rIExheWVyfS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYXllciBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBEZWxldGVMYXllcihsYXllcjogTGF5ZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGFvc2UgdGhlIG1hcCBhbmQgYXNzb2NpYXRlZCByZXNvdXJlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgRGlzcG9zZU1hcCgpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXAgYm91bmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBzY3JlZW4uIFNlZSB7QGxpbmsgSUJveH0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IEdldEJvdW5kcygpOiBQcm9taXNlPElCb3g+O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXAgY2VudGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIuIFNlZSB7QGxpbmsgSUxhdExvbmd9LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBHZXRDZW50ZXIoKTogUHJvbWlzZTxJTGF0TG9uZz47XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB6b29tIGxldmVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBHZXRab29tKCk6IFByb21pc2U8bnVtYmVyPjtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLiBUaGlzIHByb21pc2UgcmVzb2x2ZXMgdG8gbnVsbFxuICAgICAqIGlmIHRoZSBnb2UgY29vcmRpbmF0ZXMgYXJlIG5vdCBpbiB0aGUgdmlldyBwb3J0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBMb2NhdGlvblRvUG9pbnQobG9jOiBJTGF0TG9uZyk6IFByb21pc2U8SVBvaW50PjtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBMb2NhdGlvbnNUb1BvaW50cyhsb2NzOiBBcnJheTxJTGF0TG9uZz4pOiBQcm9taXNlPEFycmF5PElQb2ludD4+O1xuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyB0aGUgbWFwIG9uIGEgZ2VvIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlb0Nvb3JkaW5hdGVzIGFyb3VuZCB3aGljaCB0byBjZW50ZXIgdGhlIG1hcC4gU2VlIHtAbGluayBJTGF0TG9uZ31cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGNlbnRlciBvcGVyYXRpb25zIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2VuZXJpYyBtYXAgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IFNldE1hcE9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlldyBvcHRpb25zIG9mIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBTZXRWaWV3T3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gem9vbSAtIFpvb20gbGV2ZWwgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSB6b29tIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgU2V0Wm9vbSh6b29tOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBzdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGUuZy4gJ2NsaWNrJylcbiAgICAgKiBAcmV0dXJucyAtIEFuIG9ic2VydmFibGUgb2YgdHB5ZSBFIHRoYXQgZmlyZXMgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBTdWJzY3JpYmVUb01hcEV2ZW50PEU+KGV2ZW50TmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxFPjtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBnaXZlbiBldmVudCBuYW1lIG9uIHRoZSBtYXAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gRXZlbnQgdG8gdHJpZ2dlci5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgb25jZSB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBUcmlnZ2VyTWFwRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuLi9jb21wb25lbnRzL21hcC1tYXJrZXInO1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdCBjbGFzcyByZXByZXNlbnRzIHRoZSBjb250cmFjdCBkZWZpbnRpb25zIGZvciBhIG1hcmtlciBzZXJ2aWNlIHRvIGJlIGltcGxlbWVudGVkIGJ5IGFuIGFjdXRhbHkgdW5kZXJseWluZ1xuICogbWFwIGFyY2hpdGVjdHVyZS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1hcmtlclNlcnZpY2Uge1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1hcmtlci4gRGVwZW5kaW5nIG9uIHRoZSBtYXJrZXIgY29udGV4dCwgdGhlIG1hcmtlciB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGEgY29ycmVjc3BvbmRpbmcgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0ge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcmtlciBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50fCBhbnkpOiBJTGF0TG9uZztcblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBtb2RlbCBmb3IgdGhlIG1hcmtlciBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gb2J0YWluIHRoZSBtYXJrZXIgbW9kZWwuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBNYXJrZXJ9IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+O1xuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIHBpeGVsIGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIHBpeGVscyBvZiB0aGUgbWFya2VyIG9uIHRoZSBtYXAgY2FudmFzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0UGl4ZWxzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnR8IGFueSk6IElQb2ludDtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZ2VvIGxvY2F0aW9uIHRvIGEgcGl4ZWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gRWl0aGVyIGEge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb3IgYSB7QGxpbmsgSUxhdExvbmd9XG4gICAgICogZm9yIHRoZSBiYXNpcyBvZiB0cmFuc2xhdGlvbi5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhIHtAbGluayBJUG9pbnR9XG4gICAgICogd2l0aCB0aGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIE1hcE1hcmtlckRpcmVjdGl2ZSBvciBJTGF0TG9uZyByZWxhdGl2ZSB0byB0aGUgbWFwIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IExvY2F0aW9uVG9Qb2ludCh0YXJnZXQ6IE1hcE1hcmtlckRpcmVjdGl2ZSB8IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGFuY2hvci5cbiAgICAgKiBBbmNob3IgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGFuY2hvciBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlQW5jaG9yKG1ha2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgZHJhZ2FiaWxpdHkuXG4gICAgICogRHJhZ2FiaWxpdHkgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIG1hcmtlciBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlRHJhZ2dhYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIEljb24gb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBpY29uLlxuICAgICAqIEljb24gaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGljb24gaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZUljb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBsYWJlbC5cbiAgICAgKiBMYWJlbCBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGFiZWwgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZUxhYmVsKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBjb29yZGluYXRlcy5cbiAgICAgKiBDb29yZGluYXRlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlTWFya2VyUG9zaXRpb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB0aXRsZS5cbiAgICAgKiBUaXRsZSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgdGl0bGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVRpdGxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB2aXNpYmlsaXR5LlxuICAgICAqIFZpc2liaWxpdHkgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVZpc2libGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9pbmZvYm94JztcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IEluZm9XaW5kb3cgfSBmcm9tICcuLi9tb2RlbHMvaW5mby13aW5kb3cnO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZGVmaW5lcyB0aGUgY29udHJhY3QgZm9yIGFuIEluZm9Cb3hTZXJ2aWNlLiBFYWNoIE1hcCBBcmNoaXRlY3R1cmUgcHJvdmlkZXIgaXMgZXhwZWN0ZWQgdGhlIGZ1cm5pc2ggYSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEluZm9Cb3hTZXJ2aWNlIHtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW5mbyB3aW5kb3cgdG8gdGhlIG1hcCBvciBsYXllci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgQWRkSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbiBpbmZvYm94IHRoYXQgaXMgb3Blbi5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IENsb3NlKGluZm86IEluZm9Cb3hDb21wb25lbnQpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGV2ZW50cyBvbiB0aGUgaW5mb3dpbmRvdy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcbiAgICAgKiBAcGFyYW0gaW5mb0NvbXBvbmVudCAtIFRoZSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50OiBzdHJpbmcsIGluZm9Cb3hDb21wb25lbnQ6IEluZm9Cb3hDb21wb25lbnQpOiBPYnNlcnZhYmxlPFQ+O1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGluZm9ib3guXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXG4gICAgICovXG4gICAgYWJzdHJhY3QgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGFuIGluZm9ib3ggdGhhdCBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBPcGVuKGluZm86IEluZm9Cb3hDb21wb25lbnQsIGxvYz86IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZm9ib3ggb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgdG8gc2V0LiBPcHRpb25zIHByb3ZpZGVkIGFyZVxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBvcHRpb25zIG9mIHRoZSB1bmRlcmx5aW5nIGluZm9ib3guXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggb3B0aW9ucyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IFNldE9wdGlvbnMoaW5mbzogSW5mb0JveENvbXBvbmVudCwgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluZm9ib3ggYmFzZWQgb24gdGhlIHByb3BlcnRpZXMgc2V0IG9uIHRoZSBJbmZvQm94IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqIEBwYXJhbSBsYXRsbmcgLSBUaGUgcG9zaXRpb24gdG8gc2V0XG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggcG9zaXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIGFic3RyYWN0IFNldFBvc2l0aW9uKGluZm86IEluZm9Cb3hDb21wb25lbnQsIGxhdGxuZz86IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPjtcblxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlsaW5lJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcbmltcG9ydCB7IE1hcExheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi4vY29tcG9uZW50cy9tYXAtbGF5ZXInO1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRvIHRvIGRlZmluZSB0aGUgbGF5ZXIgc2VydmljZSBjb250cmFjdC4gTXVzdCBiZSByZWFsaXplZCBieSBpbXBsZW1lbnRpbmcgcHJvdmlkZXIuXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMYXllclNlcnZpY2Uge1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxuICAgICAqIEdlbmVyYWxseSwgTWFwTGF5ZXJEaXJlY3RpdmUgd2lsbCBiZSBpbmplY3RlZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZVxuICAgICAqIExheWVyU2VydmljZSBhbmQgdGhlbiBzZWxmIHJlZ2lzdGVyIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1hcmtlciB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbWFya2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlci5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIE1hcmtlciBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlTWFya2VyKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogUHJvbWlzZTxNYXJrZXI+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIG1hcmtlcnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIG1hcmtlcnMgdG8gYmUgdXNlZCBpbiBidWxrXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlcnMuXG4gICAgICogQHBhcmFtIG1hcmtlckljb24gLSBPcHRpb25hbCBpbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBjdXN0b20gbWFya2Vycy4gVGhpcyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1hcmtlcnMuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgTWFya2VyIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBvbHlnb24gdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIGxpbmUuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5Z29uIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVQb2x5Z29uKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj47XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWdvbnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlnb25zIHRvIGJlIHVzZWQgaW4gYnVsa1xuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWdvbnMuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWdvbiBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PjtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbGluZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlci5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhblxuICAgICAqIGFycmF5IG9mIHBvbHlsaW5lcyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5bGluZXMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlsaW5lcyB0byBiZSB1c2VkIGluIGJ1bGtcbiAgICAgKiBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlsaW5lcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlsaW5lcy5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5bGluZSBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lcyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj47XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBsYXllclxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxheWVyIC0gTWFwTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYXllciBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBEZWxldGVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTGF5ZXIgbW9kZWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBsYXllci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3Qgb3IgTWFwTGF5ZXJJZCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiByZXNvbHZlZCBjb250YWlucyB0aGUgTGF5ZXIgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEdldE5hdGl2ZUxheWVyKGxheWVyOiBNYXBMYXllckRpcmVjdGl2ZXxudW1iZXIpOiBQcm9taXNlPExheWVyPjtcbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlnb24nO1xuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdCBjbGFzcyByZXByZXNlbnRzIHRoZSBjb250cmFjdCBkZWZpbnRpb25zIGZvciBhIHBvbHlnb24gc2VydmljZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBhY3V0YWx5IHVuZGVybHlpbmdcbiAqIG1hcCBhcmNoaXRlY3R1cmUuXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2x5Z29uU2VydmljZSB7XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwb2x5Z29uIHRvIGEgbWFwLiBEZXBlbmRpbmcgb24gdGhlIHBvbHlnb24gY29udGV4dCwgdGhlIHBvbHlnb24gd2lsbCBlaXRoZXIgYnkgYWRkZWQgdG8gdGhlIG1hcCBvciBhXG4gICAqIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBBZGRQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiB2b2lkO1xuXG4gIC8qKlxuICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhIG1hcmtlci5cbiAgICAqXG4gICAgKiBAYWJzdHJhY3RcbiAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcbiAgICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxuICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAqXG4gICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcbiAgICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcblxuICAvKipcbiAgICAqIERlbGV0ZXMgYSBwb2x5Z29uLlxuICAgICpcbiAgICAqIEBhYnN0cmFjdFxuICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cbiAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBoYXMgYmVlbiBkZWxldGVkLlxuICAgICpcbiAgICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxuICAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBEZWxldGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxuICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cbiAgICpcbiAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50IHwgYW55KTogSUxhdExvbmc7XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgdGhlIHBvbHlnb24gbW9kZWwgZm9yIHRoZSBwb2x5Z29uIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gcG9seWdvbiAtIFRoZSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWdvbiBtb2RlbC5cbiAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5Z29ufSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHlnb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5Z29uPjtcblxuICAvKipcbiAgICogU2V0IHRoZSBwb2x5Z29uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJUG9seWdvbk9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAqIG9wdGlvbnMgYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IFNldE9wdGlvbnMocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgUG9seWdvbiBwYXRoXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxuICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHlnb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcblxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9tb2RlbHMvcG9seWxpbmUnO1xuaW1wb3J0IHsgTWFwUG9seWxpbmVEaXJlY3RpdmUgfSBmcm9tICcuLi9jb21wb25lbnRzL21hcC1wb2x5bGluZSc7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IGNsYXNzIHJlcHJlc2VudHMgdGhlIGNvbnRyYWN0IGRlZmludGlvbnMgZm9yIGEgcG9seWxpbmUgc2VydmljZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBhY3V0YWx5IHVuZGVybHlpbmdcbiAqIG1hcCBhcmNoaXRlY3R1cmUuXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2x5bGluZVNlcnZpY2Uge1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWxpbmUgY29udGV4dCwgdGhlIHBvbHlsaW5lIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxuICAgKiBjb3JyZWNzcG9uZGluZyBsYXllci5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSBwb2x5bGluZSAtIFRoZSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgQWRkUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogdm9pZDtcblxuICAvKipcbiAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBtYXJrZXIuXG4gICAgKlxuICAgICogQGFic3RyYWN0XG4gICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXG4gICAgKiBAcGFyYW0gcG9seWxpbmUgLSBUaGUge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxuICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAqXG4gICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXG4gICAgKi9cbiAgcHVibGljIGFic3RyYWN0IENyZWF0ZUV2ZW50T2JzZXJ2YWJsZTxUPihldmVudE5hbWU6IHN0cmluZywgcG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcblxuICAvKipcbiAgICAqIERlbGV0ZXMgYSBwb2x5bGluZS5cbiAgICAqXG4gICAgKiBAYWJzdHJhY3RcbiAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cbiAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAqXG4gICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXG4gICAgKi9cbiAgcHVibGljIGFic3RyYWN0IERlbGV0ZVBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNsaWNrZWQgbWFya2VyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZztcblxuICAvKipcbiAgICogT2J0YWlucyB0aGUgcG9seWxpbmUgbW9kZWwgZm9yIHRoZSBwb2x5bGluZSBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgUG9seWxpbmV9IGltcGxlbWVudGF0aW9uIChvciBhblxuICAgKiBhcnJheSBvZiBwb2x5bGluZXMpIGZvciBjb21wbGV4IHBhdGhzIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAqIG9wdGlvbnMgYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBQb2x5bGluZSBwYXRoXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHlsaW5lU2VydmljZVxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tb2RlbHMvbWFya2VyJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9tb2RlbHMvcG9seWdvbic7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL21vZGVscy9wb2x5bGluZSc7XG5pbXBvcnQgeyBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuLi9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXInO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9sYXllci5zZXJ2aWNlJztcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0byB0byBkZWZpbmUgdGVoIGNsdXN0ZXIgbGF5ZXIgc2VydmljZSBjb250cmFjdC4gTXVzdCBiZSByZWFsaXplZCBieSBpbXBsZW1lbnRpbmcgcHJvdmlkZXIuXG4gKlxuICogQGV4cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDbHVzdGVyU2VydmljZSBleHRlbmRzIExheWVyU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0IG9mIGVudGl0aWVzXG4gICAgICogaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBjbHVzdGVyLiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGFzIGFkZGluZyBhbiBlbnRpdGl5IHdpbGwgcmVjYWxjdWxhdGUgYWxsIGNsdXN0ZXJzLlxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgU3RhcnRDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgLyoqXG4gICAgICogU3RvcCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcbiAgICAgKiBjb21wbGV0ZSB0byByZWNhbGN1bGF0ZSB0aGUgY2x1c3RlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IFN0b3BDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xuXG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEluZm9Cb3hBY3Rpb24gcmVuZGVycyBhbiBhY3Rpb24gaW4gYW4gaW5mbyB3aW5kb3cge0BsaW5rIEluZm9Cb3h9XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmUsIEluZm9Cb3hDb21wb25lbnQsIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmV9IGZyb20gJy4uLic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cbiAqICBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cbiAqICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbTGFiZWxdPVwiJ00nXCI+XG4gKiAgICAgICAgPHgtaW5mby1ib3g+XG4gKiAgICAgICAgICA8eC1pbmZvLWJveC1hY3Rpb24gW0xhYmVsXT1cImFjdGlvbmxhYmVsXCIgKEFjdGlvbkNsaWNrZWQpPVwiYWN0aW9uQ2xpY2tlZCh0aGlzKVwiPjwveC1pbmZvLWJveC1hY3Rpb24+XG4gKiAgICAgICAgPC94LWluZm8tYm94PlxuICogICAgICA8L3gtbWFwLW1hcmtlcj5cbiAqICAgIDwveC1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleHBvcnRcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd4LWluZm8tYm94LWFjdGlvbidcbn0pXG5leHBvcnQgY2xhc3MgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gZGlzcGxheSBvbiB0aGUgYWN0aW9uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGFjdGlvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIEFjdGlvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxufVxuIiwiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNpbXBsZUNoYW5nZSxcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJbmZvQm94U2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2luZm9ib3guc2VydmljZSc7XG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuL21hcC1tYXJrZXInO1xuaW1wb3J0IHsgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaW5mb2JveC1hY3Rpb24nO1xuXG4vKipcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgbXVsdGlwbGUgaW5mb2JveGVzLlxuICovXG5sZXQgaW5mb0JveElkID0gMDtcblxuLyoqXG4gKiBJbmZvQm94IHJlbmRlcnMgYSBpbmZvIHdpbmRvdyBpbnNpZGUgYSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvciBzdGFuZGFsb25lLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwTWFya2VyRGlyZWN0aXZlLCBJbmZvQm94Q29tcG9uZW50LCBJbmZvQm94QWN0aW9uRGlyZWN0aXZlfSBmcm9tICcuLi4nO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLm1hcC1jb250YWluZXIgeyBoZWlnaHQ6IDMwMHB4OyB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cbiAqICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbTGFiZWxdPVwiJ00nXCI+XG4gKiAgICAgICAgPHgtaW5mby1ib3ggW0Rpc2FibGVBdXRvUGFuXT1cInRydWVcIj5cbiAqICAgICAgICAgIEhpLCB0aGlzIGlzIHRoZSBjb250ZW50IG9mIHRoZSA8c3Ryb25nPmluZm8gd2luZG93PC9zdHJvbmc+XG4gKiAgICAgICAgIDwveC1pbmZvLWJveD5cbiAqICAgICAgIDwveC1tYXAtbWFya2VyPlxuICogICAgIDwveC1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleHBvcnRcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd4LWluZm8tYm94JyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2ICNpbmZvQm94Q29udGVudCBjbGFzcz0naW5mby1ib3gtY29udGVudCc+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PmAsXG4gICAgc3R5bGVzOiBbYFxuICAgICAgICB4LW1hcCAuTWljcm9zb2Z0TWFwIC5JbmZvYm94IC5pbmZvYm94LXRpdGxlIHsgcGFkZGluZzogMTBweCAxMHB4IDVweCAxMHB4IH1cbiAgICAgICAgeC1tYXAgLk1pY3Jvc29mdE1hcCAuSW5mb2JveCAuaW5mb2JveC1pbmZvIHsgcGFkZGluZzogM3B4IDEwcHggMTBweCAxMHB4IH1cbiAgICAgICAgeC1tYXAgLk1pY3Jvc29mdE1hcCAuSW5mb2JveCAuaW5mb2JveC1hY3Rpb25zIHsgaGVpZ2h0OiBhdXRvIH1cbiAgICBgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIEluZm9Cb3hDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfaW5mb0JveEFkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfaWQ6IHN0cmluZyA9IChpbmZvQm94SWQrKykudG9TdHJpbmcoKTtcblxuICAgIC8qKlxuICAgICAqIEhUTUwgY29uZW50IG9mIHRoZSBpbmZvYm94XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2luZm9Cb3hDb250ZW50JykgcHJpdmF0ZSBfY29udGVudDogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIFplcm8gb3IgbW9yZSBhY3Rpb25zIHRvIHNob3cgb24gdGhlIGluZm8gd2luZG93XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSkgcHVibGljIEluZm9XaW5kb3dBY3Rpb25zOiBRdWVyeUxpc3Q8SW5mb0JveEFjdGlvbkRpcmVjdGl2ZT47XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXRpdHVkZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cgKG9ubHkgdXNlZnVsbCBpZiB5b3UgdXNlIGl0IG91c2lkZSBvZiBhIHtAbGluayBNYXBNYXJrZXJ9KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIExhdGl0dWRlOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIHBvc2l0aW9uIG9mIHRoZSBpbmZvIHdpbmRvdyAob25seSB1c2VmdWxsIGlmIHlvdSB1c2UgaXQgb3VzaWRlIG9mIGEge0BsaW5rIE1hcE1hcmtlcn0pLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTG9uZ2l0dWRlOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBpbiB0aGUgaW5mbyB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gdG8gZGlzcGxheSBpbiB0aGUgaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBEZXNjcmlwdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBhdXRvLXBhbiBvbiBvcGVuLiBCeSBkZWZhdWx0LCB0aGUgaW5mbyB3aW5kb3cgd2lsbCBwYW4gdGhlIG1hcCBzbyB0aGF0IGl0IGlzIGZ1bGx5XG4gICAgICogdmlzaWJsZSB3aGVuIGl0IG9wZW5zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgRGlzYWJsZUF1dG9QYW46IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiAgTWF4aW11bSB3aWR0aCBvZiB0aGUgaW5mb3dpbmRvdywgcmVnYXJkbGVzcyBvZiBjb250ZW50J3Mgd2lkdGguIFRoaXMgdmFsdWUgaXMgb25seSBjb25zaWRlcmVkXG4gICAgICogIGlmIGl0IGlzIHNldCBiZWZvcmUgYSBjYWxsIHRvIG9wZW4uIFRvIGNoYW5nZSB0aGUgbWF4aW11bSB3aWR0aCB3aGVuIGNoYW5naW5nIGNvbnRlbnQsIGNhbGxcbiAgICAgKiAgY2xvc2UsIHVwZGF0ZSBtYXhXaWR0aCwgYW5kIHRoZW4gb3Blbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIE1heFdpZHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciBvbmx5IG9uZSBpbmZvYm94IGNhbiBiZSBvcGVuIGF0IGEgdGltZS4gTm90ZSB0aGF0IEFOWSBpbmZvIGJveCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIE1vZGFsID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBtYXJrZXIgdGhhdCBpcyB0aGUgaG9zdCBvZiB0aGUgaW5mbyB3aW5kb3cgKGlmIGF2YWlsYWJsZSlcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIEhvc3RNYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdmlzaWJpbGl0eSBvZiBpbmZvYm94XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9mZnNldCBvZiB0aGUgaW5mb2JveCBmcm9tIHRoZSBob3N0IG1hcmtlciBsYXQvbG9uZyBvciB0aGUgc2VwZWNpZmllZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHhPZmZzZXQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBmb3IgdGhlIGluZm9ib3ggZnJvbSB0aGUgaG9zdCBtYXJrZXIgbGF0L2xvbmcgb3IgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHlPZmZzZXQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgb3RoZXIgaW5mbyBib3hlcyBzaG91bGQgYmUgY2xvc2VkIGJlZm9yZSBvcGVuaW5nIHRoaXMgb25lXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBDbG9zZUluZm9Cb3hlc09uT3BlbiA9IHRydWU7XG5cbiAgICAvLy9cbiAgICAvLy8gRGVsZWdhdGUgZGVmaW50aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgaW5mbyB3aW5kb3cgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIEluZm9Cb3hDbG9zZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIC8vL1xuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGluZm8gYm94LlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IEh0bWxDb250ZW50KCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50Lm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5fY29udGVudC5uYXRpdmVFbGVtZW50LmlubmVyVGV4dCAmJiB0aGlzLl9jb250ZW50Lm5hdGl2ZUVsZW1lbnQuaW5uZXJUZXh0LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lm5hdGl2ZUVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBJZCBvZiB0aGUgaW5mbyBib3ggYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSWQoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2lkOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgSW5mb0JveENvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gX2luZm9Cb3hTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdW5kZXJseWluZyBNYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbmZvQm94U2VydmljZTogSW5mb0JveFNlcnZpY2UpIHsgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIEluZm9ib3guXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBDbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLkNsb3NlKHRoaXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5JbmZvQm94Q2xvc2UuZW1pdCh0aGlzLl9pZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBhZnRlciBjb21wb25lbnQgdmlldyBhcyBiZWVuIGluaXRpYWxpemVkLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLl9pbmZvQm94U2VydmljZS5BZGRJbmZvV2luZG93KHRoaXMpO1xuICAgICAgICB0aGlzLl9pbmZvQm94QWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLkhhbmRsZUV2ZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBDaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KSB7XG4gICAgICAgIGlmICghdGhpcy5faW5mb0JveEFkZGVkVG9NYW5hZ2VyKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAoKGNoYW5nZXNbJ2xhdGl0dWRlJ10gfHwgY2hhbmdlc1snbG9uZ2l0dWRlJ10pICYmIHR5cGVvZiB0aGlzLkxhdGl0dWRlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuTG9uZ2l0dWRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5faW5mb0JveFNlcnZpY2UuU2V0UG9zaXRpb24odGhpcywge1xuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBjaGFuZ2VzWydsYXRpdHVkZSddLmN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGNoYW5nZXNbJ2xvbmdpdHVkZSddLmN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5TZXRJbmZvV2luZG93T3B0aW9ucyhjaGFuZ2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkgeyB0aGlzLl9pbmZvQm94U2VydmljZS5EZWxldGVJbmZvV2luZG93KHRoaXMpOyB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIGNsb3NlZCBpbmZvIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbbG9jXSAgLSB7QGxpbmsgSUxhdExvbmcgfSByZXByZXNlbnRpbmcgcG9zaXRpb24gb24gd2hpY2ggdG8gb3BlbiB0aGUgd2luZG93LlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBPcGVuKGxvYz86IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvQm94U2VydmljZS5PcGVuKHRoaXMsIGxvYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5mbyBib3guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5mbyBib3guXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBUb1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gJ0luZm9Cb3hDb21wb25lbnQtJyArIHRoaXMuX2lkOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIGNsaWNrIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIEhhbmRsZUV2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faW5mb0JveFNlcnZpY2UuQ3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdpbmZvd2luZG93Y2xvc2UnLCB0aGlzKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICB0aGlzLkluZm9Cb3hDbG9zZS5lbWl0KHRoaXMuX2lkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5nZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBTZXRJbmZvV2luZG93T3B0aW9ucyhjaGFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoY2hhbmdlc1sndGl0bGUnXSkgeyBvcHRpb25zLnRpdGxlID0gdGhpcy5UaXRsZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZGVzY3JpcHRpb24nXSkgeyBvcHRpb25zLmRlc2NyaXB0aW9uID0gdGhpcy5EZXNjcmlwdGlvbjsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZGlzYWJsZUF1dG9QYW4nXSkgeyBvcHRpb25zLmRpc2FibGVBdXRvUGFuID0gdGhpcy5EaXNhYmxlQXV0b1BhbjsgfVxuICAgICAgICBpZiAoY2hhbmdlc1sndmlzaWJsZSddKSB7IG9wdGlvbnMudmlzaWJsZSA9IHRoaXMuVmlzaWJsZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1sneE9mZnNldCddIHx8IGNoYW5nZXNbJ3lPZmZzZXQnXSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl4ZWxPZmZzZXQgPT0gbnVsbCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07IH1cbiAgICAgICAgICAgIG9wdGlvbnMucGl4ZWxPZmZzZXQueCA9IHRoaXMueE9mZnNldDtcbiAgICAgICAgICAgIG9wdGlvbnMucGl4ZWxPZmZzZXQueSA9IHRoaXMueU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbmZvQm94U2VydmljZS5TZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgRGlyZWN0aXZlLCBTaW1wbGVDaGFuZ2UsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLFxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElNYXJrZXJFdmVudCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1ldmVudCc7XG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi9pbmZvYm94JztcblxuLyoqXG4gKiBpbnRlcm5hbCBjb3VudGVyIHRvIHVzZSBhcyBpZHMgZm9yIG1hcmtlci5cbiAqL1xubGV0IG1hcmtlcklkID0gMDtcblxuLyoqXG4gKiBNYXBNYXJrZXJEaXJlY3RpdmUgcmVuZGVycyBhIG1hcCBtYXJrZXIgaW5zaWRlIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmV9IGZyb20gJy4uLic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcbiAqICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICB9XG4gKiBgXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDx4LW1hcC1tYXJrZXIgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW0xhYmVsXT1cIidNJ1wiPjwveC1tYXAtbWFya2VyPlxuICogICA8L3gtbWFwPlxuICogYFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleHBvcnRcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd4LW1hcC1tYXJrZXInXG59KVxuZXhwb3J0IGNsYXNzIE1hcE1hcmtlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcml2YXRlIF9jbGlja1RpbWVvdXQ6IFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgcHJpdmF0ZSBfZXZlbnRzOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICAgIHByaXZhdGUgX2lkOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfaW5DbHVzdGVyTGF5ZXIgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9pbkN1c3RvbUxheWVyID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBbnkgSW5mb0JveCB0aGF0IGlzIGEgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBtYXJrZXJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJbmZvQm94Q29tcG9uZW50KSBwcm90ZWN0ZWQgX2luZm9Cb3g6IEluZm9Cb3hDb21wb25lbnQ7XG5cbiAgICBwcml2YXRlIF9sYXllcklkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfbWFya2VyQWRkZWRUb01hbmdlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogIEljb24gYW5jaG9yIHJlbGF0aXZlIHRvIG1hcmtlciByb290XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIEFuY2hvcjogSVBvaW50O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgRHJhZzogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBEcmFnRW5kOiBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIG1hcmtlciBjYW4gYmUgZHJhZ2dlZC4gRGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgRHJhZ2dhYmxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIERyYWdTdGFydDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiBhIG1hcmtlciBpY29uIGlzIGJlaW5nIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBEeW5hbWljTWFya2VyQ3JlYXRlZDogRXZlbnRFbWl0dGVyPElNYXJrZXJJY29uSW5mbz4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJJY29uSW5mbz4oKTtcblxuICAgIC8qKlxuICAgICAqIEljb24gaGVpZ2h0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIEhlaWdodDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSW5mb3JtYXRpb24gZm9yIGR5bmFtaWMsIGN1c3RvbSBjcmVhdGVkIGljb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBJY29uSW5mbzogSU1hcmtlckljb25JbmZvO1xuXG4gICAgLyoqXG4gICAgICogSWNvbiAodGhlIFVSTCBvZiB0aGUgaW1hZ2UpIGZvciB0aGUgZm9yZWdyb3VuZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgSWNvblVybDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB0byBpbmRpY2lhdGUgd2hldGhlciB0aGlzIGlzIHRoZSBmaXJzdCBtYXJrZXIgaW4gYSBzZXQuXG4gICAgICogVXNlIHRoaXMgZm9yIGJ1bGsgb3BlcmF0aW9ucyAocGFydGljdWxhcmlseSBjbHVzdGVyaW5nKSB0byBlbnN1cmUgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIElzRmlyc3RJblNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB0byBpbmRpY2lhdGUgd2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IG1hcmtlciBpbiBhIHNldC5cbiAgICAgKiBVc2UgdGhpcyBmb3IgYnVsayBvcGVyYXRpb25zIChwYXJ0aWN1bGFyaWx5IGNsdXN0ZXJpbmcpIHRvIGVuc3VyZSBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgSXNMYXN0SW5TZXQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIChhIHNpbmdsZSB1cHBlcmNhc2UgY2hhcmFjdGVyKSBmb3IgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXRpdHVkZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBMYXRpdHVkZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvbmdpdHVkZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBMb25naXR1ZGU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIE1hcmtlckNsaWNrOiBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogQXJiaXRhcnkgbWV0YWRhdGEgdG8gYXNzaWduIHRvIHRoZSBNYXJrZXIuIFRoaXMgaXMgdXNlZnVsIGZvciBldmVudHNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIE1vdXNlRG93bjogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIG1hcmtlciBtb3VzZW91dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIG1hcmtlciBtb3VzZW92ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIE1vdXNlT3ZlcjogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgbWFya2VyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIHJpZ2h0LWNsaWNrZWQgb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFJpZ2h0Q2xpY2s6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpdGxlIG9mIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBtYXJrZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEljb24gV2lkdGhcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgV2lkdGg6IG51bWJlcjtcblxuICAgIC8vL1xuICAgIC8vLyBEZWxlZ2F0ZXNcbiAgICAvLy9cblxuXG5cblxuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0c3doZXRoZXIgdGhlIG1hcmtlciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBtYXJrZXIgc2VydmljZSBhbmQgaXMgcmVhZHkgZm9yIHVzZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IEFkZGVkVG9NYW5hZ2VyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcjsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaWQgb2YgdGhlIG1hcmtlciBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IElkKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9pZDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgaW4gYSBjbHVzdGVyIGxheWVyLiBTZWUge0BsaW5rIENsdXN0ZXJMYXllcn0uXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBJbkNsdXN0ZXJMYXllcigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2luQ2x1c3RlckxheWVyOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyBpbiBhIGN1c3RvbSBsYXllci4gU2VlIHtAbGluayBNYXBMYXllcn0uXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBJbkN1c3RvbUxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DdXN0b21MYXllcjsgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0cyB0aGUgaWQgb2YgdGhlIExheWVyIHRoZSBtYXJrZXIgYmVsb25ncyB0by5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IExheWVySWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xheWVySWQ7IH1cblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBNYXJrZXJEaXJlY3RpdmUuXG4gICAgICogQHBhcmFtIF9tYXJrZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcmtlclNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBfY29udGFpbmVyUmVmIC0gVmlldyBjb250YWluZXIgaG9zdGluZyB0aGUgbWFya2VyLlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHBhcmVudCBsYXllciB0aHJvdWdoIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXJrZXJTZXJ2aWNlOiBNYXJrZXJTZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy5faWQgPSAobWFya2VySWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgYSBtYXJrZXIgZ2VvIGxvY2F0aW9uIHRvIGEgcGl4ZWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbbG9jXSAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzLiBJZiBudWxsLCB0aGUgbWFya2VyJ3MgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgYW4ge0BsaW5rIElQb2ludH0gcmVwcmVzZW50aW5nIHRoZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BpeGVsKGxvYz86IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGxvYyA/IGxvYyA6IHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciBDb21wb25lbnQgY29udGVudCBpbml0aWFsaXphdGlvbi4gUGFydCBvZiBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7IHRoaXMuX2luZm9Cb3guSG9zdE1hcmtlciA9IHRoaXM7IH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZTogc3RyaW5nID0gdGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWU7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1jbHVzdGVyLWxheWVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luQ2x1c3RlckxheWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1tYXAtbGF5ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5DdXN0b21MYXllciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXllcklkID0gTnVtYmVyKHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC5hdHRyaWJ1dGVzWydsYXllcklkJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyU2VydmljZS5BZGRNYXJrZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIGNvbGxlY3Rpb24gb2YgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuTGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLkxvbmdpdHVkZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX21hcmtlckFkZGVkVG9NYW5nZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydMYXRpdHVkZSddIHx8IGNoYW5nZXNbJ0xvbmdpdHVkZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZU1hcmtlclBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydUaXRsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZVRpdGxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydMYWJlbCddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUxhYmVsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydEcmFnZ2FibGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyU2VydmljZS5VcGRhdGVEcmFnZ2FibGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0ljb25VcmwnXSB8fCBjaGFuZ2VzWydJY29uSW5mbyddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUljb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0FuY2hvciddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUFuY2hvcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snVmlzaWJsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZVZpc2libGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX21hcmtlclNlcnZpY2UuRGVsZXRlTWFya2VyKHRoaXMpO1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBNYXJrZXIgSWQuXG4gICAgICogQHJldHVybnMgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciBpZC5cbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwTWFya2VyLScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhcmlvdXMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IF9nZXRFdmVudEFyZzogKGU6IE1vdXNlRXZlbnQpID0+IElNYXJrZXJFdmVudCA9IGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBNYXJrZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgQ2xpY2s6IGUsXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXG4gICAgICAgICAgICAgICAgUGl4ZWxzOiB0aGlzLl9tYXJrZXJTZXJ2aWNlLkdldFBpeGVsc0Zyb21DbGljayhlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaCh0aGlzLl9tYXJrZXJTZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xpY2snLCB0aGlzKS5zdWJzY3JpYmUoKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vL1xuICAgICAgICAgICAgLy8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNpbmNlIG1hcCB3aWxsIHRyZWF0IGEgZG91YmxlY2xpY2sgZmlyc3QgYXMgdHdvIGNsaWNrcy4uLidcbiAgICAgICAgICAgIC8vL1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gdGltZXIoMzAwKS5zdWJzY3JpYmUobiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmZvQm94Lk9wZW4odGhpcy5fbWFya2VyU2VydmljZS5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuTWFya2VyQ2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaCh0aGlzLl9tYXJrZXJTZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnZGJsY2xpY2snLCB0aGlzKS5zdWJzY3JpYmUoKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGlja1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlja1RpbWVvdXQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5EYmxDbGljay5lbWl0KF9nZXRFdmVudEFyZyhlKSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWcnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZy5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdFbmQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZ3N0YXJ0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdTdGFydC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZWRvd24nLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VEb3duLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU1vdmUuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdXQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VPdXQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlT3Zlci5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlVXAuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncmlnaHRjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5SaWdodENsaWNrLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcyA9IHRoaXMuX21hcmtlclNlcnZpY2UuQ3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCB0aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2gob3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBPbkNoYW5nZXMsXG4gICAgT25Jbml0LFxuICAgIE9uRGVzdHJveSxcbiAgICBTaW1wbGVDaGFuZ2UsXG4gICAgVmlld0NoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgRWxlbWVudFJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBOZ1pvbmVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcHNlcnZpY2VmYWN0b3J5JztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFya2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9pbmZvYm94LnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbGF5ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3BvbHlnb24uc2VydmljZSc7XG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pYm94JztcbmltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xuaW1wb3J0IHsgTWFwVHlwZUlkIH0gZnJvbSAnLi4vbW9kZWxzL21hcC10eXBlLWlkJztcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XG5cbi8qKlxuICogUmVuZGVycyBhIG1hcCBiYXNlZCBvbiBhIGdpdmVuIHByb3ZpZGVyLlxuICogKipJbXBvcnRhbnQgbm90ZSoqOiBUbyBiZSBhYmxlIHNlZSBhIG1hcCBpbiB0aGUgYnJvd3NlciwgeW91IGhhdmUgdG8gZGVmaW5lIGEgaGVpZ2h0IGZvciB0aGUgQ1NTXG4gKiBjbGFzcyBgbWFwLWNvbnRhaW5lcmAuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50fSBmcm9tICcuLi4nO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cbiAqIGBdLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPjwveC1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleHBvcnRcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd4LW1hcCcsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogTWFwU2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5XSwgdXNlRmFjdG9yeTogTWFwU2VydmljZUNyZWF0b3IgfSxcbiAgICAgICAgeyBwcm92aWRlOiBNYXJrZXJTZXJ2aWNlLCBkZXBzOiBbTWFwU2VydmljZUZhY3RvcnksIE1hcFNlcnZpY2UsIExheWVyU2VydmljZSwgQ2x1c3RlclNlcnZpY2VdLCB1c2VGYWN0b3J5OiBNYXJrZXJTZXJ2aWNlRmFjdG9yeSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBJbmZvQm94U2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5LCBNYXBTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE1hcmtlclNlcnZpY2VdLCB1c2VGYWN0b3J5OiBJbmZvQm94U2VydmljZUZhY3RvcnlcbiAgICAgICAgfSxcbiAgICAgICAgeyBwcm92aWRlOiBMYXllclNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZV0sIHVzZUZhY3Rvcnk6IExheWVyU2VydmljZUZhY3RvcnkgfSxcbiAgICAgICAgeyBwcm92aWRlOiBDbHVzdGVyU2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5LCBNYXBTZXJ2aWNlXSwgdXNlRmFjdG9yeTogQ2x1c3RlclNlcnZpY2VGYWN0b3J5IH0sXG4gICAgICAgIHsgcHJvdmlkZTogUG9seWdvblNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogUG9seWdvblNlcnZpY2VGYWN0b3J5IH0sXG4gICAgICAgIHsgcHJvdmlkZTogUG9seWxpbmVTZXJ2aWNlLCBkZXBzOiBbTWFwU2VydmljZUZhY3RvcnksIE1hcFNlcnZpY2UsIExheWVyU2VydmljZV0sIHVzZUZhY3Rvcnk6IFBvbHlsaW5lU2VydmljZUZhY3RvcnkgfVxuICAgIF0sXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiAjY29udGFpbmVyIGNsYXNzPSdtYXAtY29udGFpbmVyLWlubmVyJz48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz0nbWFwLWNvbnRlbnQnPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIHN0eWxlczogW2BcbiAgICAgICAgLm1hcC1jb250YWluZXItaW5uZXIgeyB3aWR0aDogaW5oZXJpdDsgaGVpZ2h0OiBpbmhlcml0OyB9XG4gICAgICAgIC5tYXAtY29udGFpbmVyLWlubmVyIGRpdiB7IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IH1cbiAgICAgICAgLm1hcC1jb250ZW50IHsgZGlzcGxheTpub25lOyB9XG4gICAgYF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBNYXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcml2YXRlIF9sb25naXR1ZGUgPSAwO1xuICAgIHByaXZhdGUgX2xhdGl0dWRlID0gMDtcbiAgICBwcml2YXRlIF96b29tID0gMDtcbiAgICBwcml2YXRlIF9jbGlja1RpbWVvdXQ6IG51bWJlciB8IE5vZGVKUy5UaW1lcjtcbiAgICBwcml2YXRlIF9vcHRpb25zOiBJTWFwT3B0aW9ucyA9IHt9O1xuICAgIHByaXZhdGUgX2JveDogSUJveCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfbWFwUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLm1hcC1jb250YWluZXInKSBwdWJsaWMgX2NvbnRhaW5lckNsYXNzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBAVmlld0NoaWxkKCdjb250YWluZXInKSBwcml2YXRlIF9jb250YWluZXI6IEVsZW1lbnRSZWY7XG4gICAgQENvbnRlbnRDaGlsZHJlbihNYXBNYXJrZXJEaXJlY3RpdmUpIHByaXZhdGUgX21hcmtlcnM6IEFycmF5PE1hcE1hcmtlckRpcmVjdGl2ZT47XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3Igc2V0cyB0aGUgbWF4aW11bSBhbmQgbWluaW11bSBib3VuZGluZyBib3ggZm9yIG1hcC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgQm94KCk6IElCb3ggeyByZXR1cm4gdGhpcy5fYm94OyB9XG4gICAgcHVibGljIHNldCBCb3godmFsOiBJQm94KSB7IHRoaXMuX2JveCA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBsYXRpdHVkZSB0aGF0IHNldHMgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBMYXRpdHVkZSgpOiBudW1iZXIgfCBzdHJpbmcgeyByZXR1cm4gdGhpcy5fbG9uZ2l0dWRlOyB9XG4gICAgcHVibGljIHNldCBMYXRpdHVkZSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2xhdGl0dWRlID0gdGhpcy5Db252ZXJ0VG9EZWNpbWFsKHZhbHVlKTtcbiAgICAgICAgdGhpcy5VcGRhdGVDZW50ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxvbmdpdHVkZSB0aGF0IHNldHMgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBMb25naXR1ZGUoKTogbnVtYmVyIHwgc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2xvbmdpdHVkZTsgfVxuICAgIHB1YmxpYyBzZXQgTG9uZ2l0dWRlKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbG9uZ2l0dWRlID0gdGhpcy5Db252ZXJ0VG9EZWNpbWFsKHZhbHVlKTtcbiAgICAgICAgdGhpcy5VcGRhdGVDZW50ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgZ2VuZXJhbCBtYXAgT3B0aW9uc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBPcHRpb25zKCk6IElNYXBPcHRpb25zIHsgcmV0dXJuIHRoaXMuX29wdGlvbnM7IH1cbiAgICBwdWJsaWMgc2V0IE9wdGlvbnModmFsOiBJTWFwT3B0aW9ucykgeyB0aGlzLl9vcHRpb25zID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDhgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBab29tKCk6IG51bWJlciB8IHN0cmluZyB7IHJldHVybiB0aGlzLl96b29tOyB9XG4gICAgcHVibGljIHNldCBab29tKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fem9vbSA9IHRoaXMuQ29udmVydFRvRGVjaW1hbCh2YWx1ZSwgOCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fem9vbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU2V0Wm9vbSh0aGlzLl96b29tKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgYm91bmRpbmcgYm94IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgQm91bmRzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SUJveD4gPSBuZXcgRXZlbnRFbWl0dGVyPElCb3g+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIENlbnRlckNoYW5nZTogRXZlbnRFbWl0dGVyPElMYXRMb25nPiA9IG5ldyBFdmVudEVtaXR0ZXI8SUxhdExvbmc+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrIG9uIGFcbiAgICAgKiBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgTWFwQ2xpY2s6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICogb24gYSBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgTWFwRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciByaWdodC1jbGlja3Mgb24gdGhlIG1hcCAoYnV0IG5vdCB3aGVuIHRoZXkgY2xpY2tcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBNYXBSaWdodENsaWNrOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xuICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIE1hcE1vdXNlT3ZlcjogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3Mgb24gdGhlIG1hcCAoYnV0IG5vdCB3aGVuIHRoZXkgY2xpY2tcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBNYXBNb3VzZU91dDogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3Mgb24gdGhlIG1hcCAoYnV0IG5vdCB3aGVuIHRoZXkgY2xpY2tcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBNYXBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBzZXJ2aWNlIGlzIGF2YWlsYWJsZSBhbmQgdGhlIG1hcHMgaGFzIGJlZW5cbiAgICAgKiBJbml0aWFsaXplZCAoYnV0IG5vdCBuZWNlc3NhcmlseSBjcmVhdGVkKS4gSXQgY29udGFpbnMgYSBQcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIHJldHVybnNcbiAgICAgKiB0aGUgbWFpbiBtYXAgb2JqZWN0IG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIE1hcFByb21pc2U6IEV2ZW50RW1pdHRlcjxQcm9taXNlPGFueT4+ID0gbmV3IEV2ZW50RW1pdHRlcjxQcm9taXNlPGFueT4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaWl0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIFpvb21DaGFuZ2U6IEV2ZW50RW1pdHRlcjxOdW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxOdW1iZXI+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIHNlcnZpY2UgaXMgYXZhaWxhYmxlIGFuZCB0aGUgbWFwcyBoYXMgYmVlblxuICAgICAqIEluaXRpYWxpemVkXG4gICAgICogQG1lbWJlck9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIE1hcFNlcnZpY2U6IEV2ZW50RW1pdHRlcjxNYXBTZXJ2aWNlPiA9IG5ldyBFdmVudEVtaXR0ZXI8TWFwU2VydmljZT4oKTtcblxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcENvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlZCBpbXBsZW1lbnRhdGlvbiBvZiBhIG1hcCBzZXJ2aWNlIGZvciB0aGUgdW5kZXJseWluZyBtYXBzIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb25zLlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gQ29tcG9uZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5Jbml0TWFwSW5zdGFuY2UodGhpcy5fY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLk1hcFByb21pc2UuZW1pdCh0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UpO1xuICAgICAgICB0aGlzLk1hcFNlcnZpY2UuZW1pdCh0aGlzLl9tYXBTZXJ2aWNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIHRoZSBkYXRhYm91ZCBwcm9wZXJ0aWVzIG9jY3VyLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9tYXBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlc1snQm94J10pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm94ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TZXRWaWV3T3B0aW9ucyg8SU1hcE9wdGlvbnM+e1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB0aGlzLl9ib3hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ09wdGlvbnMnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU2V0TWFwT3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uIEZyZWVzIHRoZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuRGlzcG9zZU1hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgcmVzaXplIGV2ZW50IG9uIHRoZSBtYXAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGdldHMgcmVzb2x2ZWQgYWZ0ZXIgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIFRyaWdnZXJSZXNpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIC8vIE5vdGU6IFdoZW4gd2Ugd291bGQgdHJpZ2dlciB0aGUgcmVzaXplIGV2ZW50IGFuZCBzaG93IHRoZSBtYXAgaW4gdGhlIHNhbWUgdHVybiAod2hpY2ggaXMgYVxuICAgICAgICAvLyBjb21tb24gY2FzZSBmb3IgdHJpZ2dlcmluZyBhIHJlc2l6ZSBldmVudCksIHRoZW4gdGhlIHJlc2l6ZSBldmVudCB3b3VsZCBub3RcbiAgICAgICAgLy8gd29yayAodG8gc2hvdyB0aGUgbWFwKSwgc28gd2UgdHJpZ2dlciB0aGUgZXZlbnQgaW4gYSB0aW1lb3V0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgKCkgPT4geyByZXR1cm4gdGhpcy5fbWFwU2VydmljZS5UcmlnZ2VyTWFwRXZlbnQoJ3Jlc2l6ZScpLnRoZW4oKCkgPT4gcmVzb2x2ZSgpKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQcml2YXRlIG1ldGhvZHMuXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIG51bWJlci1pc2ggdmFsdWUgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gW2RlZmF1bHRWYWx1ZT1udWxsXSAtIERlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHRoZSBjb252ZXJzaW9uIGNhbm5vdCBiZSBwZXJmb3JtZWQuXG4gICAgICogQHJldHVybnMgLSBDb252ZXJ0ZWQgbnVtYmVyIG9mIHRoZSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxuICAgICAqL1xuICAgIHByaXZhdGUgQ29udmVydFRvRGVjaW1hbCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBkZWZhdWx0VmFsdWU6IG51bWJlciA9IG51bGwpOiBudW1iZXIge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiA8bnVtYmVyPnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgaGFuZGxpbmcgdGhlIG1hcCBjbGljayBldmVudHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBIYW5kbGVNYXBDbGlja0V2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ2NsaWNrJykuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNpbmNlIGJpbmcgd2lsbCB0cmVhdCBhIGRvdWJsZWNsaWNrIGZpcnN0IGFzIHR3byBjbGlja3MuLi4nXG4gICAgICAgICAgICAvLy9cbiAgICAgICAgICAgIHRoaXMuX2NsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuTWFwQ2xpY2suZW1pdCg8TW91c2VFdmVudD5lKTtcbiAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PignZGJsY2xpY2snKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xpY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KDxOb2RlSlMuVGltZXI+dGhpcy5fY2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuTWFwRGJsQ2xpY2suZW1pdCg8TW91c2VFdmVudD5lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU3Vic2NyaWJlVG9NYXBFdmVudDxhbnk+KCdyaWdodGNsaWNrJykuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5NYXBSaWdodENsaWNrLmVtaXQoPE1vdXNlRXZlbnQ+ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PignbW91c2VvdmVyJykuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5NYXBNb3VzZU92ZXIuZW1pdCg8TW91c2VFdmVudD5lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU3Vic2NyaWJlVG9NYXBFdmVudDxhbnk+KCdtb3VzZW91dCcpLnN1YnNjcmliZShlID0+IHtcbiAgICAgICAgICAgIHRoaXMuTWFwTW91c2VPdXQuZW1pdCg8TW91c2VFdmVudD5lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU3Vic2NyaWJlVG9NYXBFdmVudDxhbnk+KCdtb3VzZW1vdmUnKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICB0aGlzLk1hcE1vdXNlTW92ZS5lbWl0KDxNb3VzZUV2ZW50PmUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyBtYXAgY2VudGVyIGNoYW5nZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBIYW5kbGVNYXBCb3VuZHNDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU3Vic2NyaWJlVG9NYXBFdmVudDx2b2lkPignYm91bmRzY2hhbmdlZCcpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkdldEJvdW5kcygpLnRoZW4oKGJvdW5kczogSUJveCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuQm91bmRzQ2hhbmdlLmVtaXQoYm91bmRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyBtYXAgY2VudGVyIGNoYW5nZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBIYW5kbGVNYXBDZW50ZXJDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU3Vic2NyaWJlVG9NYXBFdmVudDx2b2lkPignY2VudGVyY2hhbmdlZCcpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkdldENlbnRlcigpLnRoZW4oKGNlbnRlcjogSUxhdExvbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF0aXR1ZGUgIT09IGNlbnRlci5sYXRpdHVkZSB8fCB0aGlzLl9sb25naXR1ZGUgIT09IGNlbnRlci5sb25naXR1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF0aXR1ZGUgPSBjZW50ZXIubGF0aXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdpdHVkZSA9IGNlbnRlci5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ2VudGVyQ2hhbmdlLmVtaXQoPElMYXRMb25nPnsgbGF0aXR1ZGU6IHRoaXMuX2xhdGl0dWRlLCBsb25naXR1ZGU6IHRoaXMuX2xvbmdpdHVkZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgaGFuZGxpbmcgbWFwIHpvb20gY2hhbmdlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIEhhbmRsZU1hcFpvb21DaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuU3Vic2NyaWJlVG9NYXBFdmVudDx2b2lkPignem9vbWNoYW5nZWQnKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRab29tKCkudGhlbigoejogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pvb20gIT09IHopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbSA9IHo7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuWm9vbUNoYW5nZS5lbWl0KHopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsIC0gSHRtbCBlbGVtZW50cyB3aGljaCB3aWxsIGhvc3QgdGhlIG1hcCBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBJbml0TWFwSW5zdGFuY2UoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY2VudGVyID09IG51bGwpIHsgdGhpcy5fb3B0aW9ucy5jZW50ZXIgPSB7IGxhdGl0dWRlOiB0aGlzLl9sYXRpdHVkZSwgbG9uZ2l0dWRlOiB0aGlzLl9sb25naXR1ZGUgfTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuem9vbSA9PSBudWxsKSB7IHRoaXMuX29wdGlvbnMuem9vbSA9IHRoaXMuX3pvb207IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLm1hcFR5cGVJZCA9PSBudWxsKSB7IHRoaXMuX29wdGlvbnMubWFwVHlwZUlkID0gTWFwVHlwZUlkLmh5YnJpZDsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2JveCAhPSBudWxsKSB7IHRoaXMuX29wdGlvbnMuYm91bmRzID0gdGhpcy5fYm94OyB9XG4gICAgICAgICAgICB0aGlzLl9tYXBQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXAoZWwsIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5IYW5kbGVNYXBDZW50ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuSGFuZGxlTWFwQm91bmRzQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcFpvb21DaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuSGFuZGxlTWFwQ2xpY2tFdmVudHMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbWFwIGNlbnRlciBiYXNlZCBvbiB0aGUgZ2VvIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIFVwZGF0ZUNlbnRlcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMuX2xvbmdpdHVkZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlNldENlbnRlcih7XG4gICAgICAgICAgICBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsXG4gICAgICAgICAgICBsb25naXR1ZGU6IHRoaXMuX2xvbmdpdHVkZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBjbHVzdGVyIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xuICogdXMgdG8gdXNlIGxhbWRhIGZ1bmN0aW9ucyBpbmxpbmUuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIGYgLSBUaGUge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBDbHVzdGVyIFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQ2x1c3RlclNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2UgeyByZXR1cm4gZi5DcmVhdGVDbHVzdGVyU2VydmljZShtKTsgfVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBpbmZvYm94IHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xuICogdXMgdG8gdXNlIGxhbWRhIGZ1bmN0aW9ucyBpbmxpbmUuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIGYgLSBUaGUge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcmtlclNlcnZpY2V9IGluc3RhbmNlLlxuICogQHJldHVybnMgLSBBIGNvbmNyZXRlIGluc3RhbmNlIG9mIGEgSW5mb0JveCBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJbmZvQm94U2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsXG4gICAgbWE6IE1hcmtlclNlcnZpY2UpOiBJbmZvQm94U2VydmljZSB7IHJldHVybiBmLkNyZWF0ZUluZm9Cb3hTZXJ2aWNlKG0sIG1hKTsgfVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBsYXllciBzZXJ2aWNlIGluc3RhbmNlLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIGNvbnN0cmFpbnRzIHdpdGggQU9UIHRoYXQgZG8gbm8gYWxsb3dcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxuICogQHJldHVybnMgLSBBIGNvbmNyZXRlIGluc3RhbmNlIG9mIGEgTGF5ZXIgU2VydmljZSBiYXNlZCBvbiB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gTGF5ZXJTZXJ2aWNlRmFjdG9yeShmOiBNYXBTZXJ2aWNlRmFjdG9yeSwgbTogTWFwU2VydmljZSk6IExheWVyU2VydmljZSB7IHJldHVybiBmLkNyZWF0ZUxheWVyU2VydmljZShtKTsgfVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtYXAgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMgLSBBIGNvbmNyZXRlIGluc3RhbmNlIG9mIGEgTWFwU2VydmljZSBiYXNlZCBvbiB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gTWFwU2VydmljZUNyZWF0b3IoZjogTWFwU2VydmljZUZhY3RvcnkpOiBNYXBTZXJ2aWNlIHsgcmV0dXJuIGYuQ3JlYXRlKCk7IH1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbWFya2VyIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xuICogdXMgdG8gdXNlIGxhbWRhIGZ1bmN0aW9ucyBpbmxpbmUuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIGYgLSBUaGUge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbCAtIEEge0BsaW5rIExheWVyU2VydmljZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gYyAtIEEge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIE1hcmtlciBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYXJrZXJTZXJ2aWNlRmFjdG9yeShmOiBNYXBTZXJ2aWNlRmFjdG9yeSwgbTogTWFwU2VydmljZSwgbDogTGF5ZXJTZXJ2aWNlLCBjOiBDbHVzdGVyU2VydmljZSk6IE1hcmtlclNlcnZpY2Uge1xuICAgIHJldHVybiBmLkNyZWF0ZU1hcmtlclNlcnZpY2UobSwgbCwgYyk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHBvbHlnb24gc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIG0gLSBBIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBsIC0gQSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIFBvbHlnb24gU2VydmljZSBiYXNlZCBvbiB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gUG9seWdvblNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlLCBsOiBMYXllclNlcnZpY2UpOiBQb2x5Z29uU2VydmljZSB7XG4gICAgcmV0dXJuIGYuQ3JlYXRlUG9seWdvblNlcnZpY2UobSwgbCk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHBvbHlsaW5lIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xuICogdXMgdG8gdXNlIGxhbWRhIGZ1bmN0aW9ucyBpbmxpbmUuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIGYgLSBUaGUge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbCAtIEEge0BsaW5rIExheWVyU2VydmljZX0gaW5zdGFuY2UuXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBQb2x5bGluZSBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQb2x5bGluZVNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlLCBsOiBMYXllclNlcnZpY2UpOiBQb2x5bGluZVNlcnZpY2Uge1xuICAgIHJldHVybiBmLkNyZWF0ZVBvbHlsaW5lU2VydmljZShtLCBsKTtcbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBTaW1wbGVDaGFuZ2UsXG4gICAgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbGF5ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuL21hcC1tYXJrZXInO1xuXG4vKipcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgbXVsdGlwbGUgbGF5ZXJzLlxuICovXG5sZXQgbGF5ZXJJZCA9IDA7XG5cbi8qKlxuICogTWFwTGF5ZXJEaXJlY3RpdmUgY3JlYXRlcyBhIGxheWVyIG9uIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmV9IGZyb20gJy4uLic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcbiAqICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICB9XG4gKiBgXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtab29tXT0nem9vbSc+XG4gKiAgICAgPHgtbWFwLWxheWVyIFtWaXNpYmxlXT0ndmlzaWJsZSc+XG4gKiAgICAgICAgIDx4LW1hcC1tYXJrZXIgW0xhdGl0dWRlXT0nbGF0JyBbTG9uZ2l0dWRlXT0nbG5nJyBbTGFiZWxdPScnTScnPjwveC1tYXAtbWFya2VyPlxuICogICAgIDwveC1tYXAtbGF5ZXI+XG4gKiAgIDwveC1tYXA+XG4gKiBgXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4cG9ydFxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3gtbWFwLWxheWVyJ1xufSlcbmV4cG9ydCBjbGFzcyBNYXBMYXllckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByb3RlY3RlZCBfdmlzaWJsZSA9IHRydWU7XG4gICAgcHJvdGVjdGVkIF9hZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgIHByb3RlY3RlZCBfaWQ6IG51bWJlcjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTWFwTWFya2VyRGlyZWN0aXZlKSBwcm90ZWN0ZWQgX21hcmtlcnM6IEFycmF5PE1hcE1hcmtlckRpcmVjdGl2ZT47XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxheWVyIHZpc2liaWxpdHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IFZpc2libGUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl92aXNpYmxlOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgVmlzaWJsZSh2YWw6IGJvb2xlYW4pIHsgdGhpcy5fdmlzaWJsZSA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGF5ZXIgaWQuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IElkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9pZDsgfVxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcExheWVyRGlyZWN0aXZlLlxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JldGVkIGltcGxlbWVudGF0aW9uIG9mIGEgbGF5ZXIgc2VydmljZSBmb3IgdGhlIHVuZGVybHlpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICogR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb25zLlxuICAgICAqIEBwYXJhbSBfY29udGFpbmVyUmVmIC0gUmVmZXJlbmNlIHRvIHRoZSBjb250YWluZXIgaG9zdGluZyB0aGUgbWFwIGNhbnZhcy4gR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLCBwcm90ZWN0ZWQgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLl9pZCA9IGxheWVySWQrKztcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBDb21wb25lbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYXR0cmlidXRlc1snbGF5ZXJJZCddID0gdGhpcy5faWQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkFkZExheWVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRlZFRvTWFuYWdlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdlcyB0byB0aGUgZGF0YWJvdWQgcHJvcGVydGllcyBvY2N1ci4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIENoYW5nZXMgdGhhdCBoYXZlIG9jY3VyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb01hbmFnZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcih0aGlzKS50aGVuKGwgPT4ge1xuICAgICAgICAgICAgICAgIGwuU2V0VmlzaWJsZSghbC5HZXRWaXNpYmxlKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkRlbGV0ZUxheWVyKHRoaXMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IElDbHVzdGVySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ljbHVzdGVyLWljb24taW5mbyc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlLFxuICAgIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9tb2RlbHMvbGF5ZXInO1xuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1wbGFjZW1lbnQtbW9kZSc7XG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mb30gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NsdXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lzcGlkZXItY2x1c3Rlci1vcHRpb25zJztcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLWxheWVyJztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgbGF5ZXIgb24gYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxuICogIHN0eWxlczogW2BcbiAqICAgLm1hcC1jb250YWluZXIge1xuICogICAgIGhlaWdodDogMzAwcHg7XG4gKiAgIH1cbiAqIGBdLFxuICogdGVtcGxhdGU6IGBcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09J2xhdCcgW0xvbmdpdHVkZV09J2xuZycgW1pvb21dPSd6b29tJz5cbiAqICAgICA8eC1jbHVzdGVyLWxheWVyIFtWaXNpYmxlXT0ndmlzaWJsZSc+XG4gKiAgICAgICAgIDx4LW1hcC1tYXJrZXIgW0xhdGl0dWRlXT0nbGF0JyBbTG9uZ2l0dWRlXT0nbG5nJyBbTGFiZWxdPScnTScnPjwveC1tYXAtbWFya2VyPlxuICogICAgIDwveC1jbHVzdGVyLWxheWVyPlxuICogICA8L3gtbWFwPlxuICogYFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleHBvcnRcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd4LWNsdXN0ZXItbGF5ZXInXG59KVxuZXhwb3J0IGNsYXNzIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBleHRlbmRzIE1hcExheWVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfY2x1c3RlcmluZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHByaXZhdGUgX2NsdXN0ZXJQbGFjZW1lbnRNb2RlOiBDbHVzdGVyUGxhY2VtZW50TW9kZSA9IENsdXN0ZXJQbGFjZW1lbnRNb2RlLk1lYW5WYWx1ZTtcbiAgICBwcml2YXRlIF9jbHVzdGVyQ2xpY2tBY3Rpb246IENsdXN0ZXJDbGlja0FjdGlvbiA9IENsdXN0ZXJDbGlja0FjdGlvbi5ab29tSW50b0NsdXN0ZXI7XG4gICAgcHJpdmF0ZSBfc3BpZGVyQ2x1c3Rlck9wdGlvbnM6IElTcGlkZXJDbHVzdGVyT3B0aW9ucztcbiAgICBwcml2YXRlIF96SW5kZXg6IG51bWJlcjtcbiAgICBwcml2YXRlIF9ncmlkU2l6ZTogbnVtYmVyO1xuICAgIHByaXZhdGUgX2xheWVyT2Zmc2V0OiBJUG9pbnQ7XG4gICAgcHJpdmF0ZSBfaWNvbkluZm86IElNYXJrZXJJY29uSW5mbztcbiAgICBwcml2YXRlIF9taW5pbXVtQ2x1c3RlclNpemU6IG51bWJlcjtcbiAgICBwcml2YXRlIF9zdHlsZXM6IEFycmF5PElDbHVzdGVySWNvbkluZm8+O1xuICAgIHByaXZhdGUgX3VzZUR5bmFtaWNTaXplTWFya2VyID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfZHluYW1pY01hcmtlckJhc2VTaXplID0gMTg7XG4gICAgcHJpdmF0ZSBfZHluYW1pY01hcmtlclJhbmdlczogTWFwPG51bWJlciwgc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KFtcbiAgICAgICAgWzEwLCAncmdiYSgyMCwgMTgwLCAyMCwgMC41KSddLFxuICAgICAgICBbMTAwLCAncmdiYSgyNTUsIDIxMCwgNDAsIDAuNSknXSxcbiAgICAgICAgW051bWJlci5NQVhfU0FGRV9JTlRFR0VSICwgJ3JnYmEoMjU1LCA0MCwgNDAsIDAuNSknXVxuICAgIF0pO1xuICAgIHByaXZhdGUgX3pvb21PbkNsaWNrID0gdHJ1ZTtcbiAgICBwcml2YXRlIF9pY29uQ3JlYXRpb25DYWxsYmFjazogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlZmludGlvbnNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGhlIENsdXN0ZXIgQ2xpY2sgQWN0aW9uIHtAbGluayBDbHVzdGVyQ2xpY2tBY3Rpb259LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlckNsaWNrQWN0aW9uKCk6IENsdXN0ZXJDbGlja0FjdGlvbiAgeyByZXR1cm4gdGhpcy5fY2x1c3RlckNsaWNrQWN0aW9uOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgQ2x1c3RlckNsaWNrQWN0aW9uKHZhbDogQ2x1c3RlckNsaWNrQWN0aW9uKSB7IHRoaXMuX2NsdXN0ZXJDbGlja0FjdGlvbiA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhlIGNsdXN0ZXJpbmcgbGF5ZXIgZW5hYmxlcyBjbHVzdGVyaW5nLiBXaGVuIHNldCB0byBmYWxzZSwgdGhlIGxheWVyXG4gICAgICogYmVoYXZlcyBsaWtlIGEgZ2VuZXJpYyBsYXllci4gVGhpcyBpcyBoYW5keSBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IGNsdXN0ZXJpbmcgYXQgY2VydGFpbiB6b29tIGxldmVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IENsdXN0ZXJpbmdFbmFibGVkKCk6IGJvb2xlYW4gIHsgcmV0dXJuIHRoaXMuX2NsdXN0ZXJpbmdFbmFibGVkOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgQ2x1c3RlcmluZ0VuYWJsZWQodmFsOiBib29sZWFuKSB7IHRoaXMuX2NsdXN0ZXJpbmdFbmFibGVkID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNsdXN0ZXIgcGxhY2VtZW50IG1vZGUuIHtAbGluayBDbHVzdGVyUGxhY2VtZW50TW9kZX1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IENsdXN0ZXJQbGFjZW1lbnRNb2RlKCk6IENsdXN0ZXJQbGFjZW1lbnRNb2RlICB7IHJldHVybiB0aGlzLl9jbHVzdGVyUGxhY2VtZW50TW9kZTsgfVxuICAgICAgICBwdWJsaWMgc2V0IENsdXN0ZXJQbGFjZW1lbnRNb2RlKHZhbDogQ2x1c3RlclBsYWNlbWVudE1vZGUpIHsgdGhpcy5fY2x1c3RlclBsYWNlbWVudE1vZGUgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2FsbGJhY2sgaW52b2tlZCB0byBjcmVhdGUgYSBjdXN0b20gY2x1c3RlciBtYXJrZXIuIE5vdGUgdGhhdCB3aGVuIHtAbGluayBVc2VEeW5hbWljU2l6ZU1hcmtlcnN9IGlzIGVuYWJsZWQsXG4gICAgICogeW91IGNhbm5vdCBzZXQgYSBjdXN0b20gbWFya2VyIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgQ3VzdG9tTWFya2VyQ2FsbGJhY2soKTogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nICB7IHJldHVybiB0aGlzLl9pY29uQ3JlYXRpb25DYWxsYmFjazsgfVxuICAgICAgICBwdWJsaWMgc2V0IEN1c3RvbU1hcmtlckNhbGxiYWNrKHZhbDogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlRHluYW1pY1NpemVNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyhcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKGBZb3UgY2Fubm90IHNldCBhIGN1c3RvbSBtYXJrZXIgY2FsbGJhY2sgd2hlbiBVc2VEeW5hbWljU2l6ZU1hcmtlcnMgaXMgc2V0IHRvIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIFNldCBVc2VEeW5hbWljU2l6ZU1ha2VycyB0byBmYWxzZS5gKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pY29uQ3JlYXRpb25DYWxsYmFjayA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBiYXNlIHNpemUgb2YgZHluYW1pYyBtYXJrZXJzIGluIHBpeGVscy4gVGhlIGFjdHVhbHkgc2l6ZSBvZiB0aGUgZHluYW1pYyBtYXJrZXIgaXMgYmFzZWQgb24gdGhpcy5cbiAgICAgKiBTZWUge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICAgICAgcHVibGljIGdldCBEeW5hbWljTWFya2VyQmFzZVNpemUoKTogbnVtYmVyICB7IHJldHVybiB0aGlzLl9keW5hbWljTWFya2VyQmFzZVNpemU7IH1cbiAgICAgICAgcHVibGljIHNldCBEeW5hbWljTWFya2VyQmFzZVNpemUodmFsOiBudW1iZXIpIHsgdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHJhbmdlcyB0byB1c2UgdG8gY2FsY3VsYXRlIGJyZWFrcG9pbnRzIGFuZCBjb2xvcnMgZm9yIGR5bmFtaWMgbWFya2Vycy5cbiAgICAgKiBUaGUgbWFwIGNvbnRhaW5zIGtleS92YWx1ZSBwYWlycywgd2l0aCB0aGUga2V5cyBiZWluZ1xuICAgICAqIHRoZSBicmVha3BvaW50IHNpemVzIGFuZCB0aGUgdmFsdWVzIHRoZSBjb2xvcnMgdG8gYmUgdXNlZCBmb3IgdGhlIGR5bmFtaWMgbWFya2VyIGluIHRoYXQgcmFuZ2UuIFNlZSB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IER5bmFtaWNNYXJrZXJSYW5nZXMoKTogTWFwPG51bWJlciwgc3RyaW5nPiAgeyByZXR1cm4gdGhpcy5fZHluYW1pY01hcmtlclJhbmdlczsgfVxuICAgICAgICBwdWJsaWMgc2V0IER5bmFtaWNNYXJrZXJSYW5nZXModmFsOiBNYXA8bnVtYmVyLCBzdHJpbmc+KSB7IHRoaXMuX2R5bmFtaWNNYXJrZXJSYW5nZXMgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZ3JpZCBzaXplIHRvIGJlIHVzZWQgZm9yIGNsdXN0ZXJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICAgICAgcHVibGljIGdldCBHcmlkU2l6ZSgpOiBudW1iZXIgIHsgcmV0dXJuIHRoaXMuX2dyaWRTaXplOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgR3JpZFNpemUodmFsOiBudW1iZXIpIHsgdGhpcy5fZ3JpZFNpemUgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgSWNvbkluZm8gdG8gYmUgdXNlZCB0byBjcmVhdGUgYSBjdXN0b20gY2x1c3RlciBtYXJrZXIuIFN1cHBvcnRzIGZvbnQtYmFzZWQsIFNWRywgZ3JhcGhpY3MgYW5kIG1vcmUuXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgSWNvbkluZm8oKTogSU1hcmtlckljb25JbmZvICB7IHJldHVybiB0aGlzLl9pY29uSW5mbzsgfVxuICAgICAgICBwdWJsaWMgc2V0IEljb25JbmZvKHZhbDogSU1hcmtlckljb25JbmZvKSB7IHRoaXMuX2ljb25JbmZvID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IExheWVyT2Zmc2V0KCk6IElQb2ludCAgeyByZXR1cm4gdGhpcy5fbGF5ZXJPZmZzZXQ7IH1cbiAgICAgICAgcHVibGljIHNldCBMYXllck9mZnNldCh2YWw6IElQb2ludCkgeyB0aGlzLl9sYXllck9mZnNldCA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHBpbnMgcmVxdWlyZWQgdG8gZm9ybSBhIGNsdXN0ZXJcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IE1pbmltdW1DbHVzdGVyU2l6ZSgpOiBudW1iZXIgIHsgcmV0dXJuIHRoaXMuX21pbmltdW1DbHVzdGVyU2l6ZTsgfVxuICAgICAgICBwdWJsaWMgc2V0IE1pbmltdW1DbHVzdGVyU2l6ZSh2YWw6IG51bWJlcikgeyB0aGlzLl9taW5pbXVtQ2x1c3RlclNpemUgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9ucyBmb3Igc3BpZGVyIGNsdXN0ZXJpbmcgYmVoYXZpb3IuIFNlZSB7QGxpbmsgSVNwaWRlckNsdXN0ZXJPcHRpb25zfVxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgU3BpZGVyQ2x1c3Rlck9wdGlvbnMoKTogSVNwaWRlckNsdXN0ZXJPcHRpb25zIHsgcmV0dXJuIHRoaXMuX3NwaWRlckNsdXN0ZXJPcHRpb25zOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgU3BpZGVyQ2x1c3Rlck9wdGlvbnModmFsOiBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMpIHsgdGhpcy5fc3BpZGVyQ2x1c3Rlck9wdGlvbnMgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2x1c3RlciBzdHlsZXNcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IFN0eWxlcygpOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPiB7IHJldHVybiB0aGlzLl9zdHlsZXM7IH1cbiAgICAgICAgcHVibGljIHNldCBTdHlsZXModmFsOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPikgeyB0aGlzLl9zdHlsZXMgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHVzZSBkeW5hbWljIG1hcmtlcnMuIER5bmFtaWMgbWFya2VycyBjaGFuZ2UgaW4gc2l6ZSBhbmQgY29sb3IgZGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBwaW5zIGluIHRoZSBjbHVzdGVyLiBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyB3aWxsIHRha2UgcHJlY2VuZGVuY2Ugb3ZlciBhbnkgY3VzdG9tIG1hcmtlciBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IFVzZUR5bmFtaWNTaXplTWFya2VycygpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3VzZUR5bmFtaWNTaXplTWFya2VyOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgVXNlRHluYW1pY1NpemVNYXJrZXJzKHZhbDogYm9vbGVhbikge1xuICAgICAgICAgICAgdGhpcy5fdXNlRHluYW1pY1NpemVNYXJrZXIgPSB2YWw7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSAobTogQXJyYXk8TWFya2VyPiwgaW5mbzogSU1hcmtlckljb25JbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUuQ3JlYXRlRHluYW1pY1NpemVNYXJrZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmxlbmd0aCwgaW5mbywgdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplLCB0aGlzLl9keW5hbWljTWFya2VyUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyLiBJZiBub3QgdXNlZCwgbGF5ZXJzIGdldCBzdGFja2VkIGluIHRoZSBvcmRlciBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgWkluZGV4KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl96SW5kZXg7IH1cbiAgICAgICAgcHVibGljIHNldCBaSW5kZXgodmFsOiBudW1iZXIpIHsgdGhpcy5fekluZGV4ID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGUgY2x1c3RlciBzaG91bGQgem9vbSBpbiBvbiBjbGlja1xuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgWm9vbU9uQ2xpY2soKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl96b29tT25DbGljazsgfVxuICAgICAgICBwdWJsaWMgc2V0IFpvb21PbkNsaWNrKHZhbDogYm9vbGVhbikgeyB0aGlzLl96b29tT25DbGljayA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZHluYW1pYyBzaXplIG1hcmtlciB0byBiZSB1c2VkIGZvciBjbHVzdGVyIG1hcmtlcnMgaWYgVXNlRHluYW1pY1NpemVNYXJrZXJzIGlzIHNldCB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpemUgLSBUaGUgbnVtYmVyIG9mIG1hcmtlcnMgaW4gdGhlIGNsdXN0ZXIuXG4gICAgICogQHBhcmFtIGluZm8gIC0gVGhlIGljb24gaW5mbyB0byBiZSB1c2VkLiBUaGlzIHdpbGwgYmUgaHlkcmF0ZWQgd2l0aFxuICAgICAqIHRoZSBhY3R1YWx5IGRpbWVuc2lvbnMgb2YgdGhlIGNyZWF0ZWQgbWFya2VycyBhbmQgaXMgdXNlZCBieSB0aGUgdW5kZXJseWluZyBtb2RlbC9zZXJ2aWNlc1xuICAgICAqIHRvIGNvcnJlY3RseSBvZmZzZXQgdGhlIG1hcmtlciBmb3IgY29ycmVjdCBwb3NpdGlvbmluZy5cbiAgICAgKiBAcGFyYW0gYmFzZU1hcmtlclNpemUgLSBUaGUgYmFzZSBzaXplIGZvciBkeW5taWMgbWFya2Vycy5cbiAgICAgKiBAcGFyYW0gcmFuZ2VzIC0gVGhlIHJhbmdlcyB0byB1c2UgdG8gY2FsY3VsYXRlIGJyZWFrcG9pbnRzIGFuZCBjb2xvcnMgZm9yIGR5bmFtaWMgbWFya2Vycy5cbiAgICAgKiBUaGUgbWFwIGNvbnRhaW5zIGtleS92YWx1ZSBwYWlycywgd2l0aCB0aGUga2V5cyBiZWluZ1xuICAgICAqIHRoZSBicmVha3BvaW50IHNpemVzIGFuZCB0aGUgdmFsdWVzIHRoZSBjb2xvcnMgdG8gYmUgdXNlZCBmb3IgdGhlIGR5bmFtaWMgbWFya2VyIGluIHRoYXQgcmFuZ2UuXG4gICAgICogQHJldHVybnMgLSBBbiBzdHJpbmcgY29udGFpbmluZyB0aGUgU1ZHIGZvciB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgQ3JlYXRlRHluYW1pY1NpemVNYXJrZXIoc2l6ZTogbnVtYmVyLCBpbmZvOiBJTWFya2VySWNvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWFya2VyU2l6ZTogbnVtYmVyLCByYW5nZXM6IE1hcDxudW1iZXIsIHN0cmluZz4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtcjogbnVtYmVyID0gYmFzZU1hcmtlclNpemU7XG4gICAgICAgIGNvbnN0IG91dGxpbmU6IG51bWJlciA9IG1yICogMC4zNTtcbiAgICAgICAgY29uc3QgdG90YWw6IG51bWJlciA9IHNpemU7XG4gICAgICAgIGNvbnN0IHI6IG51bWJlciA9IE1hdGgubG9nKHRvdGFsKSAvIE1hdGgubG9nKDEwKSAqIDUgKyBtcjtcbiAgICAgICAgY29uc3QgZDogbnVtYmVyID0gciAqIDI7XG4gICAgICAgIGxldCBmaWxsQ29sb3I6IHN0cmluZztcbiAgICAgICAgcmFuZ2VzLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgICAgICAgIGlmICh0b3RhbCA8PSBrICYmICFmaWxsQ29sb3IpIHsgZmlsbENvbG9yID0gdjsgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmaWxsQ29sb3IpIHsgZmlsbENvbG9yID0gJ3JnYmEoMjAsIDE4MCwgMjAsIDAuNSknOyB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIFNWRyBzdHJpbmcgb2YgdHdvIGNpcmNsZXMsIG9uZSBvbiB0b3Agb2YgdGhlIG90aGVyLCB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGFuZCBjb2xvci5cbiAgICAgICAgY29uc3Qgc3ZnOiBBcnJheTxhbnk+ID0gW2A8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JyR7ZH0nIGhlaWdodD0nJHtkfSc+YCxcbiAgICAgICAgICAgIGA8Y2lyY2xlIGN4PScke3J9JyBjeT0nJHtyfScgcj0nJHtyfScgZmlsbD0nJHtmaWxsQ29sb3J9Jy8+YCxcbiAgICAgICAgICAgIGA8Y2lyY2xlIGN4PScke3J9JyBjeT0nJHtyfScgcj0nJHtyIC0gb3V0bGluZX0nIGZpbGw9JyR7ZmlsbENvbG9yfScvPmAsXG4gICAgICAgICAgICBgPC9zdmc+YF07XG4gICAgICAgIGluZm8uc2l6ZSA9IHsgd2lkdGg6IGQsIGhlaWdodDogZCB9O1xuICAgICAgICBpbmZvLm1hcmtlck9mZnNldFJhdGlvID0geyB4OiAwLjUsIHk6IDAuNSB9O1xuICAgICAgICBpbmZvLnRleHRPZmZzZXQgPSB7IHg6IDAsIHk6IHIgLSA4IH07XG4gICAgICAgIHJldHVybiBzdmcuam9pbignJyk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JldGVkIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlciBsYXllciBzZXJ2aWNlIGZvciB0aGUgdW5kZXJseWluZyBtYXBzXG4gICAgICogaW1wbGVtZW50YXRpb25zLiBHZW5lcmFsbHkgcHJvdmlkZWQgdmlhIGluamVjdGlvbnMuXG4gICAgICogQHBhcmFtIF9jb250YWluZXJSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgdmlldyBjb250YWluZXIgb2YgdGhlIGxheWVyLiBHZW5lcmFsbHkgcHJvdmlkZWQgdmlhIGluamVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbGF5ZXJTZXJ2aWNlOiBDbHVzdGVyU2VydmljZSwgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICBzdXBlcihfbGF5ZXJTZXJ2aWNlLCBfY29udGFpbmVyUmVmKTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIGNvbGxlY3Rpb24gb2YgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb01hbmFnZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydDbHVzdGVyQ2xpY2tBY3Rpb24nXSkge1xuICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgdGhlIENsdXN0ZXJDbGlja0FjdGlvbiBhZnRlciB0aGUgbGF5ZXIgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGxheWVyc2VydmljZS4nKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyA9IHsgaWQ6IHRoaXMuX2lkIH07XG4gICAgICAgIGlmIChjaGFuZ2VzWydDbHVzdGVyaW5nRW5hYmxlZCddKSB7IG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLl9jbHVzdGVyaW5nRW5hYmxlZDsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snR3JpZFNpemUnXSkgeyBvcHRpb25zLmdyaWRTaXplID0gdGhpcy5fZ3JpZFNpemU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0xheWVyT2Zmc2V0J10pIHsgb3B0aW9ucy5sYXllck9mZnNldCA9IHRoaXMuX2xheWVyT2Zmc2V0OyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydTcGlkZXJDbHVzdGVyT3B0aW9ucyddKSB7IG9wdGlvbnMuc3BpZGVyQ2x1c3Rlck9wdGlvbnMgPSB0aGlzLl9zcGlkZXJDbHVzdGVyT3B0aW9uczsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snWkluZGV4J10pIHsgb3B0aW9ucy56SW5kZXggPSB0aGlzLl96SW5kZXg7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSkgeyBvcHRpb25zLnZpc2libGUgPSB0aGlzLl92aXNpYmxlOyB9XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKHRoaXMpLnRoZW4oKGw6IExheWVyKSA9PiB7XG4gICAgICAgICAgICBsLlNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBWaWV3Q29udGFpbmVyUmVmLFxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSVBvbHlnb25FdmVudCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlnb24tZXZlbnQnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuL2luZm9ib3gnO1xuXG5sZXQgcG9seWdvbklkID0gMDtcblxuLyoqXG4gKlxuICogTWFwUG9seWdvbkRpcmVjdGl2ZSByZW5kZXJzIGEgcG9seWdvbiBpbnNpZGUgYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZyb20gJy4uLic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAsXG4gKiAgc3R5bGVzOiBbYFxuICogICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cbiAqIGBdLFxuICogdGVtcGxhdGU6IGBcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cbiAqICAgICAgPHgtbWFwLXBvbHlnb24gW1BhdGhzXT1cInBhdGhcIj48L3gtbWFwLXBvbHlnb24+XG4gKiAgIDwveC1tYXA+XG4gKiBgXG4gKiB9KVxuICogYGBgXG4gKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd4LW1hcC1wb2x5Z29uJ1xufSlcbmV4cG9ydCBjbGFzcyBNYXBQb2x5Z29uRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2luQ3VzdG9tTGF5ZXIgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9pZDogbnVtYmVyO1xuICAgIHByaXZhdGUgX2xheWVySWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIF9hZGRlZFRvU2VydmljZSA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2V2ZW50czogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAgIC8vL1xuICAgIC8vLyBBbnkgSW5mb0JveCB0aGF0IGlzIGEgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBwb2x5Z29uXG4gICAgLy8vXG4gICAgQENvbnRlbnRDaGlsZChJbmZvQm94Q29tcG9uZW50KSBwcm90ZWN0ZWQgX2luZm9Cb3g6IEluZm9Cb3hDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRoaXMgUG9seWdvbiBoYW5kbGVzIG1vdXNlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIENsaWNrYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBzaGFwZSBvdmVyIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBEcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZWRpdCB0aGlzIHNoYXBlIGJ5IGRyYWdnaW5nIHRoZSBjb250cm9sXG4gICAgICogcG9pbnRzIHNob3duIGF0IHRoZSB2ZXJ0aWNlcyBhbmQgb24gZWFjaCBzZWdtZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgRWRpdGFibGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWxsIGNvbG9yIG9mIHRoZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgRmlsbENvbG9yOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsbCBvcGFjaXR5IGJldHdlZW4gMC4wIGFuZCAxLjBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIEZpbGxPcGFjaXR5OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFyZSBpbnRlcnByZXRlZCBhcyBnZW9kZXNpYyBhbmQgd2lsbFxuICAgICAqIGZvbGxvdyB0aGUgY3VydmF0dXJlIG9mIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlXG4gICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcbiAgICAgKiBnZW9kZXNpYyBwb2x5Z29uIG1heSBhcHBlYXIgdG8gY2hhbmdlIHdoZW4gZHJhZ2dlZCwgYXMgdGhlIGRpbWVuc2lvbnNcbiAgICAgKiBhcmUgbWFpbnRhaW5lZCByZWxhdGl2ZSB0byB0aGUgc3VyZmFjZSBvZiB0aGUgZWFydGguIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgR2VvZGVzaWMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWF4aW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5Z29uIGxhYmxlIGlzIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIExhYmVsTWF4Wm9vbTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIHBvbHlnb24gbGFibGUgaXMgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNaW5ab29tOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBBcmJpdGFyeSBtZXRhZGF0YSB0byBhc3NpZ24gdG8gdGhlIFBvbHlnb24uIFRoaXMgaXMgdXNlZnVsIGZvciBldmVudHNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIE1ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlcmVkIHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIHRoYXQgZGVzaWduYXRlcyBhIGNsb3NlZCBsb29wLlxuICAgICAqIFVubGlrZSBwb2x5bGluZXMsIGEgcG9seWdvbiBtYXkgY29uc2lzdCBvZiBvbmUgb3IgbW9yZSBwYXRocy5cbiAgICAgKiBBcyBhIHJlc3VsdCwgdGhlIHBhdGhzIHByb3BlcnR5IG1heSBzcGVjaWZ5IG9uZSBvciBtb3JlIGFycmF5cyBvZlxuICAgICAqIExhdExuZyBjb29yZGluYXRlcy4gUGF0aHMgYXJlIGNsb3NlZCBhdXRvbWF0aWNhbGx5OyBkbyBub3QgcmVwZWF0IHRoZVxuICAgICAqIGZpcnN0IHZlcnRleCBvZiB0aGUgcGF0aCBhcyB0aGUgbGFzdCB2ZXJ0ZXguIFNpbXBsZSBwb2x5Z29ucyBtYXkgYmVcbiAgICAgKiBkZWZpbmVkIHVzaW5nIGEgc2luZ2xlIGFycmF5IG9mIExhdExuZ3MuIE1vcmUgY29tcGxleCBwb2x5Z29ucyBtYXlcbiAgICAgKiBzcGVjaWZ5IGFuIGFycmF5IG9mIGFycmF5cyAoZm9yIGlubmVyIGxvb3BzICkuIEFueSBzaW1wbGUgYXJyYXlzIGFyZSBjb252ZXJ0ZWQgaW50byBBcnJheXMuXG4gICAgICogSW5zZXJ0aW5nIG9yIHJlbW92aW5nIExhdExuZ3MgZnJvbSB0aGUgQXJyYXkgd2lsbCBhdXRvbWF0aWNhbGx5IHVwZGF0ZVxuICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBQYXRoczogQXJyYXk8SUxhdExvbmc+IHwgQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSB0aXRsZSBhcyB0aGUgbGFiZWwgb24gdGhlIHBvbHlnb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93TGFiZWw6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHRpdGxlIG9mIHRoZSBwb2x5Z29uIGFzIHRoZSB0b29sdGlwIG9uIHRoZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cm9rZSBjb2xvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZUNvbG9yOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3Ryb2tlIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgU3Ryb2tlT3BhY2l0eTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBTdHJva2VXZWlnaHQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgcG9seWdvbiBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHpJbmRleCBjb21wYXJlZCB0byBvdGhlciBwb2x5cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHpJbmRleDogbnVtYmVyO1xuXG4gICAgLy8vXG4gICAgLy8vIERlbGVnYXRlIGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIERibENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlnb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBEcmFnOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBEcmFnRW5kOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgRHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlnb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBNb3VzZURvd246IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIE1vdXNlTW92ZTogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5Z29uIG1vdXNlb3V0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWdvbiBtb3VzZW92ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBNb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvblxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VVcDogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlnb24gaXMgcmlnaHQtY2xpY2tlZCBvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFJpZ2h0Q2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBlZGl0aW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBQYXRoQ2hhbmdlZDogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZS5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgQWRkZWRUb1NlcnZpY2UoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9hZGRlZFRvU2VydmljZTsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZCBvZiB0aGUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBwb2x5Z29uIGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IElkQXNTdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyBpbiBhIGN1c3RvbSBsYXllci4gU2VlIHtAbGluayBNYXBMYXllcn0uXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSW5DdXN0b21MYXllcigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2luQ3VzdG9tTGF5ZXI7IH1cblxuICAgIC8qKlxuICAgICAqIGdldHMgdGhlIGlkIG9mIHRoZSBMYXllciB0aGUgcG9seWdvbiBiZWxvbmdzIHRvLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IExheWVySWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xheWVySWQ7IH1cblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBQb2x5Z29uRGlyZWN0aXZlLlxuICAgICAqIEBwYXJhbSBfcG9seWdvbk1hbmFnZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcG9seWdvblNlcnZpY2U6IFBvbHlnb25TZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy5faWQgPSBwb2x5Z29uSWQrKztcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgY29udGVudCBpbnRpYWxpemF0aW9uIG9mIHRoZSBkaXJlY3RpdmUgaXMgY29tcGxldGUuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWU6IHN0cmluZyA9IHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lO1xuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtbWFwLWxheWVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luQ3VzdG9tTGF5ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVySWQgPSBOdW1iZXIodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LmF0dHJpYnV0ZXNbJ2xheWVySWQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5fcG9seWdvblNlcnZpY2UuQWRkUG9seWdvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZGVkVG9TZXJ2aWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdlcyB0byB0aGUgZGF0YWJvdWQgcHJvcGVydGllcyBvY2N1ci4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIENoYW5nZXMgdGhhdCBoYXZlIG9jY3VyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiBhbnkge1xuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkVG9TZXJ2aWNlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbnN0IG86IElQb2x5Z29uT3B0aW9ucyA9IHRoaXMuR2VuZXJhdGVQb2x5Z29uQ2hhbmdlU2V0KGNoYW5nZXMpO1xuICAgICAgICBpZiAobyAhPSBudWxsKSB7IHRoaXMuX3BvbHlnb25TZXJ2aWNlLlNldE9wdGlvbnModGhpcywgbyk7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1BhdGhzJ10gJiYgIWNoYW5nZXNbJ1BhdGhzJ10uaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5VcGRhdGVQb2x5Z29uKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcG95Z29uIGlzIGJlaW5nIGRlc3Ryb3llZC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuIFJlbGVhc2UgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5EZWxldGVQb2x5Z29uKHRoaXMpO1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgLy8vXG4gICAgICAgIC8vLyByZW1vdmUgZXZlbnQgc3Vic2NyaXB0aW9uc1xuICAgICAgICAvLy9cbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBXaXJlcyB1cCB0aGUgZXZlbnQgcmVjZWl2ZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwcml2YXRlIEFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICBjb25zdCBfZ2V0RXZlbnRBcmc6IChlOiBNb3VzZUV2ZW50KSA9PiBJUG9seWdvbkV2ZW50ID0gZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFBvbHlnb246IHRoaXMsXG4gICAgICAgICAgICAgICAgQ2xpY2s6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKHRoaXMuX3BvbHlnb25TZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xpY2snLCB0aGlzKS5zdWJzY3JpYmUoKGV2OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0OiBNYXBQb2x5Z29uRGlyZWN0aXZlID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmZvQm94ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmZvQm94Lk9wZW4odGhpcy5fcG9seWdvblNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZXYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuQ2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2RibGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRibENsaWNrLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWcnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZy5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdFbmQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZ3N0YXJ0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdTdGFydC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZWRvd24nLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VEb3duLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU1vdmUuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdXQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VPdXQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlT3Zlci5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlVXAuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncmlnaHRjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5SaWdodENsaWNrLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3BhdGhjaGFuZ2VkJywgaGFuZGxlcjogKGV2OiBJUG9seWdvbkV2ZW50KSA9PiB0aGlzLlBhdGhDaGFuZ2VkLmVtaXQoZXYpIH1cbiAgICAgICAgXTtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcyA9IHRoaXMuX3BvbHlnb25TZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgdGhpcykuc3Vic2NyaWJlKG9iai5oYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgSVBvbHlnb24gb3B0aW9uIGNoYW5nZXNldCBmcm9tIGRpcmVjdGl2ZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0ge0BsaW5rIFNpbXBsZUNoYW5nZXN9IGlkZW50aWZ5aW5nIHRoZSBjaGFuZ2VzIHRoYXQgb2NjdXJlZC5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJUG9seWdvbk9wdGlvbnN9IGNvbnRhaW5pbmcgdGhlIHBvbHlnb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHJpdmF0ZSBHZW5lcmF0ZVBvbHlnb25DaGFuZ2VTZXQoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IElQb2x5Z29uT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyA9IHsgaWQ6IHRoaXMuX2lkIH07XG4gICAgICAgIGxldCBoYXNPcHRpb25zOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGFuZ2VzWydDbGlja2FibGUnXSkgeyBvcHRpb25zLmNsaWNrYWJsZSA9IHRoaXMuQ2xpY2thYmxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snRHJhZ2dhYmxlJ10pIHsgb3B0aW9ucy5kcmFnZ2FibGUgPSB0aGlzLkRyYWdnYWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0VkaXRhYmxlJ10pIHsgb3B0aW9ucy5lZGl0YWJsZSA9IHRoaXMuRWRpdGFibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydGaWxsQ29sb3InXSB8fCBjaGFuZ2VzWydGaWxsT3BhY2l0eSddKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZpbGxDb2xvciA9IHRoaXMuRmlsbENvbG9yO1xuICAgICAgICAgICAgb3B0aW9ucy5maWxsT3BhY2l0eSA9IHRoaXMuRmlsbE9wYWNpdHk7XG4gICAgICAgICAgICBoYXNPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snR2VvZGVzaWMnXSkgeyBvcHRpb25zLmdlb2Rlc2ljID0gdGhpcy5HZW9kZXNpYzsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0xhYmVsTWF4Wm9vbSddKSB7IG9wdGlvbnMubGFiZWxNYXhab29tID0gdGhpcy5MYWJlbE1heFpvb207IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydMYWJlbE1pblpvb20nXSkgeyBvcHRpb25zLmxhYmVsTWluWm9vbSA9IHRoaXMuTGFiZWxNaW5ab29tOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXAnXSkgeyBvcHRpb25zLnNob3dUb29sdGlwID0gdGhpcy5TaG93VG9vbHRpcDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Nob3dMYWJlbCddKSB7IG9wdGlvbnMuc2hvd0xhYmVsID0gdGhpcy5TaG93TGFiZWw7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydTdHJva2VDb2xvciddIHx8IGNoYW5nZXNbJ1N0cm9rZU9wYWNpdHknXSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdHJva2VDb2xvciA9IHRoaXMuU3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICBvcHRpb25zLnN0cm9rZU9wYWNpdHkgPSB0aGlzLlN0cm9rZU9wYWNpdHk7XG4gICAgICAgICAgICBoYXNPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlV2VpZ2h0J10pIHsgb3B0aW9ucy5zdHJva2VXZWlnaHQgPSB0aGlzLlN0cm9rZVdlaWdodDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1RpdGxlJ10pIHsgb3B0aW9ucy50aXRsZSA9IHRoaXMuVGl0bGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5WaXNpYmxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snekluZGV4J10pIHsgb3B0aW9ucy56SW5kZXggPSB0aGlzLnpJbmRleDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIGhhc09wdGlvbnMgPyBvcHRpb25zIDogbnVsbDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7XG4gICAgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgVmlld0NvbnRhaW5lclJlZixcbiAgICBFdmVudEVtaXR0ZXIsIENvbnRlbnRDaGlsZCwgQWZ0ZXJDb250ZW50SW5pdCwgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3BvbHlsaW5lLnNlcnZpY2UnO1xuaW1wb3J0IHsgSVBvbHlsaW5lRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1ldmVudCc7XG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi9pbmZvYm94JztcblxubGV0IHBvbHlsaW5lSWQgPSAwO1xuXG4vKipcbiAqXG4gKiBNYXBQb2x5bGluZURpcmVjdGl2ZSByZW5kZXJzIGEgcG9seWxpbmUgaW5zaWRlIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZnJvbSAnLi4uJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcCxcbiAqICBzdHlsZXM6IFtgXG4gKiAgIC5tYXAtY29udGFpbmVyIHsgaGVpZ2h0OiAzMDBweDsgfVxuICogYF0sXG4gKiB0ZW1wbGF0ZTogYFxuICogICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPlxuICogICAgICA8eC1tYXAtcG9seWxpbmUgW1BhdGhzXT1cInBhdGhcIj48L3gtbWFwLXBvbHlsaW5lPlxuICogICA8L3gtbWFwPlxuICogYFxuICogfSlcbiAqIGBgYFxuICpcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAneC1tYXAtcG9seWxpbmUnXG59KVxuZXhwb3J0IGNsYXNzIE1hcFBvbHlsaW5lRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2luQ3VzdG9tTGF5ZXIgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9pZDogbnVtYmVyO1xuICAgIHByaXZhdGUgX2xheWVySWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIF9hZGRlZFRvU2VydmljZSA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2V2ZW50czogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAgIC8vL1xuICAgIC8vLyBBbnkgSW5mb0JveCB0aGF0IGlzIGEgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBwb2x5bGluZVxuICAgIC8vL1xuICAgIEBDb250ZW50Q2hpbGQoSW5mb0JveENvbXBvbmVudCkgcHJvdGVjdGVkIF9pbmZvQm94OiBJbmZvQm94Q29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIFBvbHlsaW5lIGhhbmRsZXMgbW91c2UgZXZlbnRzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIENsaWNrYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBzaGFwZSBvdmVyIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgRHJhZ2dhYmxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBzaGFwZSBieSBkcmFnZ2luZyB0aGUgY29udHJvbFxuICAgICAqIHBvaW50cyBzaG93biBhdCB0aGUgdmVydGljZXMgYW5kIG9uIGVhY2ggc2VnbWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBFZGl0YWJsZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBlZGdlcyBvZiB0aGUgcG9seWxpbmUgYXJlIGludGVycHJldGVkIGFzIGdlb2Rlc2ljIGFuZCB3aWxsXG4gICAgICogZm9sbG93IHRoZSBjdXJ2YXR1cmUgb2YgdGhlIEVhcnRoLiBXaGVuIGZhbHNlLCBlZGdlcyBvZiB0aGUgcG9seWxpbmUgYXJlXG4gICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcbiAgICAgKiBnZW9kZXNpYyBwb2x5bGluZSBtYXkgYXBwZWFyIHRvIGNoYW5nZSB3aGVuIGRyYWdnZWQsIGFzIHRoZSBkaW1lbnNpb25zXG4gICAgICogYXJlIG1haW50YWluZWQgcmVsYXRpdmUgdG8gdGhlIHN1cmZhY2Ugb2YgdGhlIGVhcnRoLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBHZW9kZXNpYyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQXJiaXRhcnkgbWV0YWRhdGEgdG8gYXNzaWduIHRvIHRoZSBQb2x5bGluZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGV2ZW50c1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIE1ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlcmVkIHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIHRoYXQgZGVzaWduYXRlcyBhIHBvbHlsaW5lLlxuICAgICAqIFNpbXBsZSBwb2x5bGluZXMgbWF5IGJlIGRlZmluZWQgdXNpbmcgYSBzaW5nbGUgYXJyYXkgb2YgTGF0TG5ncy4gTW9yZVxuICAgICAqIGNvbXBsZXggcG9seWxpbmVzIG1heSBzcGVjaWZ5IGFuIGFycmF5IG9mIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBQYXRoOiBBcnJheTxJTGF0TG9uZz4gfCBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHRpdGxlIG9mIHRoZSBwb2x5bGluZSBhcyB0aGUgdG9vbHRpcCBvbiB0aGUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93VG9vbHRpcDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3Ryb2tlIGNvbG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZUNvbG9yOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3Ryb2tlIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZU9wYWNpdHk6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJva2Ugd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZVdlaWdodDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgcG9seWxpbmUgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFZpc2libGU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgekluZGV4IGNvbXBhcmVkIHRvIG90aGVyIHBvbHlzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHpJbmRleDogbnVtYmVyO1xuXG4gICAgLy8vXG4gICAgLy8vIERlbGVnYXRlIGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgQ2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIERibENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBmaXJlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgcG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgRHJhZzogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlsaW5lLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIERyYWdFbmQ6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgRHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlZG93biBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VEb3duOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VNb3ZlOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW92ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgTW91c2VPdmVyOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBNb3VzZVVwOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbiBpcyBmaXJlZCB3aGVuIHRoZSBQb2x5bGluZSBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFJpZ2h0Q2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2UuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBBZGRlZFRvU2VydmljZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2FkZGVkVG9TZXJ2aWNlOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSBwb2x5bGluZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpZCBvZiB0aGUgcG9seWxpbmUgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IElkQXNTdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgaW4gYSBjdXN0b20gbGF5ZXIuIFNlZSB7QGxpbmsgTWFwTGF5ZXJ9LlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBJbkN1c3RvbUxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DdXN0b21MYXllcjsgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0cyB0aGUgaWQgb2YgdGhlIExheWVyIHRoZSBwb2x5bGluZSBiZWxvbmdzIHRvLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBMYXllcklkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sYXllcklkOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWFwUG9seWxpbmVEaXJlY3RpdmUuXG4gICAgICogQHBhcmFtIF9wb2x5bGluZU1hbmFnZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlsaW5lU2VydmljZTogUG9seWxpbmVTZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy5faWQgPSBwb2x5bGluZUlkKys7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbnRlbnQgaW50aWFsaXphdGlvbiBvZiB0aGUgZGlyZWN0aXZlIGlzIGNvbXBsZXRlLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZTogc3RyaW5nID0gdGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWU7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1tYXAtbGF5ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5DdXN0b21MYXllciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IE51bWJlcih0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXR0cmlidXRlc1snbGF5ZXJJZCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkVG9TZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2x5bGluZVNlcnZpY2UuQWRkUG9seWxpbmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hZGRlZFRvU2VydmljZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBDaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IGFueSB7XG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb1NlcnZpY2UpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgY29uc3QgbzogSVBvbHlsaW5lT3B0aW9ucyA9IHRoaXMuR2VuZXJhdGVQb2x5bGluZUNoYW5nZVNldChjaGFuZ2VzKTtcbiAgICAgICAgaWYgKG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVTZXJ2aWNlLlNldE9wdGlvbnModGhpcywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1BhdGgnXSAmJiAhY2hhbmdlc1snUGF0aCddLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVTZXJ2aWNlLlVwZGF0ZVBvbHlsaW5lKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHBvbHlsaW5lIGlzIGJlaW5nIGRlc3Ryb3llZC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuIFJlbGVhc2UgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVTZXJ2aWNlLkRlbGV0ZVBvbHlsaW5lKHRoaXMpO1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgICAgIC8vL1xuICAgICAgICAgICAgLy8vIHJlbW92ZSBldmVudCBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAvLy9cbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBXaXJlcyB1cCB0aGUgZXZlbnQgcmVjZWl2ZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHJpdmF0ZSBBZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgY29uc3QgX2dldEV2ZW50QXJnOiAoZTogTW91c2VFdmVudCkgPT4gSVBvbHlsaW5lRXZlbnQgPSBlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgUG9seWxpbmU6IHRoaXMsXG4gICAgICAgICAgICAgICAgQ2xpY2s6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChldjogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZm9Cb3guT3Blbih0aGlzLl9wb2x5bGluZVNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZXYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuQ2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRGJsQ2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5EcmFnLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ0VuZC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ1N0YXJ0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZURvd24uZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlTW92ZS5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU91dC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VPdmVyLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VVcC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlJpZ2h0Q2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9zID0gdGhpcy5fcG9seWxpbmVTZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgdGhpcykuc3Vic2NyaWJlKG9iai5oYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgSVBvbHlsaW5lIG9wdGlvbiBjaGFuZ2VzZXQgZnJvbSBkaXJlY3RpdmUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIHtAbGluayBTaW1wbGVDaGFuZ2VzfSBpZGVudGlmeWluZyB0aGUgY2hhbmdlcyB0aGF0IG9jY3VyZWQuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30gY29udGFpbmluZyB0aGUgcG9seWxpbmUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxuICAgICAqL1xuICAgIHByaXZhdGUgR2VuZXJhdGVQb2x5bGluZUNoYW5nZVNldChjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogSVBvbHlsaW5lT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMgPSB7IGlkOiB0aGlzLl9pZCB9O1xuICAgICAgICBsZXQgaGFzT3B0aW9uczogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbmdlc1snQ2xpY2thYmxlJ10pIHsgb3B0aW9ucy5jbGlja2FibGUgPSB0aGlzLkNsaWNrYWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0RyYWdnYWJsZSddKSB7IG9wdGlvbnMuZHJhZ2dhYmxlID0gdGhpcy5EcmFnZ2FibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydFZGl0YWJsZSddKSB7IG9wdGlvbnMuZWRpdGFibGUgPSB0aGlzLkVkaXRhYmxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snR2VvZGVzaWMnXSkgeyBvcHRpb25zLmdlb2Rlc2ljID0gdGhpcy5HZW9kZXNpYzsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Nob3dUb29sdGlwJ10pIHsgb3B0aW9ucy5zaG93VG9vbHRpcCA9IHRoaXMuU2hvd1Rvb2x0aXA7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydTdHJva2VDb2xvciddKSB7IG9wdGlvbnMuc3Ryb2tlQ29sb3IgPSB0aGlzLlN0cm9rZUNvbG9yOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlT3BhY2l0eSddKSB7IG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuU3Ryb2tlT3BhY2l0eTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1N0cm9rZVdlaWdodCddKSB7IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0ID0gdGhpcy5TdHJva2VXZWlnaHQ7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydUaXRsZSddKSB7IG9wdGlvbnMudGl0bGUgPSB0aGlzLlRpdGxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY2hhbmdlc1snVmlzaWJsZSddKSB7IG9wdGlvbnMudmlzaWJsZSA9IHRoaXMuVmlzaWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3pJbmRleCddKSB7IG9wdGlvbnMuekluZGV4ID0gdGhpcy56SW5kZXg7IGhhc09wdGlvbnMgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBoYXNPcHRpb25zID8gb3B0aW9ucyA6IG51bGw7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcbiAgICBFdmVudEVtaXR0ZXIsIENvbnRlbnRDaGlsZCwgQWZ0ZXJDb250ZW50SW5pdCwgVmlld0NvbnRhaW5lclJlZiwgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElNYXJrZXJFdmVudCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1ldmVudCc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xuaW1wb3J0IHsgSUNsdXN0ZXJJY29uSW5mbyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItaWNvbi1pbmZvJztcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFya2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbGF5ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NsdXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9tb2RlbHMvbGF5ZXInO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1wbGFjZW1lbnQtbW9kZSc7XG5pbXBvcnQgeyBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL2NsdXN0ZXItbGF5ZXInO1xuXG4vKipcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgbWFya2VyLlxuICovXG5sZXQgbGF5ZXJJZCA9IDEwMDAwMDA7XG5cbi8qKlxuICogTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUgcGVyZm9ybWFudGx5IHJlbmRlcnMgYSBsYXJnZSBzZXQgb2YgbWFwIG1hcmtlciBpbnNpZGUgYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxuICogIHN0eWxlczogW2BcbiAqICAgLm1hcC1jb250YWluZXIge1xuICogICAgIGhlaWdodDogMzAwcHg7XG4gKiAgIH1cbiAqIGBdLFxuICogdGVtcGxhdGU6IGBcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cbiAqICAgICAgPHgtbWFwLW1hcmtlci1sYXllciBbTWFya2VyT3B0aW9uc109XCJfbWFya2Vyc1wiPjwveC1tYXAtbWFya2VyLWxheWVyPlxuICogICA8L3gtbWFwPlxuICogYFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleHBvcnRcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd4LW1hcC1tYXJrZXItbGF5ZXInXG59KVxuZXhwb3J0IGNsYXNzIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfbGF5ZXJQcm9taXNlOiBQcm9taXNlPExheWVyPjtcbiAgICBwcml2YXRlIF9zZXJ2aWNlOiBMYXllclNlcnZpY2U7XG4gICAgcHJpdmF0ZSBfc3R5bGVzOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPjtcbiAgICBwcml2YXRlIF91c2VEeW5hbWljU2l6ZU1hcmtlciA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSA9IDE4O1xuICAgIHByaXZhdGUgX2R5bmFtaWNNYXJrZXJSYW5nZXM6IE1hcDxudW1iZXIsIHN0cmluZz4gPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPihbXG4gICAgICAgIFsxMCwgJ3JnYmEoMjAsIDE4MCwgMjAsIDAuNSknXSxcbiAgICAgICAgWzEwMCwgJ3JnYmEoMjU1LCAyMTAsIDQwLCAwLjUpJ10sXG4gICAgICAgIFtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAsICdyZ2JhKDI1NSwgNDAsIDQwLCAwLjUpJ11cbiAgICBdKTtcbiAgICBwcml2YXRlIF9pY29uQ3JlYXRpb25DYWxsYmFjazogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nO1xuICAgIHByaXZhdGUgX3N0cmVhbWluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX21hcmtlcnM6IEFycmF5PElNYXJrZXJPcHRpb25zPiA9IG5ldyBBcnJheTxJTWFya2VyT3B0aW9ucz4oKTtcbiAgICBwcml2YXRlIF9tYXJrZXJzTGFzdDogQXJyYXk8SU1hcmtlck9wdGlvbnM+ID0gbmV3IEFycmF5PElNYXJrZXJPcHRpb25zPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRoZSBDbHVzdGVyIENsaWNrIEFjdGlvbiB7QGxpbmsgQ2x1c3RlckNsaWNrQWN0aW9ufS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBDbHVzdGVyQ2xpY2tBY3Rpb246IENsdXN0ZXJDbGlja0FjdGlvbiA9ICBDbHVzdGVyQ2xpY2tBY3Rpb24uWm9vbUludG9DbHVzdGVyO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBJY29uSW5mbyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBjbHVzdGVyIG1hcmtlci4gU3VwcG9ydHMgZm9udC1iYXNlZCwgU1ZHLCBncmFwaGljcyBhbmQgbW9yZS5cbiAgICAgKiBTZWUge0BsaW5rIElNYXJrZXJJY29uSW5mb30uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgQ2x1c3Rlckljb25JbmZvOiBJTWFya2VySWNvbkluZm87XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNsdXN0ZXIgcGxhY2VtZW50IG1vZGUuIHtAbGluayBDbHVzdGVyUGxhY2VtZW50TW9kZX1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpICBwdWJsaWMgQ2x1c3RlclBsYWNlbWVudE1vZGU6IENsdXN0ZXJQbGFjZW1lbnRNb2RlID0gQ2x1c3RlclBsYWNlbWVudE1vZGUuTWVhblZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjYWxsYmFjayBpbnZva2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBjbHVzdGVyIG1hcmtlci4gTm90ZSB0aGF0IHdoZW4ge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30gaXMgZW5hYmxlZCxcbiAgICAgKiB5b3UgY2Fubm90IHNldCBhIGN1c3RvbSBtYXJrZXIgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IEN1c3RvbU1hcmtlckNhbGxiYWNrKCk6IChtOiBBcnJheTxNYXJrZXI+LCBpOiBJTWFya2VySWNvbkluZm8pID0+IHN0cmluZyAgeyByZXR1cm4gdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2s7IH1cbiAgICAgICAgcHVibGljIHNldCBDdXN0b21NYXJrZXJDYWxsYmFjayh2YWw6IChtOiBBcnJheTxNYXJrZXI+LCBpOiBJTWFya2VySWNvbkluZm8pID0+IHN0cmluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZUR5bmFtaWNTaXplTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3coXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihgWW91IGNhbm5vdCBzZXQgYSBjdXN0b20gbWFya2VyIGNhbGxiYWNrIHdoZW4gVXNlRHluYW1pY1NpemVNYXJrZXJzIGlzIHNldCB0byB0cnVlLlxuICAgICAgICAgICAgICAgICAgICBTZXQgVXNlRHluYW1pY1NpemVNYWtlcnMgdG8gZmFsc2UuYClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSB2YWw7XG4gICAgICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFzZSBzaXplIG9mIGR5bmFtaWMgbWFya2VycyBpbiBwaXhlbHMuIFRoZSBhY3R1YWx5IHNpemUgb2YgdGhlIGR5bmFtaWMgbWFya2VyIGlzIGJhc2VkIG9uIHRoaXMuXG4gICAgICogU2VlIHtAbGluayBVc2VEeW5hbWljU2l6ZU1hcmtlcnN9LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgRHluYW1pY01hcmtlckJhc2VTaXplKCk6IG51bWJlciAgeyByZXR1cm4gdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgRHluYW1pY01hcmtlckJhc2VTaXplKHZhbDogbnVtYmVyKSB7IHRoaXMuX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSByYW5nZXMgdG8gdXNlIHRvIGNhbGN1bGF0ZSBicmVha3BvaW50cyBhbmQgY29sb3JzIGZvciBkeW5hbWljIG1hcmtlcnMuXG4gICAgICogVGhlIG1hcCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMsIHdpdGggdGhlIGtleXMgYmVpbmdcbiAgICAgKiB0aGUgYnJlYWtwb2ludCBzaXplcyBhbmQgdGhlIHZhbHVlcyB0aGUgY29sb3JzIHRvIGJlIHVzZWQgZm9yIHRoZSBkeW5hbWljIG1hcmtlciBpbiB0aGF0IHJhbmdlLiBTZWUge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICAgICAgcHVibGljIGdldCBEeW5hbWljTWFya2VyUmFuZ2VzKCk6IE1hcDxudW1iZXIsIHN0cmluZz4gIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNNYXJrZXJSYW5nZXM7IH1cbiAgICAgICAgcHVibGljIHNldCBEeW5hbWljTWFya2VyUmFuZ2VzKHZhbDogTWFwPG51bWJlciwgc3RyaW5nPikgeyB0aGlzLl9keW5hbWljTWFya2VyUmFuZ2VzID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGxheWVyIGNsdXN0ZXJzLiBUaGlzIHByb3BlcnR5IGNhbiBvbmx5IGJlIHNldCBvbiBjcmVhdGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgRW5hYmxlQ2x1c3RlcmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBncmlkIHNpemUgdG8gYmUgdXNlZCBmb3IgY2x1c3RlcmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBHcmlkU2l6ZTogbnVtYmVyID0gMTUwO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBJY29uSW5mbyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBtYXJrZXIgaW1hZ2VzLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxuICAgICAqIFNlZSB7QGxpbmsgSU1hcmtlckljb25JbmZvfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBJY29uSW5mbzogSU1hcmtlckljb25JbmZvO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIEFuIG9mZnNldCBhcHBsaWVkIHRvIHRoZSBwb3NpdGlvbmluZyBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGF5ZXJPZmZzZXQ6IElQb2ludCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiAgSU1hcmtlck9wdGlvbnMgYXJyYXkgaG9sZGluZyB0aGUgbWFya2VyIGluZm8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IE1hcmtlck9wdGlvbnMoKTogQXJyYXk8SU1hcmtlck9wdGlvbnM+IHsgcmV0dXJuIHRoaXMuX21hcmtlcnM7IH1cbiAgICAgICAgcHVibGljIHNldCBNYXJrZXJPcHRpb25zKHZhbDogQXJyYXk8SU1hcmtlck9wdGlvbnM+KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2Vyc0xhc3QucHVzaCguLi52YWwuc2xpY2UoMCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi52YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VycyA9IHZhbC5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjbHVzdGVyIHN0eWxlc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICAgICAgcHVibGljIGdldCBTdHlsZXMoKTogQXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4geyByZXR1cm4gdGhpcy5fc3R5bGVzOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgU3R5bGVzKHZhbDogQXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4pIHsgdGhpcy5fc3R5bGVzID0gdmFsOyB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gdHJlYXQgY2hhbmdlcyBpbiB0aGUgTWFya2VyT3B0aW9ucyBhcyBzdHJlYW1zIG9mIG5ldyBtYXJrZXJzLiBJbiB0aHNpIG1vZGUsIGNoYW5naW5nIHRoZVxuICAgICAqIEFycmF5IHN1cHBsaWVkIGluIE1hcmtlck9wdGlvbnMgd2lsbCBiZSBpbmNyZW1lbnRhbGx5IGRyYXduIG9uIHRoZSBtYXAgYXMgb3Bwb3NlZCB0byByZXBsYWNlIHRoZSBtYXJrZXJzIG9uIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgICAgICBwdWJsaWMgZ2V0IFRyZWF0TmV3TWFya2VyT3B0aW9uc0FzU3RyZWFtKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc3RyZWFtaW5nOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgVHJlYXROZXdNYXJrZXJPcHRpb25zQXNTdHJlYW0odmFsOiBib29sZWFuKSB7IHRoaXMuX3N0cmVhbWluZyA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gdXNlIGR5bmFtaWMgbWFya2Vycy4gRHluYW1pYyBtYXJrZXJzIGNoYW5nZSBpbiBzaXplIGFuZCBjb2xvciBkZXBlbmRpbmcgb24gdGhlIG51bWJlciBvZlxuICAgICAqIHBpbnMgaW4gdGhlIGNsdXN0ZXIuIElmIHNldCB0byB0cnVlLCB0aGlzIHdpbGwgdGFrZSBwcmVjZW5kZW5jZSBvdmVyIGFueSBjdXN0b20gbWFya2VyIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICAgICAgcHVibGljIGdldCBVc2VEeW5hbWljU2l6ZU1hcmtlcnMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcjsgfVxuICAgICAgICBwdWJsaWMgc2V0IFVzZUR5bmFtaWNTaXplTWFya2Vycyh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZUR5bmFtaWNTaXplTWFya2VyID0gdmFsO1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ljb25DcmVhdGlvbkNhbGxiYWNrID0gKG06IEFycmF5PE1hcmtlcj4sIGluZm86IElNYXJrZXJJY29uSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2x1c3RlckxheWVyRGlyZWN0aXZlLkNyZWF0ZUR5bmFtaWNTaXplTWFya2VyKFxuICAgICAgICAgICAgICAgICAgICAgICAgbS5sZW5ndGgsIGluZm8sIHRoaXMuX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSwgdGhpcy5fZHluYW1pY01hcmtlclJhbmdlcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyIGxheWVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuIElmIG5vdCB1c2VkLCBsYXllcnMgZ2V0IHN0YWNrZWQgaW4gdGhlIG9yZGVyIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgWkluZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhlIGNsdXN0ZXIgc2hvdWxkIHpvb20gaW4gb24gY2xpY2tcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBab29tT25DbGljazogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8vL1xuICAgIC8vLyBEZWxlZ2F0ZXNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgZHluYW1pYyBpY29uIGZvciBhIG1hcmtlciBpcyBiZWluZyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBEeW5hbWljTWFya2VyQ3JlYXRlZDogRXZlbnRFbWl0dGVyPElNYXJrZXJJY29uSW5mbz4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJJY29uSW5mbz4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBtYXJrZXIgaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBNYXJrZXJDbGljazogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyBhIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcblxuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaWQgb2YgdGhlIG1hcmtlciBsYXllci5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUuXG4gICAgICogQHBhcmFtIF9tYXJrZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcmtlclNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIExheWVyU2VydmljZX0uXG4gICAgICogQHBhcmFtIF9jbHVzdGVyU2VydmljZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBDbHVzdGVyU2VydmljZX0uXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBfem9uZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBOZ1pvbmV9IHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfbWFya2VyU2VydmljZTogTWFya2VyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2NsdXN0ZXJTZXJ2aWNlOiBDbHVzdGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX2lkID0gbGF5ZXJJZCsrO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBhIGdlbyBsb2NhdGlvbiB0byBhIHBpeGVsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBtYXAgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2xvY10gLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcy5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhbiB7QGxpbmsgSVBvaW50fSByZXByZXNlbnRpbmcgdGhlIHBpeGVsIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIExvY2F0aW9uVG9QaXhlbChsb2M6IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGxvYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmFrZUxheWVyRGlyZWN0aXZlOiBhbnkgPSB7XG4gICAgICAgICAgICAgICAgSWQgOiB0aGlzLl9pZCxcbiAgICAgICAgICAgICAgICBWaXNpYmxlOiB0aGlzLlZpc2libGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuRW5hYmxlQ2x1c3RlcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5BZGRMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UgPSB0aGlzLl9sYXllclNlcnZpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuTGF5ZXJPZmZzZXQgPSB0aGlzLkxheWVyT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5aSW5kZXggPSB0aGlzLlpJbmRleDtcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuQ2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLkVuYWJsZUNsdXN0ZXJpbmc7XG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkNsdXN0ZXJQbGFjZW1lbnRNb2RlID0gdGhpcy5DbHVzdGVyUGxhY2VtZW50TW9kZTtcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuR3JpZFNpemUgPSB0aGlzLkdyaWRTaXplO1xuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5DbHVzdGVyQ2xpY2tBY3Rpb24gPSB0aGlzLkNsdXN0ZXJDbGlja0FjdGlvbjtcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuSWNvbkluZm8gPSB0aGlzLkNsdXN0ZXJJY29uSW5mbztcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuQ3VzdG9tTWFya2VyQ2FsbGJhY2sgPSB0aGlzLkN1c3RvbU1hcmtlckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5Vc2VEeW5hbWljU2l6ZU1hcmtlcnMgPSB0aGlzLlVzZUR5bmFtaWNTaXplTWFya2VycztcbiAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyU2VydmljZS5BZGRMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VydmljZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XG4gICAgICAgICAgICAgICAgbC5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuTWFya2VyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuVXBkYXRlTWFya2VycygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xuICAgICAgICAgICAgbC5EZWxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhY3RzIHRvIGNoYW5nZXMgaW4gZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIG9mIHRoZSBjb21wb25lbnQgYW5kIGFjdHVhdGVzIHByb3BlcnR5IGNoYW5nZXMgaW4gdGhlIHVuZGVybGluZyBsYXllciBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gY29sbGVjdGlvbiBvZiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW2tleTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0pIHtcbiAgICAgICAgbGV0IHNob3VsZFNldE9wdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbzogSUNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGFuZ2VzWydNYXJrZXJPcHRpb25zJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlTWFya2VycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSAmJiAhY2hhbmdlc1snVmlzaWJsZSddLmZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IGwuU2V0VmlzaWJsZSh0aGlzLlZpc2libGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydFbmFibGVDbHVzdGVyaW5nJ10gJiYgIWNoYW5nZXNbJ0VuYWJsZUNsdXN0ZXJpbmcnXS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgaWYgKCdTdG9wQ2x1c3RlcmluZycgaW4gdGhpcy5fc2VydmljZSkge1xuICAgICAgICAgICAgICAgIG8uY2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLkVuYWJsZUNsdXN0ZXJpbmc7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0T3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSBFbmFibGVDbHVzdGVyaW5nIGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snQ2x1c3RlclBsYWNlbWVudE1vZGUnXSAmJiAhY2hhbmdlc1snQ2x1c3RlclBsYWNlbWVudE1vZGUnXS5maXJzdENoYW5nZSAmJiAnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcbiAgICAgICAgICAgIG8ucGxhY2VtZW50TW9kZSA9IHRoaXMuQ2x1c3RlclBsYWNlbWVudE1vZGU7XG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snR3JpZFNpemUnXSAmJiAhY2hhbmdlc1snR3JpZFNpemUnXS5maXJzdENoYW5nZSAmJiAnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcbiAgICAgICAgICAgIG8uZ3JpZFNpemUgPSB0aGlzLkdyaWRTaXplO1xuICAgICAgICAgICAgc2hvdWxkU2V0T3B0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ0NsdXN0ZXJDbGlja0FjdGlvbiddICYmICFjaGFuZ2VzWydDbHVzdGVyQ2xpY2tBY3Rpb24nXS5maXJzdENoYW5nZSAmJiAnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcbiAgICAgICAgICAgIG8uem9vbU9uQ2xpY2sgPSB0aGlzLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3RlcjtcbiAgICAgICAgICAgIHNob3VsZFNldE9wdGlvbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY2hhbmdlc1snWkluZGV4J10gJiYgIWNoYW5nZXNbJ1pJbmRleCddLmZpcnN0Q2hhbmdlKSB8fFxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xheWVyT2Zmc2V0J10gJiYgIWNoYW5nZXNbJ0xheWVyT2Zmc2V0J10uZmlyc3RDaGFuZ2UpIHx8XG4gICAgICAgICAgICAoY2hhbmdlc1snSWNvbkluZm8nXSAmJiAhY2hhbmdlc1snSWNvbkluZm8nXS5maXJzdENoYW5nZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSBaSW5kZXggb3IgTGF5ZXJPZmZzZXQgYWZ0ZXIgdGhlIGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZFNldE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZha2VMYXllckRpcmVjdGl2ZTogYW55ID0ge0lkIDogdGhpcy5faWR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4gbC5TZXRPcHRpb25zKG8pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTWFya2VyIElkLlxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgaWQuXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwTWFya2VyTGF5ZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cblxuICAgIC8vL1xuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFyaW91cyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbSAtIHRoZSBtYXJrZXIgZm9yIHdoaWNoIHRvIGFkZCB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwcml2YXRlIEFkZEV2ZW50TGlzdGVuZXJzKG06IE1hcmtlcik6IHZvaWQge1xuICAgICAgICBtLkFkZExpc3RlbmVyKCdjbGljaycsIChlOiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1hcmtlckNsaWNrLmVtaXQoe1xuICAgICAgICAgICAgICAgIE1hcmtlcjogbSxcbiAgICAgICAgICAgICAgICBDbGljazogZSxcbiAgICAgICAgICAgICAgICBMb2NhdGlvbjogdGhpcy5fbWFya2VyU2VydmljZS5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlKSxcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG0uQWRkTGlzdGVuZXIoJ2RyYWdlbmQnLCAoZTogTW91c2VFdmVudCkgPT4gdGhpcy5EcmFnRW5kLmVtaXQoe1xuICAgICAgICAgICAgICAgIE1hcmtlcjogbSxcbiAgICAgICAgICAgICAgICBDbGljazogZSxcbiAgICAgICAgICAgICAgICBMb2NhdGlvbjogdGhpcy5fbWFya2VyU2VydmljZS5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlKSxcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBtYXJrZXJzIGJhc2VkIG9uIHRoZSBtYXJrZXIgb3B0aW9ucy4gVGhpcyB3aWxsIHBsYWNlIHRoZSBtYXJrZXJzIG9uIHRoZSBtYXBcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHByaXZhdGUgVXBkYXRlTWFya2VycygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyUHJvbWlzZSA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcnM6IEFycmF5PElNYXJrZXJPcHRpb25zPiA9IHRoaXMuX3N0cmVhbWluZyA/IHRoaXMuX21hcmtlcnNMYXN0LnNwbGljZSgwKSA6IHRoaXMuX21hcmtlcnM7XG5cbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBwcm9taXNlIGZvciB0aGUgbWFya2Vyc1xuICAgICAgICAgICAgY29uc3QgbXA6IFByb21pc2U8QXJyYXk8TWFya2VyPj4gPSB0aGlzLl9zZXJ2aWNlLkNyZWF0ZU1hcmtlcnMobWFya2VycywgdGhpcy5JY29uSW5mbyk7XG5cbiAgICAgICAgICAgIC8vIHNldCBtYXJrZXJzIG9uY2UgcHJvbWlzZXMgYXJlIGZ1bGxmaWxsZWQuXG4gICAgICAgICAgICBtcC50aGVuKG0gPT4ge1xuICAgICAgICAgICAgICAgIG0uZm9yRWFjaChtYXJrZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFdmVudExpc3RlbmVycyhtYXJrZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbWluZyA/IGwuQWRkRW50aXRpZXMobSkgOiBsLlNldEVudGl0aWVzKG0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsIFNpbXBsZUNoYW5nZSwgSW5wdXQsIE91dHB1dCwgT25EZXN0cm95LCBPbkNoYW5nZXMsXG4gICAgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIEFmdGVyQ29udGVudEluaXQsIFZpZXdDb250YWluZXJSZWYsIE5nWm9uZSxcbiAgICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XG5pbXBvcnQgeyBJU2l6ZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXNpemUnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlnb24nO1xuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tb2RlbHMvbWFwLWxhYmVsJztcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xuXG4vKipcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgcG9seWdvbnMuXG4gKi9cbmxldCBsYXllcklkID0gMTAwMDAwMDtcblxuLyoqXG4gKiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUgcGVyZm9ybWFudGx5IHJlbmRlcnMgYSBsYXJnZSBzZXQgb2YgcG9seWdvbnMgb24gYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtNYXBDb21wb25lbnR9IGZyb20gJy4uLic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcbiAqICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICB9XG4gKiBgXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDx4LW1hcC1wb2x5Z29uLWxheWVyIFtQb2x5Z29uT3B0aW9uc109XCJfcG9seWdvbnNcIj48L3gtbWFwLXBvbHlnb24tbGF5ZXI+XG4gKiAgIDwveC1tYXA+XG4gKiBgXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4cG9ydFxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3gtbWFwLXBvbHlnb24tbGF5ZXInXG59KVxuZXhwb3J0IGNsYXNzIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcml2YXRlIF9pZDogbnVtYmVyO1xuICAgIHByaXZhdGUgX2xheWVyUHJvbWlzZTogUHJvbWlzZTxMYXllcj47XG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgX2NhbnZhczogQ2FudmFzT3ZlcmxheTtcbiAgICBwcml2YXRlIF9sYWJlbHM6IEFycmF5PHtsb2M6IElMYXRMb25nLCB0aXRsZTogc3RyaW5nfT4gPSBuZXcgQXJyYXk8e2xvYzogSUxhdExvbmcsIHRpdGxlOiBzdHJpbmd9PigpO1xuICAgIHByaXZhdGUgX3Rvb2x0aXA6IE1hcExhYmVsO1xuICAgIHByaXZhdGUgX3Rvb2x0aXBTdWJzY3JpcHRpb25zOiBBcnJheTxTdWJzY3JpcHRpb24+ID0gbmV3IEFycmF5PFN1YnNjcmlwdGlvbj4oKTtcbiAgICBwcml2YXRlIF90b29sdGlwVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBJTGFiZWxPcHRpb25zID0ge1xuICAgICAgICBmb250U2l6ZTogMTEsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxuICAgICAgICBzdHJva2VDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICBmb250Q29sb3I6ICcjZmZmZmZmJ1xuICAgIH07XG4gICAgcHJpdmF0ZSBfc3RyZWFtaW5nOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfcG9seWdvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4gPSBuZXcgQXJyYXk8SVBvbHlnb25PcHRpb25zPigpO1xuICAgIHByaXZhdGUgX3BvbHlnb25zTGFzdDogQXJyYXk8SVBvbHlnb25PcHRpb25zPiA9IG5ldyBBcnJheTxJUG9seWdvbk9wdGlvbnM+KCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgcG9seWdvbiBsYWJlbHMgYXJlIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNYXhab29tOiBudW1iZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5Z29uIGxhYmVscyBhcmUgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE1pblpvb206IG51bWJlciA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogU2VwY2lmaWVzIHN0eWxlaW5nIG9wdGlvbnMgZm9yIG9uLW1hcCBwb2x5Z29uIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxPcHRpb25zOiBJTGFiZWxPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIEFuIG9mZnNldCBhcHBsaWVkIHRvIHRoZSBwb3NpdGlvbmluZyBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIExheWVyT2Zmc2V0OiBJUG9pbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgcG9seWdvbiBvcHRpb25zIHJlcHJlc2VudGluZyB0aGUgcG9seWdvbnMgaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgUG9seWdvbk9wdGlvbnMoKTogQXJyYXk8SVBvbHlnb25PcHRpb25zPiB7IHJldHVybiB0aGlzLl9wb2x5Z29uczsgfVxuICAgICAgICBwdWJsaWMgc2V0IFBvbHlnb25PcHRpb25zKHZhbDogQXJyYXk8SVBvbHlnb25PcHRpb25zPikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zTGFzdC5wdXNoKC4uLnZhbC5zbGljZSgwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMucHVzaCguLi52YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMgPSB2YWwuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgcG9seWdvbiB0aXRsZXMgYXMgdGhlIGxhYmVscyBvbiB0aGUgcG9seWdvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFNob3dMYWJlbHM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgdGl0bGVzIG9mIHRoZSBwb2x5Z29zbiBhcyB0aGUgdG9vbHRpcHMgb24gdGhlIHBvbHlnb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93VG9vbHRpcHM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIHRyZWF0IGNoYW5nZXMgaW4gdGhlIFBvbHlnb25PcHRpb25zIGFzIHN0cmVhbXMgb2YgbmV3IG1hcmtlcnMuIEluIHRoaXMgbW9kZSwgY2hhbmdpbmcgdGhlXG4gICAgICogQXJyYXkgc3VwcGxpZWQgaW4gUG9seWdvbk9wdGlvbnMgd2lsbCBiZSBpbmNyZW1lbnRhbGx5IGRyYXduIG9uIHRoZSBtYXAgYXMgb3Bwb3NlZCB0byByZXBsYWNlIHRoZSBwb2x5Z29ucyBvbiB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgVHJlYXROZXdQb2x5Z29uT3B0aW9uc0FzU3RyZWFtKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc3RyZWFtaW5nOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgVHJlYXROZXdQb2x5Z29uT3B0aW9uc0FzU3RyZWFtKHZhbDogYm9vbGVhbikgeyB0aGlzLl9zdHJlYW1pbmcgPSB2YWw7IH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIG1hcmtlciBsYXllclxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgWkluZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgLy8vXG4gICAgLy8vIERlbGVnYXRlc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIHBvbHlnb24gaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgUG9seWdvbkNsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlnb24gaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBQb2x5Z29uRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlnb24gaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBQb2x5Z29uTW91c2VNb3ZlOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIG1vdXNlb3V0IG9uIGEgcG9seWdvbiBpbiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFBvbHlnb25Nb3VzZU91dDogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBtb3VzZW92ZXIgb24gYSBwb2x5Z29uIGluIGEgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFBvbHlnb25Nb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcblxuXG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpZCBvZiB0aGUgbWFya2VyIGxheWVyLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlLlxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIExheWVyU2VydmljZX0uXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBfem9uZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBOZ1pvbmV9IHNlcnZpY2UuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX2lkID0gbGF5ZXJJZCsrO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIGNvbnN0IGxheWVyT3B0aW9uczogSUxheWVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZha2VMYXllckRpcmVjdGl2ZTogYW55ID0ge1xuICAgICAgICAgICAgICAgIElkIDogdGhpcy5faWQsXG4gICAgICAgICAgICAgICAgVmlzaWJsZTogdGhpcy5WaXNpYmxlLFxuICAgICAgICAgICAgICAgIExheWVyT2Zmc2V0OiB0aGlzLkxheWVyT2Zmc2V0LFxuICAgICAgICAgICAgICAgIFpJbmRleDogdGhpcy5aSW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuQWRkTGF5ZXIoZmFrZUxheWVyRGlyZWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xuXG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlQ2FudmFzT3ZlcmxheShlbCA9PiB0aGlzLkRyYXdMYWJlbHMoZWwpKVxuICAgICAgICAgICAgXSkudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlc1swXS5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gdmFsdWVzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5fY2FudmFzUmVhZHkudGhlbihiID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IHRoaXMuX2NhbnZhcy5HZXRUb29sVGlwT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAodGhpcy5TaG93VG9vbHRpcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLlBvbHlnb25PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5VcGRhdGVQb2x5Z29ucygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UgPSB0aGlzLl9sYXllclNlcnZpY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uIEZyZWVzIHRoZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IHtcbiAgICAgICAgICAgIGwuRGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7IHRoaXMuX2NhbnZhcy5EZWxldGUoKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIGNvbGxlY3Rpb24gb2YgY2hhbmdlcy5cbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW2tleTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0pIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1BvbHlnb25PcHRpb25zJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9seWdvbnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10gJiYgIWNoYW5nZXNbJ1Zpc2libGUnXS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiBsLlNldFZpc2libGUodGhpcy5WaXNpYmxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFuZ2VzWydaSW5kZXgnXSAmJiAhY2hhbmdlc1snWkluZGV4J10uZmlyc3RDaGFuZ2UpIHx8XG4gICAgICAgICAgICAoY2hhbmdlc1snTGF5ZXJPZmZzZXQnXSAmJiAhY2hhbmdlc1snTGF5ZXJPZmZzZXQnXS5maXJzdENoYW5nZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSBaSW5kZXggb3IgTGF5ZXJPZmZzZXQgYWZ0ZXIgdGhlIGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY2hhbmdlc1snU2hvd0xhYmVscyddICYmICFjaGFuZ2VzWydTaG93TGFiZWxzJ10uZmlyc3RDaGFuZ2UpIHx8XG4gICAgICAgICAgICAoY2hhbmdlc1snTGFiZWxNaW5ab29tJ10gJiYgIWNoYW5nZXNbJ0xhYmVsTWluWm9vbSddLmZpcnN0Q2hhbmdlKSB8fFxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xhYmVsTWF4Wm9vbSddICYmICFjaGFuZ2VzWydMYWJlbE1heFpvb20nXS5maXJzdENoYW5nZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLlJlZHJhdyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXBzJ10gJiYgdGhpcy5fdG9vbHRpcCkge1xuICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKGNoYW5nZXNbJ1Nob3dUb29sdGlwcyddLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBNYXJrZXIgSWQuXG4gICAgICogQHJldHVybnMgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciBpZC5cbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwUG9seWdvbkxheWVyLScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhcmlvdXMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHAgLSB0aGUgcG9seWdvbiBmb3Igd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwcml2YXRlIEFkZEV2ZW50TGlzdGVuZXJzKHA6IFBvbHlnb24pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5Z29uQ2xpY2suZW1pdCh7UG9seWdvbjogcCwgQ2xpY2s6IGV2fSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RibGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlnb25EYmxDbGljay5lbWl0KHtQb2x5Z29uOiBwLCBDbGljazogZXZ9KSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlnb25Nb3VzZU1vdmUuZW1pdCh7UG9seWdvbjogcCwgQ2xpY2s6IGV2fSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3V0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlnb25Nb3VzZU91dC5lbWl0KHtQb2x5Z29uOiBwLCBDbGljazogZXZ9KSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlnb25Nb3VzZU92ZXIuZW1pdCh7UG9seWdvbjogcCwgQ2xpY2s6IGV2fSkgfVxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHAuQWRkTGlzdGVuZXIob2JqLm5hbWUsIG9iai5oYW5kbGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHBvbHlnb24gbGFiZWxzLiBDYWxsZWQgYnkgdGhlIENhbnZhcyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsIC0gVGhlIGNhbnZhcyBvbiB3aGljaCB0byBkcmF3IHRoZSBsYWJlbHMuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHByaXZhdGUgRHJhd0xhYmVscyhlbDogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuU2hvd0xhYmVscykge1xuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRab29tKCkudGhlbih6ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5MYWJlbE1pblpvb20gPD0geiAmJiB0aGlzLkxhYmVsTWF4Wm9vbSA+PSB6KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5fbGFiZWxzLm1hcCh4ID0+IHgudGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uc1RvUG9pbnRzKHRoaXMuX2xhYmVscy5tYXAoeCA9PiB4LmxvYykpLnRoZW4obG9jcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplOiBJU2l6ZSA9IHRoaXMuX21hcFNlcnZpY2UuTWFwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZHJhdyB0aGUgcG9pbnQgaWYgaXQgaXMgbm90IGluIHZpZXcuIFRoaXMgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZSB3aGVuIHpvb21lZCBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jc1tpXS54ID49IDAgJiYgbG9jc1tpXS55ID49IDAgJiYgbG9jc1tpXS54IDw9IHNpemUud2lkdGggJiYgbG9jc1tpXS55IDw9IHNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1RleHQoY3R4LCBsb2NzW2ldLCBsYWJlbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgdGV4dCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2Ugb24gdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gY3R4IC0gQ2FudmFzIGRyYXdpbmcgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gbG9jIC0gUGl4ZWwgbG9jYXRpb24gb24gdGhlIGNhbnZhcyB3aGVyZSB0byBjZW50ZXIgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHRleHQgLSBUZXh0IHRvIGRyYXcuXG4gICAgICovXG4gICAgcHJpdmF0ZSBEcmF3VGV4dChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbG9jOiBJUG9pbnQsIHRleHQ6IHN0cmluZykge1xuICAgICAgICBsZXQgbG86IElMYWJlbE9wdGlvbnMgPSB0aGlzLkxhYmVsT3B0aW9ucztcbiAgICAgICAgaWYgKGxvID09IG51bGwgJiYgdGhpcy5fdG9vbHRpcCkgeyBsbyA9IHRoaXMuX3Rvb2x0aXAuRGVmYXVsdExhYmVsU3R5bGU7IH1cbiAgICAgICAgaWYgKGxvID09IG51bGwpIHsgbG8gPSB0aGlzLl9kZWZhdWx0T3B0aW9uczsgfVxuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxvLnN0cm9rZUNvbG9yO1xuICAgICAgICBjdHguZm9udCA9IGAke2xvLmZvbnRTaXplfXB4ICR7bG8uZm9udEZhbWlseX1gO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGNvbnN0IHN0cm9rZVdlaWdodDogbnVtYmVyID0gbG8uc3Ryb2tlV2VpZ2h0O1xuICAgICAgICBpZiAodGV4dCAmJiBzdHJva2VXZWlnaHQgJiYgc3Ryb2tlV2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXZWlnaHQ7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQodGV4dCwgbG9jLngsIGxvYy55KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbG8uZm9udENvbG9yO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgbG9jLngsIGxvYy55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSB0b29sdGlwIGFuZCB0aGUgYXR0YWNobWVudCBvZiB0aGUgYXNzb2NpYXRlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyAtIFRydWUgdG8gZW5hYmxlIHRoZSB0b29sdGlwLCBmYWxzZSB0byBkaXNhYmxlLlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwcml2YXRlIE1hbmFnZVRvb2x0aXAoc2hvdzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGFkZCB0b29sdGlwIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWdvbk1vdXNlTW92ZS5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogSUxhdExvbmcgPSB0aGlzLl9jYW52YXMuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZS5DbGljayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLlBvbHlnb25Nb3VzZU92ZXIuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLlBvbHlnb24uVGl0bGUgJiYgZS5Qb2x5Z29uLlRpdGxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jOiBJTGF0TG9uZyA9IHRoaXMuX2NhbnZhcy5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlLkNsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3RleHQnLCBlLlBvbHlnb24uVGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLlBvbHlnb25Nb3VzZU91dC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdG9vbHRpcCBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnNwbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIHVwZGF0ZXMgdGhlIHBvbHlnb25zIGJhc2VkIG9uIHRoZSBwb2x5Z29uIG9wdGlvbnMuIFRoaXMgd2lsbCBwbGFjZSB0aGUgcG9seWdvbnMgb24gdGhlIG1hcFxuICAgICAqIGFuZCByZWdpc3RlciB0aGUgYXNzb2NpYXRlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIHByaXZhdGUgVXBkYXRlUG9seWdvbnMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllclByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9seWdvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4gPSB0aGlzLl9zdHJlYW1pbmcgPyB0aGlzLl9wb2x5Z29uc0xhc3Quc3BsaWNlKDApIDogdGhpcy5fcG9seWdvbnM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0cmVhbWluZykgeyB0aGlzLl9sYWJlbHMuc3BsaWNlKDApOyB9XG5cbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBwcm9taXNlIGZvciB0aGUgbWFya2Vyc1xuICAgICAgICAgICAgY29uc3QgbHA6IFByb21pc2U8QXJyYXk8UG9seWdvbj4+ID0gdGhpcy5fc2VydmljZS5DcmVhdGVQb2x5Z29ucyhsLkdldE9wdGlvbnMoKS5pZCwgcG9seWdvbnMpO1xuXG4gICAgICAgICAgICAvLyBzZXQgbWFya2VycyBvbmNlIHByb21pc2VzIGFyZSBmdWxsZmlsbGVkLlxuICAgICAgICAgICAgbHAudGhlbihwID0+IHtcbiAgICAgICAgICAgICAgICBwLmZvckVhY2gocG9seSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LlRpdGxlICE9IG51bGwgJiYgcG9seS5UaXRsZS5sZW5ndGggPiAwKSB7IHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IHBvbHkuQ2VudHJvaWQsIHRpdGxlOiBwb2x5LlRpdGxlfSk7IH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFdmVudExpc3RlbmVycyhwb2x5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW1pbmcgPyBsLkFkZEVudGl0aWVzKHApIDogbC5TZXRFbnRpdGllcyhwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7IHRoaXMuX2NhbnZhcy5SZWRyYXcoIXRoaXMuX3N0cmVhbWluZyk7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7XG4gICAgRGlyZWN0aXZlLCBTaW1wbGVDaGFuZ2UsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLFxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsXG4gICAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSVNpemUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lzaXplJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJUG9seWxpbmVFdmVudCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLWV2ZW50JztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcbmltcG9ydCB7IElMYWJlbE9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYWJlbC1vcHRpb25zJztcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlsaW5lJztcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbW9kZWxzL21hcC1sYWJlbCc7XG5pbXBvcnQgeyBDYW52YXNPdmVybGF5IH0gZnJvbSAnLi4vbW9kZWxzL2NhbnZhcy1vdmVybGF5JztcblxuLyoqXG4gKiBpbnRlcm5hbCBjb3VudGVyIHRvIHVzZSBhcyBpZHMgZm9yIHBvbHlsaW5lcy5cbiAqL1xubGV0IGxheWVySWQgPSAxMDAwMDAwO1xuXG4vKipcbiAqIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgcGVyZm9ybWFudGx5IHJlbmRlcnMgYSBsYXJnZSBzZXQgb2YgcG9seWxpbmUgb24gYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtNYXBDb21wb25lbnR9IGZyb20gJy4uLic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBzdHlsZXM6IFtgXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcbiAqICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICB9XG4gKiBgXSxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDx4LW1hcC1wb2x5bGluZS1sYXllciBbUG9seWdvbk9wdGlvbnNdPVwiX3BvbHlsaW5lXCI+PC94LW1hcC1wb2x5bGluZS1sYXllcj5cbiAqICAgPC94LW1hcD5cbiAqIGBcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAneC1tYXAtcG9seWxpbmUtbGF5ZXInXG59KVxuZXhwb3J0IGNsYXNzIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfaWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xuICAgIHByaXZhdGUgX3NlcnZpY2U6IExheWVyU2VydmljZTtcbiAgICBwcml2YXRlIF9jYW52YXM6IENhbnZhc092ZXJsYXk7XG4gICAgcHJpdmF0ZSBfbGFiZWxzOiBBcnJheTx7bG9jOiBJTGF0TG9uZywgdGl0bGU6IHN0cmluZ30+ID0gbmV3IEFycmF5PHtsb2M6IElMYXRMb25nLCB0aXRsZTogc3RyaW5nfT4oKTtcbiAgICBwcml2YXRlIF90b29sdGlwOiBNYXBMYWJlbDtcbiAgICBwcml2YXRlIF90b29sdGlwU3Vic2NyaXB0aW9uczogQXJyYXk8U3Vic2NyaXB0aW9uPiA9IG5ldyBBcnJheTxTdWJzY3JpcHRpb24+KCk7XG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kZWZhdWx0T3B0aW9uczogSUxhYmVsT3B0aW9ucyA9IHtcbiAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICAgIHN0cm9rZVdlaWdodDogMixcbiAgICAgICAgc3Ryb2tlQ29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZidcbiAgICB9O1xuICAgIHByaXZhdGUgX3N0cmVhbWluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3BvbHlsaW5lczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4gPSBuZXcgQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4oKTtcbiAgICBwcml2YXRlIF9wb2x5bGluZXNMYXN0OiBBcnJheTxJUG9seWxpbmVPcHRpb25zPiA9IG5ldyBBcnJheTxJUG9seWxpbmVPcHRpb25zPigpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtYXhpbXVtIHpvb20gYXQgd2hpY2ggdGhlIHBvbHlsaW5lIGxhYmVscyBhcmUgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNYXhab29tOiBudW1iZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5bGluZSBsYWJlbHMgYXJlIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIExhYmVsTWluWm9vbTogbnVtYmVyID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBTZXBjaWZpZXMgc3R5bGVpbmcgb3B0aW9ucyBmb3Igb24tbWFwIHBvbHlsaW5lIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIExhYmVsT3B0aW9uczogSUxhYmVsT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyBBbiBvZmZzZXQgYXBwbGllZCB0byB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgTGF5ZXJPZmZzZXQ6IElQb2ludCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBwb2x5bGluZSBvcHRpb25zIHJlcHJlc2VudGluZyB0aGUgcG9seWxpbmVzIGluIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICAgICAgcHVibGljIGdldCBQb2x5bGluZU9wdGlvbnMoKTogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4geyByZXR1cm4gdGhpcy5fcG9seWxpbmVzOyB9XG4gICAgICAgIHB1YmxpYyBzZXQgUG9seWxpbmVPcHRpb25zKHZhbDogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJlYW1pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXNMYXN0LnB1c2goLi4udmFsLnNsaWNlKDApKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMucHVzaCguLi52YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzID0gdmFsLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHBvbHlsaW5lcyB0aXRsZXMgYXMgdGhlIGxhYmVscyBvbiB0aGUgcG9seWxpbmVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd0xhYmVsczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSB0aXRsZXMgb2YgdGhlIHBvbHlsaW5lcyBhcyB0aGUgdG9vbHRpcHMgb24gdGhlIHBvbHlsaW5lcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFNob3dUb29sdGlwczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gdHJlYXQgY2hhbmdlcyBpbiB0aGUgUG9seWxpbmVPcHRpb25zIGFzIHN0cmVhbXMgb2YgbmV3IG1hcmtlcnMuIEluIHRoaXMgbW9kZSwgY2hhbmdpbmcgdGhlXG4gICAgICogQXJyYXkgc3VwcGxpZWQgaW4gUG9seWxpbmVPcHRpb25zIHdpbGwgYmUgaW5jcmVtZW50YWxseSBkcmF3biBvbiB0aGUgbWFwIGFzIG9wcG9zZWQgdG8gcmVwbGFjZSB0aGUgcG9seWxpbmVzIG9uIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgICAgIHB1YmxpYyBnZXQgVHJlYXROZXdQb2x5bGluZU9wdGlvbnNBc1N0cmVhbSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3N0cmVhbWluZzsgfVxuICAgICAgICBwdWJsaWMgc2V0IFRyZWF0TmV3UG9seWxpbmVPcHRpb25zQXNTdHJlYW0odmFsOiBib29sZWFuKSB7IHRoaXMuX3N0cmVhbWluZyA9IHZhbDsgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyIGxheWVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIFpJbmRleDogbnVtYmVyID0gMDtcblxuICAgIC8vL1xuICAgIC8vLyBEZWxlZ2F0ZXNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBwb2x5bGluZSBpbiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgUG9seWxpbmVDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlsaW5lIGluIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFBvbHlsaW5lRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIGEgcG9seWxpbmUgaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgUG9seWxpbmVNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBtb3VzZW91dCBvbiBhIHBvbHlsaW5lIGluIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpIFBvbHlsaW5lTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBtb3VzZW92ZXIgb24gYSBwb2x5bGluZSBpbiBhIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgUG9seWxpbmVNb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xuXG5cblxuICAgIC8vL1xuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBwb2x5bGluZSBsYXllci5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlLlxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIExheWVyU2VydmljZX0uXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBfem9uZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBOZ1pvbmV9IHNlcnZpY2UuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xuICAgICAgICB0aGlzLl9pZCA9IGxheWVySWQrKztcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciBDb21wb25lbnQgY29udGVudCBpbml0aWFsaXphdGlvbi4gUGFydCBvZiBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmFrZUxheWVyRGlyZWN0aXZlOiBhbnkgPSB7XG4gICAgICAgICAgICAgICAgSWQgOiB0aGlzLl9pZCxcbiAgICAgICAgICAgICAgICBWaXNpYmxlOiB0aGlzLlZpc2libGUsXG4gICAgICAgICAgICAgICAgTGF5ZXJPZmZzZXQ6IHRoaXMuTGF5ZXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgWkluZGV4OiB0aGlzLlpJbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5BZGRMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XG5cbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNhbnZhc092ZXJsYXkoZWwgPT4gdGhpcy5EcmF3TGFiZWxzKGVsKSlcbiAgICAgICAgICAgICAgICBdKS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1swXS5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLl9jYW52YXNSZWFkeS50aGVuKGIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IHRoaXMuX2NhbnZhcy5HZXRUb29sVGlwT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKHRoaXMuU2hvd1Rvb2x0aXBzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLlBvbHlsaW5lT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLlVwZGF0ZVBvbHlsaW5lcygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZSA9IHRoaXMuX2xheWVyU2VydmljZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IHtcbiAgICAgICAgICAgIGwuRGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7IHRoaXMuX2NhbnZhcy5EZWxldGUoKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIGNvbGxlY3Rpb24gb2YgY2hhbmdlcy5cbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydQb2x5bGluZU9wdGlvbnMnXSkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVQb2x5bGluZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10gJiYgIWNoYW5nZXNbJ1Zpc2libGUnXS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiBsLlNldFZpc2libGUodGhpcy5WaXNpYmxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFuZ2VzWydaSW5kZXgnXSAmJiAhY2hhbmdlc1snWkluZGV4J10uZmlyc3RDaGFuZ2UpIHx8XG4gICAgICAgICAgICAoY2hhbmdlc1snTGF5ZXJPZmZzZXQnXSAmJiAhY2hhbmdlc1snTGF5ZXJPZmZzZXQnXS5maXJzdENoYW5nZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSBaSW5kZXggb3IgTGF5ZXJPZmZzZXQgYWZ0ZXIgdGhlIGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY2hhbmdlc1snU2hvd0xhYmVscyddICYmICFjaGFuZ2VzWydTaG93TGFiZWxzJ10uZmlyc3RDaGFuZ2UpIHx8XG4gICAgICAgICAgICAoY2hhbmdlc1snTGFiZWxNaW5ab29tJ10gJiYgIWNoYW5nZXNbJ0xhYmVsTWluWm9vbSddLmZpcnN0Q2hhbmdlKSB8fFxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xhYmVsTWF4Wm9vbSddICYmICFjaGFuZ2VzWydMYWJlbE1heFpvb20nXS5maXJzdENoYW5nZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLlJlZHJhdyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXBzJ10gJiYgdGhpcy5fdG9vbHRpcCkge1xuICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKGNoYW5nZXNbJ1Nob3dUb29sdGlwcyddLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMYXllciBJZC5cbiAgICAgKiBAcmV0dXJucyAtIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgaWQuXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuICdNYXBQb2x5bGluZUxheWVyLScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhcmlvdXMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgcG9seWxpbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHAgLSB0aGUgcG9seWxpbmUgZm9yIHdoaWNoIHRvIGFkZCB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMocDogUG9seWxpbmUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5bGluZUNsaWNrLmVtaXQoe1BvbHlsaW5lOiBwLCBDbGljazogZXZ9KSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWxpbmVEYmxDbGljay5lbWl0KHtQb2x5bGluZTogcCwgQ2xpY2s6IGV2fSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5bGluZU1vdXNlTW92ZS5lbWl0KHtQb2x5bGluZTogcCwgQ2xpY2s6IGV2fSkgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3V0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lTW91c2VPdXQuZW1pdCh7UG9seWxpbmU6IHAsIENsaWNrOiBldn0pIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWxpbmVNb3VzZU92ZXIuZW1pdCh7UG9seWxpbmU6IHAsIENsaWNrOiBldn0pIH1cbiAgICAgICAgXTtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgob2JqKSA9PiBwLkFkZExpc3RlbmVyKG9iai5uYW1lLCBvYmouaGFuZGxlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBwb2x5bGluZSBsYWJlbHMuIENhbGxlZCBieSB0aGUgQ2FudmFzIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWwgLSBUaGUgY2FudmFzIG9uIHdoaWNoIHRvIGRyYXcgdGhlIGxhYmVscy5cbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxuICAgICAqL1xuICAgIHByaXZhdGUgRHJhd0xhYmVscyhlbDogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuU2hvd0xhYmVscykge1xuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRab29tKCkudGhlbih6ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5MYWJlbE1pblpvb20gPD0geiAmJiB0aGlzLkxhYmVsTWF4Wm9vbSA+PSB6KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5fbGFiZWxzLm1hcCh4ID0+IHgudGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uc1RvUG9pbnRzKHRoaXMuX2xhYmVscy5tYXAoeCA9PiB4LmxvYykpLnRoZW4obG9jcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplOiBJU2l6ZSA9IHRoaXMuX21hcFNlcnZpY2UuTWFwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZHJhdyB0aGUgcG9pbnQgaWYgaXQgaXMgbm90IGluIHZpZXcuIFRoaXMgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZSB3aGVuIHpvb21lZCBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jc1tpXS54ID49IDAgJiYgbG9jc1tpXS55ID49IDAgJiYgbG9jc1tpXS54IDw9IHNpemUud2lkdGggJiYgbG9jc1tpXS55IDw9IHNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1RleHQoY3R4LCBsb2NzW2ldLCBsYWJlbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgdGV4dCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2Ugb24gdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gY3R4IC0gQ2FudmFzIGRyYXdpbmcgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gbG9jIC0gUGl4ZWwgbG9jYXRpb24gb24gdGhlIGNhbnZhcyB3aGVyZSB0byBjZW50ZXIgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHRleHQgLSBUZXh0IHRvIGRyYXcuXG4gICAgICovXG4gICAgcHJpdmF0ZSBEcmF3VGV4dChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbG9jOiBJUG9pbnQsIHRleHQ6IHN0cmluZykge1xuICAgICAgICBsZXQgbG86IElMYWJlbE9wdGlvbnMgPSB0aGlzLkxhYmVsT3B0aW9ucztcbiAgICAgICAgaWYgKGxvID09IG51bGwgJiYgdGhpcy5fdG9vbHRpcCkgeyBsbyA9IHRoaXMuX3Rvb2x0aXAuRGVmYXVsdExhYmVsU3R5bGU7IH1cbiAgICAgICAgaWYgKGxvID09IG51bGwpIHsgbG8gPSB0aGlzLl9kZWZhdWx0T3B0aW9uczsgfVxuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxvLnN0cm9rZUNvbG9yO1xuICAgICAgICBjdHguZm9udCA9IGAke2xvLmZvbnRTaXplfXB4ICR7bG8uZm9udEZhbWlseX1gO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGNvbnN0IHN0cm9rZVdlaWdodDogbnVtYmVyID0gbG8uc3Ryb2tlV2VpZ2h0O1xuICAgICAgICBpZiAodGV4dCAmJiBzdHJva2VXZWlnaHQgJiYgc3Ryb2tlV2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXZWlnaHQ7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQodGV4dCwgbG9jLngsIGxvYy55KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbG8uZm9udENvbG9yO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgbG9jLngsIGxvYy55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSB0b29sdGlwIGFuZCB0aGUgYXR0YWNobWVudCBvZiB0aGUgYXNzb2NpYXRlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hvdyAtIFRydWUgdG8gZW5hYmxlIHRoZSB0b29sdGlwLCBmYWxzZSB0byBkaXNhYmxlLlxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwcml2YXRlIE1hbmFnZVRvb2x0aXAoc2hvdzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGFkZCB0b29sdGlwIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWxpbmVNb3VzZU1vdmUuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5fY2FudmFzLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGUuQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBsb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnB1c2godGhpcy5Qb2x5bGluZU1vdXNlT3Zlci5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuUG9seWxpbmUuVGl0bGUgJiYgZS5Qb2x5bGluZS5UaXRsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogSUxhdExvbmcgPSB0aGlzLl9jYW52YXMuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZS5DbGljayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCd0ZXh0JywgZS5Qb2x5bGluZS5UaXRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWxpbmVNb3VzZU91dC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdG9vbHRpcCBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnNwbGljZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIHVwZGF0ZXMgdGhlIHBvbHlsaW5lc3MgYmFzZWQgb24gdGhlIHBvbHlsaW5lIG9wdGlvbnMuIFRoaXMgd2lsbCBwbGFjZSB0aGUgcG9seWxpbmVzIG9uIHRoZSBtYXBcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgcHJpdmF0ZSBVcGRhdGVQb2x5bGluZXMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllclByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9seWxpbmVzOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPiA9IHRoaXMuX3N0cmVhbWluZyA/IHRoaXMuX3BvbHlsaW5lc0xhc3Quc3BsaWNlKDApIDogdGhpcy5fcG9seWxpbmVzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpIHsgdGhpcy5fbGFiZWxzLnNwbGljZSgwKTsgfVxuXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgcHJvbWlzZSBmb3IgdGhlIHBvbHlsaW5lc1xuICAgICAgICAgICAgY29uc3QgbHA6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4gPSB0aGlzLl9zZXJ2aWNlLkNyZWF0ZVBvbHlsaW5lcyhsLkdldE9wdGlvbnMoKS5pZCwgcG9seWxpbmVzKTtcblxuICAgICAgICAgICAgLy8gc2V0IHBvbHlsaW5lcyBvbmNlIHByb21pc2VzIGFyZSBmdWxsZmlsbGVkLlxuICAgICAgICAgICAgbHAudGhlbihwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB5OiBBcnJheTxQb2x5bGluZT4gPSBuZXcgQXJyYXk8UG9seWxpbmU+KCk7XG4gICAgICAgICAgICAgICAgcC5mb3JFYWNoKHBvbHkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2x5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlOiBzdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkczogQXJyYXk8SUxhdExvbmc+ID0gbmV3IEFycmF5PElMYXRMb25nPigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seS5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKHguQ2VudHJvaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LlRpdGxlICE9IG51bGwgJiYgeC5UaXRsZS5sZW5ndGggPiAwICYmIHRpdGxlLmxlbmd0aCA9PT0gMCkgeyB0aXRsZSA9IHguVGl0bGU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxzLnB1c2goe2xvYzogUG9seWxpbmUuR2V0UG9seWxpbmVDZW50cm9pZChjZW50cm9pZHMpLCB0aXRsZTogdGl0bGV9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkucHVzaChwb2x5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LlRpdGxlICE9IG51bGwgJiYgcG9seS5UaXRsZS5sZW5ndGggPiAwKSB7IHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IHBvbHkuQ2VudHJvaWQsIHRpdGxlOiBwb2x5LlRpdGxlfSk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMocG9seSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW1pbmcgPyBsLkFkZEVudGl0aWVzKHkpIDogbC5TZXRFbnRpdGllcyh5KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7IHRoaXMuX2NhbnZhcy5SZWRyYXcoIXRoaXMuX3N0cmVhbWluZyk7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBYnN0cmFjdCBpbXBsZW1lbnRhdGlvbi4gVVNlZCBmb3IgZGVmaW50aW9uIG9ubHkgYW5kIGFzIGEgYmFzZSB0byBpbXBsZW1lbnQgeW91clxuICogb3duIHByb3ZpZGVyLlxuICpcbiAqIEBleHBvcnRcbiAqIEBhYnN0cmFjdFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWFwQVBJTG9hZGVyIHtcblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBuZWNlc3NhcnkgcmVzb3VyY2VzIGZvciBhIGdpdmVuIG1hcCBhcmNoaXRlY3R1cmUuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCB3aGVuIHRoZSByZXNvdXJjZXMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBBUElMb2FkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBMb2FkKCk6IFByb21pc2U8dm9pZD47XG5cbn1cblxuLyoqXG4gKiBEb2N1bWVudCBSZWZlcmVuY2Ugc2VydmljZSB0byBhc3Npc3Qgd2l0aCBhYnN0cmFjdGluZyB0aGUgYXZhaWxhYmlsaXR5IG9mIGRvY3VtZW50LiBOZWVkZWQgZm9yIEFPVCBhbmRcbiAqIFNlcnZlciBTaWRlIHJlbmRlcmluZ1xuICpcbiAqIEBleHBvcnRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERvY3VtZW50UmVmIHtcblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhIGRvY3VtZW50IGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZS4gR2VuZXJhbGx5IHdpbGwgYmUgdHJ1ZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB1bmxlc3MgdGhlcmVcbiAgICAgKiB0aGVyZSBpcyBhIGJyb3dzZXItbGVzcyBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgY3VycmVudCBub24tYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBEb2N1bWVudFJlZlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhKHR5cGVvZiAoZG9jdW1lbnQpID09PSAndW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIERvY3VtZW50UmVmXG4gICAgICovXG4gICAgcHVibGljIEdldE5hdGl2ZURvY3VtZW50KCk6IGFueSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGRvY3VtZW50KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG59XG5cbi8qKlxuICogV2luZG93IFJlZmVyZW5jZSBzZXJ2aWNlIHRvIGFzc2lzdCB3aXRoIGFic3RyYWN0aW5nIHRoZSBhdmFpbGFiaWxpdHkgb2Ygd2luZG93LiBOZWVkZWQgZm9yIEFPVCBhbmRcbiAqIFNlcnZlciBTaWRlIHJlbmRlcmluZ1xuICpcbiAqIEBleHBvcnRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFdpbmRvd1JlZiB7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYSB3aW5kb3cgaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlLiBHZW5lcmFsbHkgd2lsbCBiZSB0cnVlIGluIHRoZSBicm93c2VyIGFuZCBmYWxzZSBvdGhlcndpc2UsIHVubGVzcyB0aGVyZVxuICAgICAqIHRoZXJlIGlzIGEgYnJvd3Nlci1sZXNzIGltcGxlbWVudGF0aW9uIGluIHRoZSBjdXJyZW50IG5vbi1icm93c2VyIGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1JlZlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgSXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhKHR5cGVvZiAod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpbmRvdyBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB3aW5kb3cgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1JlZlxuICAgICAqL1xuICAgIHB1YmxpYyBHZXROYXRpdmVXaW5kb3coKTogYW55IHtcbiAgICAgICAgaWYgKHR5cGVvZiAod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcblxuLyoqXG4gKiBQcm90b2NvbCBlbnVtZXJhdGlvblxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBlbnVtIFNjcmlwdFByb3RvY29sIHtcbiAgICBIVFRQLFxuICAgIEhUVFBTLFxuICAgIEFVVE9cbn1cblxuLyoqXG4gKiBCaW5nIE1hcHMgVjggc3BlY2lmaWMgbG9hZGVyIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgQmluZ01hcEFQSUxvYWRlcn1cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnICB7XG5cbiAgICAvLy9cbiAgICAvLy8gQVBJIGtleSBmb3IgYmluZyBtYXBzXG4gICAgLy8vXG4gICAgYXBpS2V5ID0gJyc7XG5cbiAgICAvLy9cbiAgICAvLy8gSG9zdCBhbmQgUGF0aCB1c2VkIGZvciB0aGUgYDxzY3JpcHQ+YCB0YWcuXG4gICAgLy8vXG4gICAgaG9zdEFuZFBhdGggPSAnd3d3LmJpbmcuY29tL2FwaS9tYXBzL21hcGNvbnRyb2wnO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3RvY29sIHVzZWQgZm9yIHRoZSBgPHNjcmlwdD5gIHRhZy5cbiAgICAvLy9cbiAgICBwcm90b2NvbDogU2NyaXB0UHJvdG9jb2wgPSBTY3JpcHRQcm90b2NvbC5IVFRQUztcblxuICAgIC8vL1xuICAgIC8vLyBUaGUgYnJhbmNoIHRvIGJlIHVzZWQuIExlYXZlIGVtcHR5IGZvciBwcm9kdWN0aW9uLiBVc2UgZXhwZXJpbWVudGFsXG4gICAgLy8vXG4gICAgYnJhbmNoID0gJyc7XG59XG5cbi8qKlxuICogRGVmYXVsdCBsb2FkZXIgY29uZmlndXJhdGlvbi5cbiAqL1xuY29uc3QgREVGQVVMVF9DT05GSUdVUkFUSU9OID0gbmV3IEJpbmdNYXBBUElMb2FkZXJDb25maWcoKTtcblxuLyoqXG4gKiBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24gZm9yIHRoZSB7QGxpbmsgTWFwQVBJTG9hZGVyfSBzZXJ2aWNlLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEJpbmdNYXBBUElMb2FkZXIgZXh0ZW5kcyBNYXBBUElMb2FkZXIge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlZmludGl0aW9ucy5cbiAgICAvLy9cbiAgICBwcml2YXRlIF9zY3JpcHRMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8vL1xuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXG4gICAgICovXG4gICAgcHVibGljIGdldCBDb25maWcoKTogQmluZ01hcEFQSUxvYWRlckNvbmZpZyB7IHJldHVybiB0aGlzLl9jb25maWc7IH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ01hcEFQSUxvYWRlci5cbiAgICAgKiBAcGFyYW0gX2NvbmZpZyAgLSBUaGUgbG9hZGVyIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIF93aW5kb3dSZWYgLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgV2luZG93UmVmfS4gTmVjZXNzYXJ5IGJlY2F1c2UgQmluZyBNYXAgVjggaW50ZXJhY3RzIHdpdGggdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgICogQHBhcmFtIF9kb2N1bWVudFJlZiAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBEb2N1bWVudFJlZn0uXG4gICAgICogTmVjZXNzYXJ5IGJlY2F1c2UgQmluZyBNYXAgVjggaW50ZXJhY3RzIHdpdGggdGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoIEBPcHRpb25hbCgpIHByaXZhdGUgX2NvbmZpZzogQmluZ01hcEFQSUxvYWRlckNvbmZpZywgcHJpdmF0ZSBfd2luZG93UmVmOiBXaW5kb3dSZWYsIHByaXZhdGUgX2RvY3VtZW50UmVmOiBEb2N1bWVudFJlZikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnID09PSBudWxsIHx8IHRoaXMuX2NvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcgPSBERUZBVUxUX0NPTkZJR1VSQVRJT047XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHMgYW5kIE1hcEFQSUxvYWRlciBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBuZWNlc3NhcnkgcmVzb3VyY2VzIGZvciBCaW5nIE1hcHMgVjguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcEFQSUxvYWRlclxuICAgICAqL1xuICAgIHB1YmxpYyBMb2FkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAodGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTmFtZSA9IGBhbmd1bGFyMmJpbmdtYXBzJHtuZXcgRGF0ZSgpLmdldE1pbGxpc2Vjb25kcygpfWA7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLkdldFNjcmlwdFNyYyhjYWxsYmFja05hbWUpO1xuXG4gICAgICAgIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmU6IEZ1bmN0aW9uLCByZWplY3Q6IEZ1bmN0aW9uKSA9PiB7XG4gICAgICAgICAgICAoPGFueT50aGlzLl93aW5kb3dSZWYuR2V0TmF0aXZlV2luZG93KCkpW2NhbGxiYWNrTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gKGVycm9yOiBFdmVudCkgPT4geyByZWplY3QoZXJyb3IpOyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYuR2V0TmF0aXZlRG9jdW1lbnQoKS5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBCaW5nIE1hcCBWOCBzY3JpcHRzIHVybCBmb3IgaW5qZWN0aW9ucyBpbnRvIHRoZSBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tOYW1lIC0gTmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIEJpbmcgTWFwcyBWOCBzY3JpcHRzIGFyZSBsb2FkZWQuXG4gICAgICogQHJldHVybnMgLSBUaGUgdXJsIHRvIGJlIHVzZWQgdG8gbG9hZCB0aGUgQmluZyBNYXAgc2NyaXB0cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBHZXRTY3JpcHRTcmMoY2FsbGJhY2tOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBwcm90b2NvbFR5cGU6IFNjcmlwdFByb3RvY29sID0gKHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcucHJvdG9jb2wpIHx8IERFRkFVTFRfQ09ORklHVVJBVElPTi5wcm90b2NvbDtcbiAgICAgICAgbGV0IHByb3RvY29sOiBzdHJpbmc7XG5cbiAgICAgICAgc3dpdGNoIChwcm90b2NvbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NyaXB0UHJvdG9jb2wuQVVUTzpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5IVFRQOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2NyaXB0UHJvdG9jb2wuSFRUUFM6XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhvc3RBbmRQYXRoOiBzdHJpbmcgPSB0aGlzLl9jb25maWcuaG9zdEFuZFBhdGggfHwgREVGQVVMVF9DT05GSUdVUkFUSU9OLmhvc3RBbmRQYXRoO1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja05hbWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5icmFuY2ggIT09ICcnKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtc1snYnJhbmNoJ10gPSB0aGlzLl9jb25maWcuYnJhbmNoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtczogc3RyaW5nID0gT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXG4gICAgICAgICAgICAubWFwKChrOiBzdHJpbmcsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbSA9IChpID09PSAwKSA/ICc/JyA6ICcmJztcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0gKz0gYCR7a309JHtxdWVyeVBhcmFtc1trXX1gO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0QW5kUGF0aH0ke3BhcmFtc31gO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEluZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvaW5mby13aW5kb3cnO1xuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvaW5mb2JveC1hY3Rpb24nO1xuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2luZm9ib3gnO1xuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ0luZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWluZm8td2luZG93JztcbmltcG9ydCB7IEJpbmdNYXBFdmVudHNMb29rdXAgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWV2ZW50cy1sb29rdXAnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgSW5mb0JveFNlcnZpY2V9IGNvbnRyYWN0IGZvciB0aGUgQmluZyBNYXBzIFY4IGFyY2hpdGVjdHVyZS5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nSW5mb0JveFNlcnZpY2UgaW1wbGVtZW50cyBJbmZvQm94U2VydmljZSB7XG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2JveGVzOiBNYXA8SW5mb0JveENvbXBvbmVudCwgUHJvbWlzZTxJbmZvV2luZG93Pj4gPSBuZXcgTWFwPEluZm9Cb3hDb21wb25lbnQsIFByb21pc2U8SW5mb1dpbmRvdz4+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ0luZm9Cb3hTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgQmluZyBNYXBzIFY4LiBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBfem9uZSAtIEFuIGluc3RhbmNlIG9mIE5nWm9uZSB0byBwcm92aWRlIHpvbmUgYXdhcmUgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9Cb3hTZXJ2aWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW5mbyB3aW5kb3cgdG8gdGhlIG1hcCBvciBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRJbmZvV2luZG93KGluZm86IEluZm9Cb3hDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgaW5mby5MYXRpdHVkZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGluZm8uTG9uZ2l0dWRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogaW5mby5MYXRpdHVkZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5mby5JbmZvV2luZG93QWN0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5mby5JbmZvV2luZG93QWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluZm8uSW5mb1dpbmRvd0FjdGlvbnMuZm9yRWFjaCgoYWN0aW9uOiBJbmZvQm94QWN0aW9uRGlyZWN0aXZlKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogYWN0aW9uLkxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXI6ICgpID0+IHsgYWN0aW9uLkFjdGlvbkNsaWNrZWQuZW1pdChudWxsKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uSHRtbENvbnRlbnQgIT09ICcnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmh0bWxDb250ZW50ID0gaW5mby5IdG1sQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBpbmZvLlRpdGxlO1xuICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8ueE9mZnNldCB8fCBpbmZvLnlPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpeGVsT2Zmc2V0ID09IG51bGwpIHsgb3B0aW9ucy5waXhlbE9mZnNldCA9IHsgeDogMCwgeTogMCB9OyB9XG4gICAgICAgICAgICBpZiAoaW5mby54T2Zmc2V0KSB7IG9wdGlvbnMucGl4ZWxPZmZzZXQueCA9IGluZm8ueE9mZnNldDsgfVxuICAgICAgICAgICAgaWYgKGluZm8ueU9mZnNldCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0LnkgPSBpbmZvLnlPZmZzZXQ7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IGluZm8uVmlzaWJsZTtcbiAgICAgICAgY29uc3QgaW5mb1Byb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUluZm9XaW5kb3cob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2JveGVzLnNldChpbmZvLCBpbmZvUHJvbWlzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFuIEluZm9Cb3hDb21wb25lbnQgdGhhdCBpcyBvcGVuLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggaGFzIGJlZW4gY2xvc2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENsb3NlKGluZm86IEluZm9Cb3hDb21wb25lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB3LkNsb3NlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYW4gaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXG4gICAgICogQHBhcmFtIGluZm9Db21wb25lbnQgLSBUaGUge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIGluZm9Db21wb25lbnQ6IEluZm9Cb3hDb21wb25lbnQpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lVHJhbnNsYXRlZCA9IEJpbmdNYXBFdmVudHNMb29rdXBbZXZlbnROYW1lXTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2JveGVzLmdldChpbmZvQ29tcG9uZW50KS50aGVuKChiOiBJbmZvV2luZG93KSA9PiB7XG4gICAgICAgICAgICAgICAgYi5BZGRMaXN0ZW5lcihldmVudE5hbWVUcmFuc2xhdGVkLCAoZTogVCkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gaW5mb2JveC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLl9ib3hlcy5nZXQoaW5mbyk7XG4gICAgICAgIGlmICh3ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdy50aGVuKChpOiBJbmZvV2luZG93KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGkuQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3hlcy5kZWxldGUoaW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYW4gaW5mb2JveCB0aGF0IGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBPcGVuKGluZm86IEluZm9Cb3hDb21wb25lbnQsIGxvYz86IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChpbmZvLkNsb3NlSW5mb0JveGVzT25PcGVuIHx8IGluZm8uTW9kYWwpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIGFsbCBvcGVuIGluZm8gYm94ZXMuXG4gICAgICAgICAgICB0aGlzLl9ib3hlcy5mb3JFYWNoKCh2OiBQcm9taXNlPEluZm9XaW5kb3c+LCBpOiBJbmZvQm94Q29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uSWQgIT09IGkuSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdi50aGVuKHcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcuSXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbmZvLkh0bWxDb250ZW50ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHRtbENvbnRlbnQgPSBpbmZvLkh0bWxDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IGluZm8uVGl0bGU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3LlNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChpbmZvLkxhdGl0dWRlICYmIGluZm8uTG9uZ2l0dWRlKSB7XG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbih7IGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLCBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobG9jKSB7XG4gICAgICAgICAgICAgICAgLy8vXG4gICAgICAgICAgICAgICAgLy8vIHRoaXMgc2l0dWF0aW9uIGlzIHNwZWNpZmljYWxseSB1c2VkIGZvciBjbHVzdGVyIGxheWVycyB0aGF0IHVzZSBzcGlkZXJpbmcuXG4gICAgICAgICAgICAgICAgLy8vXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbihsb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5mby5Ib3N0TWFya2VyKSB7XG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbih7IGxhdGl0dWRlOiBpbmZvLkhvc3RNYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogaW5mby5Ib3N0TWFya2VyLkxvbmdpdHVkZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcuT3BlbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmZvYm94IG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJSW5mb1dpbmRvd09wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zIHRvIHNldC4gT3B0aW9ucyBwcm92aWRlZCBhcmVcbiAgICAgKiBtZXJnZWQgd2l0aCB0aGUgZXhpc3Rpbmcgb3B0aW9ucyBvZiB0aGUgdW5kZXJseWluZyBpbmZvYm94LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IG9wdGlvbnMgaGF2ZSBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKChpOiBJbmZvV2luZG93KSA9PiBpLlNldE9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluZm9ib3ggYmFzZWQgb24gdGhlIHByb3BlcnRpZXMgc2V0IG9uIHRoZSBJbmZvQm94IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0UG9zaXRpb24oaW5mbzogSW5mb0JveENvbXBvbmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm94ZXMuZ2V0KGluZm8pLnRoZW4oKGk6IEluZm9XaW5kb3cpID0+IGkuU2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgbGF0aXR1ZGU6IGluZm8uTGF0aXR1ZGUsXG4gICAgICAgICAgICBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgTWFwTWFya2VyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtbWFya2VyJztcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbGF5ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NsdXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE1hcmtlclNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEJpbmcgTWFwcyBWOC5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nTWFya2VyU2VydmljZSBpbXBsZW1lbnRzIE1hcmtlclNlcnZpY2Uge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX21hcmtlcnM6IE1hcDxNYXBNYXJrZXJEaXJlY3RpdmUsIFByb21pc2U8TWFya2VyPj4gPSBuZXcgTWFwPE1hcE1hcmtlckRpcmVjdGl2ZSwgUHJvbWlzZTxNYXJrZXI+PigpO1xuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdNYXJrZXJTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS4gVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEJpbmdMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxuICAgICAqIEBwYXJhbSBfY2x1c3RlclNlcnZpY2UgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGluc3RhbmNlLlxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ0NsdXN0ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gc3VwcG9ydCB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIF9jbHVzdGVyU2VydmljZTogQ2x1c3RlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZW1iZXJzIGFuZCBNYXJrZXJTZXJ2aWNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWFya2VyLiBEZXBlbmRpbmcgb24gdGhlIG1hcmtlciBjb250ZXh0LCB0aGUgbWFya2VyIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYSBjb3JyZWNzcG9uZGluZyBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IElNYXJrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgbGF0aXR1ZGU6IG1hcmtlci5MYXRpdHVkZSwgbG9uZ2l0dWRlOiBtYXJrZXIuTG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICB0aXRsZTogbWFya2VyLlRpdGxlLFxuICAgICAgICAgICAgbGFiZWw6IG1hcmtlci5MYWJlbCxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogbWFya2VyLkRyYWdnYWJsZSxcbiAgICAgICAgICAgIGljb246IG1hcmtlci5JY29uVXJsLFxuICAgICAgICAgICAgaWNvbkluZm86IG1hcmtlci5JY29uSW5mbyxcbiAgICAgICAgICAgIGlzRmlyc3Q6IG1hcmtlci5Jc0ZpcnN0SW5TZXQsXG4gICAgICAgICAgICBpc0xhc3Q6IG1hcmtlci5Jc0xhc3RJblNldFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWFya2VyLldpZHRoKSB7IG8ud2lkdGggPSBtYXJrZXIuV2lkdGg7IH1cbiAgICAgICAgaWYgKG1hcmtlci5IZWlnaHQpIHsgby5oZWlnaHQgPSBtYXJrZXIuSGVpZ2h0OyB9XG4gICAgICAgIGlmIChtYXJrZXIuQW5jaG9yKSB7IG8uYW5jaG9yID0gbWFya2VyLkFuY2hvcjsgfVxuICAgICAgICBpZiAobWFya2VyLk1ldGFkYXRhKSB7IG8ubWV0YWRhdGEgPSBtYXJrZXIuTWV0YWRhdGE7IH1cblxuICAgICAgICAvLyBjcmVhdGUgbWFya2VyIHZpYSBwcm9taXNlLlxuICAgICAgICBsZXQgbWFya2VyUHJvbWlzZTogUHJvbWlzZTxNYXJrZXI+ID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcmtlci5JbkNsdXN0ZXJMYXllcikge1xuICAgICAgICAgICAgbWFya2VyUHJvbWlzZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlLkNyZWF0ZU1hcmtlcihtYXJrZXIuTGF5ZXJJZCwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFya2VyLkluQ3VzdG9tTGF5ZXIpIHtcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9sYXllclNlcnZpY2UuQ3JlYXRlTWFya2VyKG1hcmtlci5MYXllcklkLCBvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZU1hcmtlcihvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcmtlcnMuc2V0KG1hcmtlciwgbWFya2VyUHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXJrZXIuSWNvbkluZm8pIHtcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UudGhlbigobTogTWFya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGljb25JbmZvIHRvIHByb3ZpZGUgaG9vayB0byBkbyBwb3N0IGljb24gY3JlYXRpb24gYWN0aXZpdGllcyBhbmRcbiAgICAgICAgICAgICAgICAvLyBhbHNvIHJlLWFuY2hvciB0aGUgbWFya2VyXG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoby5pY29uSW5mbyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcDogSVBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAoby5pY29uSW5mby5zaXplICYmIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKG8uaWNvbkluZm8uc2l6ZS53aWR0aCAqIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueCkgOiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAoby5pY29uSW5mby5zaXplICYmIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKG8uaWNvbkluZm8uc2l6ZS5oZWlnaHQgKiBvLmljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvLnkpIDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG0uU2V0QW5jaG9yKHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbWFya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlcn0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZUV2ZW50T2JzZXJ2YWJsZTxUPihldmVudE5hbWU6IHN0cmluZywgbWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgY29uc3QgYjogU3ViamVjdDxUPiA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncmlnaHRjbGljaycpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXG4gICAgICAgIC8vL1xuXG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgbS5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PlxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSB7QGxpbmsgTWFwTWFya2VyfSB0byBiZSBkZWxldGVkLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgbWFya2VyIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgRGVsZXRlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpO1xuICAgICAgICBsZXQgcDogUHJvbWlzZTx2b2lkPiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwID0gbS50aGVuKChtYTogTWFya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5JbkNsdXN0ZXJMYXllcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5JbkN1c3RvbUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWEuRGVsZXRlTWFya2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZGVsZXRlKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNsaWNrZWQgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZyB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlLnByaW1pdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZS5wcmltaXRpdmUgaW5zdGFuY2VvZiBNaWNyb3NvZnQuTWFwcy5QdXNocGluKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcDogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IGUucHJpbWl0aXZlO1xuICAgICAgICBjb25zdCBsb2M6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gcC5nZXRMb2NhdGlvbigpO1xuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogbG9jLmxhdGl0dWRlLCBsb25naXR1ZGU6IGxvYy5sb25naXR1ZGUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBtYXJrZXIgbW9kZWwgZm9yIHRoZSBtYXJrZXIgYWxsb3dpbmcgYWNjZXNzIHRvIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbmF0aWxpeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlcn0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgbWFya2VyIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgTWFya2VyfSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXROYXRpdmVNYXJrZXIobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPE1hcmtlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBtYXJrZXIgcGl4ZWwgbG9jYXRpb24gZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgcGl4ZWxzIG9mIHRoZSBtYXJrZXIgb24gdGhlIG1hcCBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0UGl4ZWxzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJUG9pbnQge1xuICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlKTtcbiAgICAgICAgaWYgKGxvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihsb2MpO1xuICAgICAgICBjb25zdCBwOiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9IDxNaWNyb3NvZnQuTWFwcy5Qb2ludD4oPEJpbmdNYXBTZXJ2aWNlPlxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZSkuTWFwSW5zdGFuY2UudHJ5TG9jYXRpb25Ub1BpeGVsKGwsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHJldHVybiB7IHg6IHAueCwgeTogcC55IH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBnZW8gbG9jYXRpb24gdG8gYSBwaXhlbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbWFwIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBFaXRoZXIgYSB7QGxpbmsgTWFwTWFya2VyfSBvciBhIHtAbGluayBJTGF0TG9uZ30gZm9yIHRoZSBiYXNpcyBvZiB0cmFuc2xhdGlvbi5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhIHtAbGluayBJUG9pbnR9XG4gICAgICogd2l0aCB0aGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIE1hcE1hcmtlciBvciBJTGF0TG9uZyByZWxhdGl2ZSB0byB0aGUgbWFwIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBMb2NhdGlvblRvUG9pbnQodGFyZ2V0OiBNYXBNYXJrZXJEaXJlY3RpdmUgfCBJTGF0TG9uZyk6IFByb21pc2U8SVBvaW50PiB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwTWFya2VyRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQodGFyZ2V0KS50aGVuKChtOiBNYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsOiBJTGF0TG9uZyA9IG0uTG9jYXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxJUG9pbnQ+ID0gdGhpcy5fbWFwU2VydmljZS5Mb2NhdGlvblRvUG9pbnQobCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwU2VydmljZS5Mb2NhdGlvblRvUG9pbnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhbmNob3IgcG9zaXRpb24gZm9yIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlcn0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgYW5jaG9yLlxuICAgICAqIEFuY2hvciBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVXBkYXRlQW5jaG9yKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xuICAgICAgICAgICAgbS5TZXRBbmNob3IobWFya2VyLkFuY2hvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIGRyYWdhYmlsaXR5LlxuICAgICAqIERyYWdhYmlsaXR5IGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBtYXJrZXIgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBVcGRhdGVEcmFnZ2FibGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldERyYWdnYWJsZShtYXJrZXIuRHJhZ2dhYmxlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgSWNvbiBvbiB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJ9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGljb24uXG4gICAgICogSWNvbiBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaWNvbiBpbmZvcm1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZUljb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChtOiBNYXJrZXIsIGljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBtLlNldEljb24oaWNvbik7XG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoaWNvbkluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIuSWNvbkluZm8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gTWFya2VyLkNyZWF0ZU1hcmtlcihtYXJrZXIuSWNvbkluZm8pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7IHJldHVybihwYXlsb2FkKG0sIHMsIG1hcmtlci5JY29uSW5mbykpOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ocGF5bG9hZChtLCB4Lmljb24sIHguaWNvbkluZm8pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuKG0uU2V0SWNvbihtYXJrZXIuSWNvblVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsYWJlbCBvbiB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGxhYmVsLlxuICAgICAqIExhYmVsIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYWJlbCBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZUxhYmVsKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4geyBtLlNldExhYmVsKG1hcmtlci5MYWJlbCk7IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBjb29yZGluYXRlcy5cbiAgICAgKiBDb29yZGluYXRlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZU1hcmtlclBvc2l0aW9uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oXG4gICAgICAgICAgICAobTogTWFya2VyKSA9PiBtLlNldFBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogbWFya2VyLkxhdGl0dWRlLFxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRpdGxlIG9uIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgdGl0bGUuXG4gICAgICogVGl0bGUgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHRpdGxlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVXBkYXRlVGl0bGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldFRpdGxlKG1hcmtlci5UaXRsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB2aXNpYmxpdHkuXG4gICAgICogVmlzaWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZVZpc2libGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldFZpc2libGUobWFya2VyLlZpc2libGUpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmVyLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBBUElMb2FkZXIgfSBmcm9tICcuLi9tYXBhcGlsb2FkZXInO1xuaW1wb3J0IHsgQmluZ01hcEFQSUxvYWRlciwgQmluZ01hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vYmluZy1tYXAuYXBpLWxvYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWdvbic7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XG5pbXBvcnQgeyBNYXJrZXJUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyLXR5cGUtaWQnO1xuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9pbmZvLXdpbmRvdyc7XG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xuaW1wb3J0IHsgQmluZ0xheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1sYXllcic7XG5pbXBvcnQgeyBCaW5nQ2x1c3RlckxheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1jbHVzdGVyLWxheWVyJztcbmltcG9ydCB7IEJpbmdJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1pbmZvLXdpbmRvdyc7XG5pbXBvcnQgeyBCaW5nUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctcG9seWdvbic7XG5pbXBvcnQgeyBCaW5nUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLXBvbHlsaW5lJztcbmltcG9ydCB7IE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWxhYmVsJztcbmltcG9ydCB7IE1peGluQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctY2FudmFzLW92ZXJsYXknO1xuaW1wb3J0IHsgQmluZ0NhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWJveCc7XG5cbmltcG9ydCB7IEJpbmdNYXBFdmVudHNMb29rdXAgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWV2ZW50cy1sb29rdXAnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBNYXBTZXJ2aWNlIGFic3RyYWN0IGltcGxlbWVudGluZyBhIEJpbiBNYXAgVjggcHJvdmlkZXJcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nTWFwU2VydmljZSBpbXBsZW1lbnRzIE1hcFNlcnZpY2Uge1xuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBEZWNsYXJhdGlvbnNcbiAgICAvLy9cblxuICAgIHByaXZhdGUgX21hcDogUHJvbWlzZTxNaWNyb3NvZnQuTWFwcy5NYXA+O1xuICAgIHByaXZhdGUgX21hcEluc3RhbmNlOiBNaWNyb3NvZnQuTWFwcy5NYXA7XG4gICAgcHJpdmF0ZSBfbWFwUmVzb2x2ZXI6ICh2YWx1ZT86IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4gdm9pZDtcbiAgICBwcml2YXRlIF9jb25maWc6IEJpbmdNYXBBUElMb2FkZXJDb25maWc7XG4gICAgcHJpdmF0ZSBfbW9kdWxlczogTWFwPHN0cmluZywgT2JqZWN0PiA9IG5ldyBNYXA8c3RyaW5nLCBPYmplY3Q+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgRGVmaW5pdGlvbnNcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgbG9hZGVkIEJvbmcgbW9kdWxlcy5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTG9hZGVkTW9kdWxlcygpOiBNYXA8c3RyaW5nLCBPYmplY3Q+IHsgcmV0dXJuIHRoaXMuX21vZHVsZXM7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEJpbmcgTWFwIGNvbnRyb2wgaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWFwSW5zdGFuY2UoKTogTWljcm9zb2Z0Lk1hcHMuTWFwIHsgcmV0dXJuIHRoaXMuX21hcEluc3RhbmNlOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgUHJvbWlzZSBmb3IgYSBCaW5nIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIHtAbGluayBNYXBJbnN0YW5jZX0gaWYgeW91XG4gICAgICogYXJlIG5vdCBzdXJlIGlmIGFuZCB3aGVuIHRoZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIGdldCBNYXBQcm9taXNlKCk6IFByb21pc2U8TWljcm9zb2Z0Lk1hcHMuTWFwPiB7IHJldHVybiB0aGlzLl9tYXA7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcHMgcGh5c2ljYWwgc2l6ZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWFwU2l6ZSgpOiBJU2l6ZSB7XG4gICAgICAgIGlmICh0aGlzLk1hcEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBzOiBJU2l6ZSA9IHsgd2lkdGg6IHRoaXMuTWFwSW5zdGFuY2UuZ2V0V2lkdGgoKSwgaGVpZ2h0OiB0aGlzLk1hcEluc3RhbmNlLmdldEhlaWdodCgpIH07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ01hcFNlcnZpY2UuXG4gICAgICogQHBhcmFtIF9sb2FkZXIgTWFwQVBJTG9hZGVyIGluc3RhbmNlIGltcGxlbWVudGVkIGZvciBCaW5nIE1hcHMuIFRoaXMgaW5zdGFuY2Ugd2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXG4gICAgICogQHBhcmFtIF96b25lIE5nWm9uZSBvYmplY3QgdG8gZW5hYmxlIHpvbmUgYXdhcmUgcHJvbWlzZXMuIFRoaXMgd2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IE1hcEFQSUxvYWRlciwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLk1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gKDxCaW5nTWFwQVBJTG9hZGVyPnRoaXMuX2xvYWRlcikuQ29uZmlnO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwU2VydmljZSBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgb3ZlcmxheSBsYXllciB0byBwZXJmb3JtIGN1c3RvbSBkcmF3aW5nIG92ZXIgdGhlIG1hcCB3aXRoIG91dFxuICAgICAqIHNvbWUgb2YgdGhlIG92ZXJoZWFkIGFzc29jaWF0ZWQgd2l0aCBnb2luZyB0aHJvdWdoIHRoZSBNYXAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gZHJhd0NhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlXG4gICAgICogcmVuZGVyZWQgZm9yIHRoZSBjdXJyZW50IG1hcCB2aWV3LlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBDYW52YXNPdmVybGF5fSBvYmplY3QuXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5OiBCaW5nQ2FudmFzT3ZlcmxheSA9IG5ldyBCaW5nQ2FudmFzT3ZlcmxheShkcmF3Q2FsbGJhY2spO1xuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQob3ZlcmxheSk7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEJpbmcgbWFwIGNsdXN0ZXIgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuIFNlZSB7QGxpbmsgSUNsdXN0ZXJPcHRpb25zfS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlckxheWVyKG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSBuZXcgUHJvbWlzZTxMYXllcj4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5Mb2FkTW9kdWxlKCdNaWNyb3NvZnQuTWFwcy5DbHVzdGVyaW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVDbHVzdGVyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIobmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+KCksIG8pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmw6IEJpbmdDbHVzdGVyTGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5sYXllcnMuaW5zZXJ0KGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgYmwgPSBuZXcgQmluZ0NsdXN0ZXJMYXllcihsYXllciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJsLlNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZvcm1hdGlvbiB3aW5kb3cgZm9yIGEgbWFwIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgSW5mb1dpbmRvd30gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgTWljcm9zb2Z0Lk1hcHMuSW5mb2JveCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlSW5mb1dpbmRvdyhvcHRpb25zPzogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTxJbmZvV2luZG93PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcbiAgICAgICAgICAgIGxldCBsb2M6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvYyA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jID0gbmV3IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uKG9wdGlvbnMucG9zaXRpb24ubGF0aXR1ZGUsIG9wdGlvbnMucG9zaXRpb24ubG9uZ2l0dWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZm9Cb3g6IE1pY3Jvc29mdC5NYXBzLkluZm9ib3ggPSBuZXcgTWljcm9zb2Z0Lk1hcHMuSW5mb2JveChsb2MsIEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVJbmZvQm94T3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgICAgICBpbmZvQm94LnNldE1hcChtYXApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5nSW5mb1dpbmRvdyhpbmZvQm94KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBsYXllciB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci4gU2VlIHtAbGluayBJTGF5ZXJPcHRpb25zfVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBMYXllcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZUxheWVyKG9wdGlvbnM6IElMYXllck9wdGlvbnMpOiBQcm9taXNlPExheWVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyOiBNaWNyb3NvZnQuTWFwcy5MYXllciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5MYXllcihvcHRpb25zLmlkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQobGF5ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5nTGF5ZXIobGF5ZXIsIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWwgLSBIVE1MIGVsZW1lbnQgdG8gaG9zdCB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBtYXAgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVNYXAoZWw6IEhUTUxFbGVtZW50LCBtYXBPcHRpb25zOiBJTWFwT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLkxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGx5IG1peGluc1xuICAgICAgICAgICAgTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldygpO1xuICAgICAgICAgICAgTWl4aW5DYW52YXNPdmVybGF5KCk7XG5cbiAgICAgICAgICAgIC8vIG1hcCBzdGFydHVwLi4uXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuRGlzcG9zZU1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSU1hcExvYWRPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvYWRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFvLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgby5jcmVkZW50aWFscyA9IHRoaXMuX2NvbmZpZy5hcGlLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTWFwKGVsLCBvKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbWFwO1xuICAgICAgICAgICAgdGhpcy5fbWFwUmVzb2x2ZXIobWFwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEJpbmcgbWFwIG1hcmtlciB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gW29wdGlvbnM9PElNYXJrZXJPcHRpb25zPnt9XSAtIE9wdGlvbnMgZm9yIHRoZSBtYXJrZXIuIFNlZSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9LlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBNYXJrZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLlB1c2hQaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyA9IDxJTWFya2VyT3B0aW9ucz57fSk6IFByb21pc2U8TWFya2VyPiB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAoaWNvbjogc3RyaW5nLCBtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCk6IEJpbmdNYXJrZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycpIHsgby5pY29uID0gaWNvbjsgfVxuICAgICAgICAgICAgY29uc3QgcHVzaHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IG5ldyBNaWNyb3NvZnQuTWFwcy5QdXNocGluKGxvYywgbyk7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXI6IEJpbmdNYXJrZXIgPSBuZXcgQmluZ01hcmtlcihwdXNocGluLCBtYXAsIG51bGwpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBtYXJrZXIuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxuICAgICAgICAgICAgbWFwLmVudGl0aWVzLnB1c2gocHVzaHBpbik7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pY29uSW5mbyAmJiBvcHRpb25zLmljb25JbmZvLm1hcmtlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gTWFya2VyLkNyZWF0ZU1hcmtlcihvcHRpb25zLmljb25JbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChzKSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIChwYXlsb2FkKHMsIG1hcCkpOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBheWxvYWQoeC5pY29uLCBtYXApKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXlsb2FkKG51bGwsIG1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcG9seWdvbiB3aXRoaW4gdGhlIEJpbmcgTWFwcyBWOCBtYXAgY29udGV4dFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWdvbi4gU2VlIHtAbGluayBJUG9seWdvbk9wdGlvbnN9LlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBQb2x5Z29ufSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBuYXRpdmUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24ob3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMob3B0aW9ucy5wYXRocyk7XG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBwb2x5OiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24obG9jcywgbyk7XG4gICAgICAgICAgICBtYXAuZW50aXRpZXMucHVzaChwb2x5KTtcblxuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBCaW5nUG9seWdvbihwb2x5LCB0aGlzLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcC5NZXRhZGF0YS5zZXQoaywgdikpOyB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0xhYmVsICE9IG51bGwpIHsgcC5TaG93TGFiZWwgPSBvcHRpb25zLnNob3dMYWJlbDsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcC5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNaW5ab29tICE9IG51bGwpIHsgcC5MYWJlbE1pblpvb20gPSBvcHRpb25zLmxhYmVsTWluWm9vbTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWRpdGFibGUpIHsgcC5TZXRFZGl0YWJsZShvcHRpb25zLmVkaXRhYmxlKTsgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwb2x5bGluZSB3aXRoaW4gdGhlIEJpbmcgTWFwcyBWOCBtYXAgY29udGV4dFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWxpbmUuIFNlZSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlsaW5lfSBvYmplY3QgKG9yIGFuIGFycmF5IHRoZXJlb2YgZm9yIGNvbXBsZXggcGF0aHMpLFxuICAgICAqIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBuYXRpdmUgcG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lIHwgQXJyYXk8UG9seWxpbmU+PiB7XG4gICAgICAgIGxldCBwb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmU7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jczogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhbMF0pKSB7XG4gICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUobG9jc1swXSwgbyk7XG4gICAgICAgICAgICAgICAgbWFwLmVudGl0aWVzLnB1c2gocG9seWxpbmUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGwgPSBuZXcgQmluZ1BvbHlsaW5lKHBvbHlsaW5lLCBtYXAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcGwuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7IHBsLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcGwuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcbiAgICAgICAgICAgICAgICBsb2NzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKHAsIG8pO1xuICAgICAgICAgICAgICAgICAgICBtYXAuZW50aXRpZXMucHVzaChwb2x5bGluZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGwgPSBuZXcgQmluZ1BvbHlsaW5lKHBvbHlsaW5lLCBtYXAsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBsLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHsgcGwuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcGwuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGxheWVyIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIExheWVyIHRvIGRlbGV0ZS4gU2VlIHtAbGluayBMYXllcn0uIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhlIEJpbmcgc3BlY2lmaWMgTGF5ZXIgbW9kZWwgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTGF5ZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xuICAgICAgICAgICAgbWFwLmxheWVycy5yZW1vdmUobGF5ZXIuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwYW9zZSB0aGUgbWFwIGFuZCBhc3NvY2lhdGVkIHJlc291cmVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIERpc3Bvc2VNYXAoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAgPT0gbnVsbCAmJiB0aGlzLl9tYXBJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21hcEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLk1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgbWFwIGNlbnRlclxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGdvZSBsb2NhdGlvbiBvZiB0aGUgY2VudGVyLiBTZWUge0BsaW5rIElMYXRMb25nfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRDZW50ZXIoKTogUHJvbWlzZTxJTGF0TG9uZz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gPElMYXRMb25nPntcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogY2VudGVyLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogY2VudGVyLmxvbmdpdHVkZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXAgYm91bmRpbmcgYm94XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBib3VuZGluZyBib3guIFNlZSB7QGxpbmsgSUJveH0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0Qm91bmRzKCk6IFByb21pc2U8SUJveD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3ggPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gPElCb3g+e1xuICAgICAgICAgICAgICAgIG1heExhdGl0dWRlOiBib3guZ2V0Tm9ydGgoKSxcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IGJveC5jcm9zc2VzSW50ZXJuYXRpb25hbERhdGVMaW5lKCkgPyBib3guZ2V0V2VzdCgpIDogYm94LmdldEVhc3QoKSxcbiAgICAgICAgICAgICAgICBtaW5MYXRpdHVkZTogYm94LmdldFNvdXRoKCksXG4gICAgICAgICAgICAgICAgbWluTG9uZ2l0dWRlOiBib3guY3Jvc3Nlc0ludGVybmF0aW9uYWxEYXRlTGluZSgpID8gYm94LmdldEVhc3QoKSA6IGJveC5nZXRXZXN0KCksXG4gICAgICAgICAgICAgICAgY2VudGVyOiB7IGxhdGl0dWRlOiBib3guY2VudGVyLmxhdGl0dWRlLCBsb25naXR1ZGU6IGJveC5jZW50ZXIubG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHNoYXJlZCBvciBwcml2YXRlIGluc3RhbmNlIG9mIHRoZSBtYXAgZHJhd2luZyB0b29scy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbdXNlU2hhcmVkSW5zdGFuY2U9dHJ1ZV0gLSBTZXQgdG8gZmFsc2UgdG8gY3JlYXRlIGEgcHJpdmF0ZSBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zdCBhbiBpbnN0YW5jZSBvZiB0aGUgZHJhd2luZyB0b29scy5cbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0RHJhd2luZ1Rvb2xzICh1c2VTaGFyZWRJbnN0YW5jZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLkRyYXdpbmdUb29scz4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8TWljcm9zb2Z0Lk1hcHMuRHJhd2luZ1Rvb2xzPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLkxvYWRNb2R1bGVJbnN0YW5jZSgnTWljcm9zb2Z0Lk1hcHMuRHJhd2luZ1Rvb2xzJywgdXNlU2hhcmVkSW5zdGFuY2UpLnRoZW4oKG86IE1pY3Jvc29mdC5NYXBzLkRyYXdpbmdUb29scykgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgem9vbSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRab29tKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IG1hcC5nZXRab29tKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgbW9kdWxlIGludG8gdGhlIE1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2R1bGVOYW1lIC0gVGhlIG1vZHVsZSB0byBsb2FkLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIGNhbGwgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgTG9hZE1vZHVsZShtb2R1bGVOYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmICh0aGlzLl9tb2R1bGVzLmhhcyhtb2R1bGVOYW1lKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLmxvYWRNb2R1bGUobW9kdWxlTmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc2V0KG1vZHVsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgbW9kdWxlIGludG8gdGhlIE1hcCBhbmQgZGVsaXZlcnMgYW5kIGluc3RhbmNlIG9mIHRoZSBtb2R1bGUgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2R1bGVOYW1lIC0gVGhlIG1vZHVsZSB0byBsb2FkLlxuICAgICAqIEBwYXJhbSB1c2VTaGFyZWRJbnN0YW5jZS0gVXNlIGEgc2hhcmVkIGluc3RhbmNlIGlmIHRydWUsIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBpZiBmYWxzZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIExvYWRNb2R1bGVJbnN0YW5jZShtb2R1bGVOYW1lOiBzdHJpbmcsIHVzZVNoYXJlZEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8T2JqZWN0PiB7XG4gICAgICAgIGNvbnN0IHM6IHN0cmluZyA9IG1vZHVsZU5hbWUuc3Vic3RyKG1vZHVsZU5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICBpZiAodGhpcy5fbW9kdWxlcy5oYXMobW9kdWxlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBvOiBhbnkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCF1c2VTaGFyZWRJbnN0YW5jZSkgIHtcbiAgICAgICAgICAgICAgICBvID0gbmV3ICg8YW55Pk1pY3Jvc29mdC5NYXBzKVtzXSh0aGlzLl9tYXBJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9tb2R1bGVzLmdldChtb2R1bGVOYW1lKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbyA9IHRoaXMuX21vZHVsZXMuZ2V0KG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbyA9IG5ldyAoPGFueT5NaWNyb3NvZnQuTWFwcylbc10odGhpcy5fbWFwSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc2V0KG1vZHVsZU5hbWUsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxPYmplY3Q+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLmxvYWRNb2R1bGUobW9kdWxlTmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gbmV3ICg8YW55Pk1pY3Jvc29mdC5NYXBzKVtzXSh0aGlzLl9tYXBJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VTaGFyZWRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zZXQobW9kdWxlTmFtZSwgbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2R1bGVzLnNldChtb2R1bGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdDb3VsZCBub3QgbG9hZCBtb2R1bGUgb3IgY3JlYXRlIGluc3RhbmNlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG9mIGdlbyBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gdGhlIG1hcCBjb250cm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvYyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgdG8gdHJhbnNsYXRlLlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhbiB7QGxpbmsgSVBvaW50fSBpbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMuIFRoaXMgcHJvbWlzZSByZXNvbHZlcyB0byBudWxsXG4gICAgICogaWYgdGhlIGdvZSBjb29yZGluYXRlcyBhcmUgbm90IGluIHRoZSB2aWV3IHBvcnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KGxvYzogSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbDogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24obG9jKTtcbiAgICAgICAgICAgIGNvbnN0IHA6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID0gPE1pY3Jvc29mdC5NYXBzLlBvaW50Pm0udHJ5TG9jYXRpb25Ub1BpeGVsKGwsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xuICAgICAgICAgICAgaWYgKHAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHAueCwgeTogcC55IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG9mIGdlbyBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gdGhlIG1hcCBjb250cm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvYyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgdG8gdHJhbnNsYXRlLlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhbiB7QGxpbmsgSVBvaW50fSBpbnRlcmZhY2UgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgTG9jYXRpb25zVG9Qb2ludHMobG9jczogQXJyYXk8SUxhdExvbmc+KTogUHJvbWlzZTxBcnJheTxJUG9pbnQ+PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsID0gbG9jcy5tYXAobG9jID0+IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihsb2MpKTtcbiAgICAgICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlBvaW50PiA9IDxBcnJheTxNaWNyb3NvZnQuTWFwcy5Qb2ludD4+bS50cnlMb2NhdGlvblRvUGl4ZWwobCxcbiAgICAgICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5QaXhlbFJlZmVyZW5jZS5jb250cm9sKTtcbiAgICAgICAgICAgIHJldHVybiBwID8gcCA6IG5ldyBBcnJheTxJUG9pbnQ+KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgdGhlIG1hcCBvbiBhIGdlbyBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRMbmcgLSBHZW9Db29yZGluYXRlcyBhcm91bmQgd2hpY2ggdG8gY2VudGVyIHRoZSBtYXAuIFNlZSB7QGxpbmsgSUxhdExvbmd9XG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBjZW50ZXIgb3BlcmF0aW9ucyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4gbWFwLnNldFZpZXcoe1xuICAgICAgICAgICAgY2VudGVyOiBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24obGF0TG5nKVxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2VuZXJpYyBtYXAgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0TWFwT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXAudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JTWFwT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgbS5zZXRPcHRpb25zKG8pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aWV3IG9wdGlvbnMgb2YgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0Vmlld09wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVZpZXdPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVZpZXdPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgbS5zZXRWaWV3KG8pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gem9vbSAtIFpvb20gbGV2ZWwgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSB6b29tIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRab29tKHpvb206IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiBtYXAuc2V0Vmlldyh7XG4gICAgICAgICAgICB6b29tOiB6b29tXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IHN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoZS5nLiAnY2xpY2snKVxuICAgICAqIEByZXR1cm5zIC0gQW4gb2JzZXJ2YWJsZSBvZiB0cHllIEUgdGhhdCBmaXJlcyB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU3Vic2NyaWJlVG9NYXBFdmVudDxFPihldmVudE5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8RT4ge1xuICAgICAgICBjb25zdCBldmVudE5hbWVUcmFuc2xhdGVkID0gQmluZ01hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxFPikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG0sIGV2ZW50TmFtZVRyYW5zbGF0ZWQsIChlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIGdpdmVuIGV2ZW50IG5hbWUgb24gdGhlIG1hcCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBFdmVudCB0byB0cmlnZ2VyLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVHJpZ2dlck1hcEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobSkgPT4gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmludm9rZShtLCBldmVudE5hbWUsIG51bGwpKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbWFya2VyJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2xheWVyJztcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL21hcC1sYXllcic7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XG5cbi8qKlxuICogVGhpcyBhYnN0cmFjdCBwYXJ0aWFsbHkgaW1wbGVtZW50cyB0aGUgY29udHJhY3QgZm9yIHRoZSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfVxuICogYW5kIHtAbGluayBDbHVzdGVyU2VydmljZX0gZm9yIHRoZSBCaW5nIE1hcHMgVjggYXJjaHRpZWN0dXJlLiBJdCBzZXJ2ZXNcbiAqIGFzIHRoZSBiYXNlIGNsYXNzIGZvciBiYXNpYyBsYXllciAoe0BsaW5rIEJpbmdMYXllclNlcnZpY2V9KSBhbmQgY2x1c3RlciBsYXllciAoe0BsaW5rIEJpbmdDbHVzdGVyTGF5ZXJ9KS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAYWJzdHJhY3RcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJpbmdMYXllckJhc2Uge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuXG4gICAgcHJvdGVjdGVkIF9sYXllcnM6IE1hcDxudW1iZXIsIFByb21pc2U8TGF5ZXI+PiA9IG5ldyBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4oKTtcblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTGF5ZXJCYXNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgQmluZyBNYXBzIFY4LiBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIHByb3RlY3RlZCBfem9uZTogTmdab25lKSB7IH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxuICAgICAqIEdlbmVyYWxseSwgTWFwTGF5ZXJEaXJlY3RpdmUgd2lsbCBiZSBpbmplY3RlZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZVxuICAgICAqIExheWVyU2VydmljZSBhbmQgdGhlbiBzZWxmIHJlZ2lzdGVyIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXJrZXIgaW4gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIElkIG9mIHRoZSBsYXllciBpbiB3aGljaCB0byBjcmVhdGUgdGhlIG1hcmtlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTWFya2VyT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcmtlciBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgTWFya2VyfSBtb2RlbCBmb3IgdGhlIGNyZWF0ZWQgbWFya2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VyKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogUHJvbWlzZTxNYXJrZXI+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcsIGw6IExheWVyKTogQmluZ01hcmtlciA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2M6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG9wdGlvbnMucG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykgeyBvLmljb24gPSBpY29uOyB9XG4gICAgICAgICAgICBjb25zdCBwdXNocGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gbmV3IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4obG9jLCBvKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcjogQmluZ01hcmtlciA9IG5ldyBCaW5nTWFya2VyKHB1c2hwaW4sIG51bGwsIGwuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XG4gICAgICAgICAgICBtYXJrZXIuSXNMYXN0ID0gb3B0aW9ucy5pc0xhc3Q7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IG1hcmtlci5NZXRhZGF0YS5zZXQoaywgdikpOyB9XG4gICAgICAgICAgICBsLkFkZEVudGl0eShtYXJrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pY29uSW5mbyAmJiBvcHRpb25zLmljb25JbmZvLm1hcmtlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gTWFya2VyLkNyZWF0ZU1hcmtlcihvcHRpb25zLmljb25JbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHMpID09PSAnc3RyaW5nJykgeyByZXR1cm4ocGF5bG9hZChzLCBsKSk7IH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybihwYXlsb2FkKHguaWNvbiwgbCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBheWxvYWQobnVsbCwgbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgbWFya2Vycy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgbWFya2VycyB0byBiZSB1c2VkIGluIGJ1bGtcbiAgICAgKiBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBNYXJrZXIgb3B0aW9ucyBkZWZpbmluZyB0aGUgbWFya2Vycy5cbiAgICAgKiBAcGFyYW0gbWFya2VySWNvbiAtIE9wdGlvbmFsIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGN1c3RvbSBtYXJrZXJzLiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbWFya2Vycy5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBNYXJrZXIgbW9kZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcsIG9wOiBBcnJheTxJTWFya2VyT3B0aW9ucz4pOiBBcnJheTxCaW5nTWFya2VyPiA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxCaW5nTWFya2VyPiA9IG9wLm1hcChtbyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHM6IHN0cmluZztcbiAgICAgICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhtbyk7XG4gICAgICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycgKSB7IHMgPSBpY29uOyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoby5pY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBvLmljb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvLmljb24pIHsgZGVsZXRlIG8uaWNvbjsgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24obW8ucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IE1hcmtlci5HZXRJbWFnZUZvck1hcmtlcihzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW1nICE9IG51bGwpIHsgKDxhbnk+cHVzaHBpbikuaW1hZ2UgPSBpbWc7IH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcjogQmluZ01hcmtlciA9IG5ldyBCaW5nTWFya2VyKHB1c2hwaW4sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5Jc0ZpcnN0ID0gbW8uaXNGaXJzdDtcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNMYXN0ID0gbW8uaXNMYXN0O1xuICAgICAgICAgICAgICAgIGlmIChtby5tZXRhZGF0YSkgeyBtby5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBtYXJrZXIuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gbmV3IFByb21pc2U8QXJyYXk8TWFya2VyPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlckljb24gJiYgbWFya2VySWNvbi5tYXJrZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hcmtlci5DcmVhdGVNYXJrZXIobWFya2VySWNvbik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmVzb2x2ZShwYXlsb2FkKHMsIG9wdGlvbnMpKTsgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy50aGVuKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKHguaWNvbiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBheWxvYWQobnVsbCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3QgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBsYXllci5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJCYXNlXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZUxheWVyKGxheWVyOiBNYXBMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XG4gICAgICAgIGlmIChsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbC50aGVuKChsMTogTGF5ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbDEuRGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLmRlbGV0ZShsYXllci5JZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTGF5ZXIgbW9kZWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3Qgb3IgTGF5ZXIgSWQgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBsYXllciBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gcmVzb2x2ZWQgY29udGFpbnMgdGhlIExheWVyIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TmF0aXZlTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlfG51bWJlcik6IFByb21pc2U8TGF5ZXI+IHtcbiAgICAgICAgbGV0IHA6IFByb21pc2U8TGF5ZXI+ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZihsYXllcikgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldCgoPE1hcExheWVyRGlyZWN0aXZlPmxheWVyKS5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXllciBiYXNlZCBvbiBpdHMgaWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIGlkIC0gTGF5ZXIgSWQuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBMYXllcn0gbW9kZWwgZm9yIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJCYXNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIEdldExheWVyQnlJZChpZDogbnVtYmVyKTogUHJvbWlzZTxMYXllcj4ge1xuICAgICAgICBsZXQgcDogUHJvbWlzZTxMYXllcj47XG4gICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChsOiBQcm9taXNlPExheWVyPiwgazogbnVtYmVyKSA9PiB7IGlmIChrID09PSBpZCkgeyBwID0gbDsgfSB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xuaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbWFya2VyJztcbmltcG9ydCB7IEJpbmdQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1wb2x5Z29uJztcbmltcG9ydCB7IEJpbmdQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctcG9seWxpbmUnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xuaW1wb3J0IHsgTWFya2VyVHlwZUlkIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlci10eXBlLWlkJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ0xheWVyQmFzZSB9IGZyb20gJy4vYmluZy1sYXllci1iYXNlJztcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUge0BsaW5rIExheWVyU2VydmljZX0gY29udHJhY3QgZm9yIGEgIEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nTGF5ZXJTZXJ2aWNlIGV4dGVuZHMgQmluZ0xheWVyQmFzZSBpbXBsZW1lbnRzIExheWVyU2VydmljZSB7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ0xheWVyU2VydmljZS5cbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBJbnN0YW5jZSBvZiB0aGUgQmluZyBNYXBzIFNlcnZpY2UuIFdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBpbnN0YW5jZSB0byBwcm92aWRlIHpvbmUgYXdhcmUgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHN1cGVyKF9tYXBTZXJ2aWNlLCBfem9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxuICAgICAqIEdlbmVyYWxseSwgTWFwTGF5ZXJEaXJlY3RpdmUgd2lsbCBiZSBpbmplY3RlZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZVxuICAgICAqIExheWVyU2VydmljZSBhbmQgdGhlbiBzZWxmIHJlZ2lzdGVyIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxheWVyUHJvbWlzZSA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlTGF5ZXIoeyBpZDogbGF5ZXIuSWQgfSk7XG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIuSWQsIGxheWVyUHJvbWlzZSk7XG4gICAgICAgIGxheWVyUHJvbWlzZS50aGVuKGwgPT4gbC5TZXRWaXNpYmxlKGxheWVyLlZpc2libGUpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwb2x5Z29uIHRvIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29uLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWdvbiBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHRocm93IChuZXcgRXJyb3IoYExheWVyIHdpdGggaWQgJHtsYXllcn0gbm90IGZvdW5kIGluIExheWVyIE1hcGApKTsgfVxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jczogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGhzKTtcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBwb2x5OiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24obG9jcywgbyk7XG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uOiBQb2x5Z29uID0gbmV3IEJpbmdQb2x5Z29uKHBvbHksIDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBTZXJ2aWNlLCBsLk5hdGl2ZVByaW1pdHZlKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBwb2x5Z29uLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7cG9seWdvbi5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dMYWJlbCAhPSBudWxsKSB7IHBvbHlnb24uU2hvd0xhYmVsID0gb3B0aW9ucy5zaG93TGFiZWw7IH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcG9seWdvbi5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxhYmVsTWF4Wm9vbSAhPSBudWxsKSB7IHBvbHlnb24uTGFiZWxNYXhab29tID0gb3B0aW9ucy5sYWJlbE1heFpvb207IH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxhYmVsTWluWm9vbSAhPSBudWxsKSB7IHBvbHlnb24uTGFiZWxNaW5ab29tID0gb3B0aW9ucy5sYWJlbE1pblpvb207IH1cbiAgICAgICAgICAgIGwuQWRkRW50aXR5KHBvbHlnb24pO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5Z29uIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHRocm93IChuZXcgRXJyb3IoYExheWVyIHdpdGggaWQgJHtsYXllcn0gbm90IGZvdW5kIGluIExheWVyIE1hcGApKTsgfVxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9seWdvbnM6IFByb21pc2U8QXJyYXk8UG9seWdvbj4+ID0gbmV3IFByb21pc2U8QXJyYXk8UG9seWdvbj4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5czogQXJyYXk8QmluZ1BvbHlnb24+ID0gb3B0aW9ucy5tYXAobyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRocyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5OiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24obG9jcywgb3ApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5Z29uOiBCaW5nUG9seWdvbiA9IG5ldyBCaW5nUG9seWdvbihwb2x5LCA8QmluZ01hcFNlcnZpY2U+dGhpcy5fbWFwU2VydmljZSwgbC5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7IHBvbHlnb24uVGl0bGUgPSBvLnRpdGxlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcG9seWdvbi5NZXRhZGF0YS5zZXQoaywgdikpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocG9seXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbGluZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIGxpbmUuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5bGluZSAob3IgYW4gYXJyYXlcbiAgICAgKiBvZiBwb2x5Z29ucyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZShsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+IHtcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XG4gICAgICAgIGxldCBwb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmU7XG4gICAgICAgIGxldCBsaW5lOiBQb2x5bGluZTtcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cbiAgICAgICAgcmV0dXJuIHAudGhlbigobDogTGF5ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMob3B0aW9ucy5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhbMF0pKSB7XG4gICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUobG9jc1swXSwgbyk7XG4gICAgICAgICAgICAgICAgbGluZSA9IG5ldyBCaW5nUG9seWxpbmUocG9seWxpbmUsIHRoaXMuX21hcFNlcnZpY2UuTWFwSW5zdGFuY2UsIGwuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KGxpbmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykge2xpbmUuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBsaW5lLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcbiAgICAgICAgICAgICAgICBsb2NzLmZvckVhY2goeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKHgsIG8pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbmV3IEJpbmdQb2x5bGluZShwb2x5bGluZSwgdGhpcy5fbWFwU2VydmljZS5NYXBJbnN0YW5jZSwgbC5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KGxpbmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gbGluZS5NZXRhZGF0YS5zZXQoaywgdikpOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7bGluZS5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBsaW5lLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlsaW5lIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lcyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4ge1xuICAgICAgICBjb25zdCBwOiBQcm9taXNlPExheWVyPiA9IHRoaXMuR2V0TGF5ZXJCeUlkKGxheWVyKTtcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cbiAgICAgICAgcmV0dXJuIHAudGhlbigobDogTGF5ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvbHlsaW5lczogUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PiA9IG5ldyBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5czogQXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IG9wdGlvbnMubWFwKG8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG8ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3MgJiYgbG9jcy5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KGxvY3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5OiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZShsb2NzWzBdLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogQmluZ1BvbHlsaW5lID0gbmV3IEJpbmdQb2x5bGluZShwb2x5LCB0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlLCBsLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7IHBvbHlsaW5lLlRpdGxlID0gby50aXRsZTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ubWV0YWRhdGEpIHsgby5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBwb2x5bGluZS5NZXRhZGF0YS5zZXQoaywgdikpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lczogQXJyYXk8UG9seWxpbmU+ID0gbmV3IEFycmF5PFBvbHlsaW5lPigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jcy5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUoeCwgb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlsaW5lOiBCaW5nUG9seWxpbmUgPSBuZXcgQmluZ1BvbHlsaW5lKHBvbHksIHRoaXMuX21hcFNlcnZpY2UuTWFwSW5zdGFuY2UsIGwuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcG9seWxpbmUuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7cG9seWxpbmUuVGl0bGUgPSBvLnRpdGxlOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChwb2x5bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocG9seXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcG9seWxpbmVzO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xuaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbWFya2VyJztcbmltcG9ydCB7IEJpbmdDbHVzdGVyTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNsdXN0ZXItbGF5ZXInO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xuaW1wb3J0IHsgTWFya2VyVHlwZUlkIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlci10eXBlLWlkJztcbmltcG9ydCB7IENsdXN0ZXJDbGlja0FjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbic7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2x1c3RlckxheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jbHVzdGVyLWxheWVyJztcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdMYXllckJhc2UgfSBmcm9tICcuL2JpbmctbGF5ZXItYmFzZSc7XG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuL2JpbmctY29udmVyc2lvbnMnO1xuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBDbHVzdGVyU2VydmljZX0gY29udHJhY3QgZm9yIGEgIEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nQ2x1c3RlclNlcnZpY2UgZXh0ZW5kcyBCaW5nTGF5ZXJCYXNlIGltcGxlbWVudHMgQ2x1c3RlclNlcnZpY2Uge1xuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdDbHVzdGVyU2VydmljZS5cbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBDb25jcmV0ZSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIEJpbmcgTWFwcyBWOC4gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHN1cGVyKF9tYXBTZXJ2aWNlLCBfem9uZSk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxuICAgICAqIEdlbmVyYWxseSwgTWFwTGF5ZXIgd2lsbCBiZSBpbmplY3RlZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZVxuICAgICAqIExheWVyU2VydmljZSBhbmQgdGhlbiBzZWxmIHJlZ2lzdGVyIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiBsYXllci5JZCxcbiAgICAgICAgICAgIHZpc2libGU6IGxheWVyLlZpc2libGUsXG4gICAgICAgICAgICBjbHVzdGVyaW5nRW5hYmxlZDogbGF5ZXIuQ2x1c3RlcmluZ0VuYWJsZWQsXG4gICAgICAgICAgICBwbGFjZW1lbnRNb2RlOiBsYXllci5DbHVzdGVyUGxhY2VtZW50TW9kZVxuICAgICAgICB9O1xuICAgICAgICBpZiAobGF5ZXIuR3JpZFNpemUpIHsgb3B0aW9ucy5ncmlkU2l6ZSA9IGxheWVyLkdyaWRTaXplOyB9XG4gICAgICAgIGlmIChsYXllci5MYXllck9mZnNldCkgeyBvcHRpb25zLmxheWVyT2Zmc2V0ID0gbGF5ZXIuTGF5ZXJPZmZzZXQ7IH1cbiAgICAgICAgaWYgKGxheWVyLlpJbmRleCkgeyBvcHRpb25zLnpJbmRleCA9IGxheWVyLlpJbmRleDsgfVxuICAgICAgICBpZiAobGF5ZXIuSWNvbkluZm8pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2x1c3RlcmVkUGluQ2FsbGJhY2sgPSAocGluOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbikgPT4geyB0aGlzLkNyZWF0ZUNsdXN0ZXJQdXNoUGluKHBpbiwgbGF5ZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci5DdXN0b21NYXJrZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgb3B0aW9ucy5jbHVzdGVyZWRQaW5DYWxsYmFjayA9IChwaW46IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluKSA9PiB7IHRoaXMuQ3JlYXRlQ3VzdG9tQ2x1c3RlclB1c2hQaW4ocGluLCBsYXllcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyLlNwaWRlckNsdXN0ZXJPcHRpb25zKSB7IG9wdGlvbnMuc3BpZGVyQ2x1c3Rlck9wdGlvbnMgPSBsYXllci5TcGlkZXJDbHVzdGVyT3B0aW9uczsgfVxuXG4gICAgICAgIGNvbnN0IGxheWVyUHJvbWlzZTogUHJvbWlzZTxMYXllcj4gPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNsdXN0ZXJMYXllcihvcHRpb25zKTtcbiAgICAgICAgKDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBTZXJ2aWNlKS5NYXBQcm9taXNlLnRoZW4obSA9PiB7XG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihtLCAndmlld2NoYW5nZWVuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJpbmdFbmFibGVkICYmIG0uZ2V0Wm9vbSgpID09PSAxOSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllclByb21pc2UudGhlbigobDogQmluZ0NsdXN0ZXJMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbC5TZXRPcHRpb25zKHsgaWQ6IGxheWVyLklkLCBjbHVzdGVyaW5nRW5hYmxlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuQ2x1c3RlcmluZ0VuYWJsZWQgJiYgbS5nZXRab29tKCkgPCAxOSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllclByb21pc2UudGhlbigobDogQmluZ0NsdXN0ZXJMYXllcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsLkdldE9wdGlvbnMoKS5jbHVzdGVyaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwuU2V0T3B0aW9ucyh7IGlkOiBsYXllci5JZCwgY2x1c3RlcmluZ0VuYWJsZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNldChsYXllci5JZCwgbGF5ZXJQcm9taXNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWdvbi5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlnb24gbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlnb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5Z29uIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvbnMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlnb25PcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWdvbj4+IHtcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBvbHlsaW5lIHRvIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBsaW5lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgbGluZS5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhbiBhcnJheVxuICAgICAqIG9mIHBvbHlnb25zIGZvciBjb21wbGV4IHBhdGhzKSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmUobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiB7XG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjbHVzdGVyaW5nIGxheWVycy4gWW91IGNhbiBvbmx5IHVzZSBtYXJrZXJzLicpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWxpbmVzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBwb2x5bGluZXMgdG8gYmUgdXNlZCBpbiBidWxrXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5bGluZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5bGluZSBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5bGluZXMuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWxpbmUgbW9kZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZXMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+IHtcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcbiAgICAgKiBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXG4gICAgICogQXMgc3VjaCwgU3RvcENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgYWRkaW5nIG1hbnkgZW50aXRpZXMgYW5kIFN0YXJ0Q2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIG9uY2UgYWRkaW5nIGlzXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVyIC0gQ2x1c3RlckxheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3QgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU3RhcnRDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIuSWQpO1xuICAgICAgICBpZiAobCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGwudGhlbigobDE6IEJpbmdDbHVzdGVyTGF5ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbDEuU3RhcnRDbHVzdGVyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcbiAgICAgKiBjb21wbGV0ZSB0byByZWNhbGN1bGF0ZSB0aGUgY2x1c3RlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBTdG9wQ2x1c3RlcmluZyhsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLl9sYXllcnMuZ2V0KGxheWVyLklkKTtcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGwxLlN0b3BDbHVzdGVyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBjbHVzdGVyIHB1c2hwaW4gYXMgYSBjYWxsYmFjayBmcm9tIEJpbmdNYXBzIHdoZW4gY2x1c3RlcmluZyBvY2N1cnMuIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBtb2RlbFxuICAgICAqIGNhbiBwcm92aWRlIGFuIEljb25JbmZvIHByb3BlcnR5IHRoYXQgd291bGQgZ292ZXJuIHRoZSBhcHBhcmVuYWNlIG9mIHRoZSBwaW4uIFRoaXMgbWV0aG9kIHdpbGwgYXNzaWduIHRoZSBzYW1lIHBpbiB0byBhbGxcbiAgICAgKiBjbHVzdGVycyBpbiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2x1c3RlciAtIFRoZSBjbHVzdGVyIGZvciB3aGljaCB0byBjcmVhdGUgdGhlIHB1c2hwaW4uXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIHtAbGluayBDbHVzdGVyTGF5ZXJEaXJlY3RpdmV9IGNvbXBvbmVudCByZXByZXNlbnRpbmcgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHByaXZhdGUgQ3JlYXRlQ2x1c3RlclB1c2hQaW4oY2x1c3RlcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4sIGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCkudGhlbigobDogQmluZ0NsdXN0ZXJMYXllcikgPT4ge1xuICAgICAgICAgICAgaWYgKGxheWVyLkljb25JbmZvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZDogKGljbzogc3RyaW5nLCBpbmZvOiBJTWFya2VySWNvbkluZm8pID0+IHZvaWQgPSAoaWNvLCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmljb24gPSBpY287XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmFuY2hvciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5mby5zaXplICYmIGluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKGluZm8uc2l6ZS53aWR0aCAqIGluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueCkgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmZvLnNpemUgJiYgaW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaW5mby5zaXplLmhlaWdodCAqIGluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueSkgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5zZXRPcHRpb25zKG8pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbjogc3RyaW5nfFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+ID0gTWFya2VyLkNyZWF0ZU1hcmtlcihsYXllci5JY29uSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihpY29uKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZChpY29uLCBsYXllci5JY29uSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpY29uLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkKHguaWNvbiwgeC5pY29uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXllci5DbHVzdGVyQ2xpY2tBY3Rpb24gPT09IENsdXN0ZXJDbGlja0FjdGlvbi5ab29tSW50b0NsdXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihjbHVzdGVyLCAnY2xpY2snLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB0aGlzLlpvb21JbnRvQ2x1c3RlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGF5ZXIuQ2x1c3RlckNsaWNrQWN0aW9uID09PSBDbHVzdGVyQ2xpY2tBY3Rpb24uU3BpZGVyKSB7XG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoY2x1c3RlciwgJ2RibGNsaWNrJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4gdGhpcy5ab29tSW50b0NsdXN0ZXIoZSkpO1xuICAgICAgICAgICAgICAgIGwuSW5pdGlhbGl6ZVNwaWRlckNsdXN0ZXJTdXBwb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgaG9vayBmb3IgY29uc3VtZXJzIHRvIHByb3ZpZGUgYSBjdXN0b20gZnVuY3Rpb24gdG8gY3JlYXRlIGNsdXN0ZXIgYmlucyBmb3IgYSBjbHVzdGVyLiBUaGlzIGlzIHBhcnRpY3VhcmlseSB1c2VmdWxcbiAgICAgKiBpbiBzaXR1YXRpb24gd2hlcmUgdGhlIHBpbiBzaG91bGQgZGlmZmVyIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGlucyBpbiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbHVzdGVyIC0gVGhlIGNsdXN0ZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcHVzaHBpbi5cbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUge0BsaW5rIENsdXN0ZXJMYXllckRpcmVjdGl2ZX0gY29tcG9uZW50XG4gICAgICogcmVwcmVzZW50aW5nIHRoZSBsYXllci4gU2V0IHRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlLkN1c3RvbU1hcmtlckNhbGxiYWNrfVxuICAgICAqIHByb3BlcnR5IHRvIGRlZmluZSB0aGUgY2FsbGJhY2sgZ2VuZXJhdGluZyB0aGUgcGluLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHByaXZhdGUgQ3JlYXRlQ3VzdG9tQ2x1c3RlclB1c2hQaW4oY2x1c3RlcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4sIGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCkudGhlbigobDogQmluZ0NsdXN0ZXJMYXllcikgPT4ge1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgbWFya2VycyBmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IG06IEFycmF5PE1hcmtlcj4gPSBuZXcgQXJyYXk8TWFya2VyPigpO1xuICAgICAgICAgICAgY2x1c3Rlci5jb250YWluZWRQdXNocGlucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcjogTWFya2VyID0gbC5HZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyKSB7IG0ucHVzaChtYXJrZXIpOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGljb25JbmZvOiBJTWFya2VySWNvbkluZm8gPSB7IG1hcmtlclR5cGU6IE1hcmtlclR5cGVJZC5Ob25lIH07XG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIG8uaWNvbiA9IGxheWVyLkN1c3RvbU1hcmtlckNhbGxiYWNrKG0sIGljb25JbmZvKTtcbiAgICAgICAgICAgIGlmIChvLmljb24gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgby5hbmNob3IgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIChpY29uSW5mby5zaXplICYmIGljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvKSA/IChpY29uSW5mby5zaXplLndpZHRoICogaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueCkgOiAwLFxuICAgICAgICAgICAgICAgICAgICAoaWNvbkluZm8uc2l6ZSAmJiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaWNvbkluZm8uc2l6ZS5oZWlnaHQgKiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby55KSA6IDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChpY29uSW5mby50ZXh0T2Zmc2V0KSB7IG8udGV4dE9mZnNldCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChpY29uSW5mby50ZXh0T2Zmc2V0LngsIGljb25JbmZvLnRleHRPZmZzZXQueSk7IH1cbiAgICAgICAgICAgICAgICBjbHVzdGVyLnNldE9wdGlvbnMobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGF5ZXIuQ2x1c3RlckNsaWNrQWN0aW9uID09PSBDbHVzdGVyQ2xpY2tBY3Rpb24uWm9vbUludG9DbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoY2x1c3RlciwgJ2NsaWNrJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4gdGhpcy5ab29tSW50b0NsdXN0ZXIoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlNwaWRlcikge1xuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKGNsdXN0ZXIsICdkYmxjbGljaycsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHRoaXMuWm9vbUludG9DbHVzdGVyKGUpKTtcbiAgICAgICAgICAgICAgICBsLkluaXRpYWxpemVTcGlkZXJDbHVzdGVyU3VwcG9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tcyBpbnRvIHRoZSBjbHVzdGVyIG9uIGNsaWNrIHNvIHRoYXQgdGhlIG1lbWJlcnMgb2YgdGhlIGNsdXN0ZXIgY29tZm9ydGFibGUgZml0IGludG8gdGhlIHpvbW1lZCBhcmVhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBFdmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIFpvb21JbnRvQ2x1c3RlcihlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcGluOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbiA9IDxNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbj5lLnRhcmdldDtcbiAgICAgICAgaWYgKHBpbiAmJiBwaW4uY29udGFpbmVkUHVzaHBpbnMpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHM6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uUmVjdDtcbiAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcbiAgICAgICAgICAgIHBpbi5jb250YWluZWRQdXNocGlucy5mb3JFYWNoKHAgPT4gbG9jcy5wdXNoKHAuZ2V0TG9jYXRpb24oKSkpO1xuICAgICAgICAgICAgYm91bmRzID0gTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb25SZWN0LmZyb21Mb2NhdGlvbnMobG9jcyk7XG5cbiAgICAgICAgICAgIC8vIFpvb20gaW50byB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBjbHVzdGVyLlxuICAgICAgICAgICAgLy8gQWRkIGEgcGFkZGluZyB0byBjb21wZW5zYXRlIGZvciB0aGUgcGl4ZWwgYXJlYSBvZiB0aGUgcHVzaHBpbnMuXG4gICAgICAgICAgICAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcFNlcnZpY2UpLk1hcFByb21pc2UudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XG4gICAgICAgICAgICAgICAgbS5zZXRWaWV3KHsgYm91bmRzOiBib3VuZHMsIHBhZGRpbmc6IDc1IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcbmltcG9ydCB7IE1hcFBvbHlnb25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL21hcC1wb2x5Z29uJztcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcblxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9seWdvbiBTZXJ2aWNlIGFic3RyYWN0IGNsYXNzIGZvciBCaW5nIE1hcHMgVjguXG4gKlxuICogQGV4cG9ydFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQmluZ1BvbHlnb25TZXJ2aWNlIGltcGxlbWVudHMgUG9seWdvblNlcnZpY2Uge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX3BvbHlnb25zOiBNYXA8TWFwUG9seWdvbkRpcmVjdGl2ZSwgUHJvbWlzZTxQb2x5Z29uPj4gPSBuZXcgTWFwPE1hcFBvbHlnb25EaXJlY3RpdmUsIFByb21pc2U8UG9seWdvbj4+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ1BvbHlnb25TZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS4gVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0gaW5zdGFuY2UuXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gc3VwcG9ydCB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5Z29uIGNvbnRleHQsIHRoZSBwb2x5Z29uIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxuICAgICAqIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbzogSVBvbHlnb25PcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IHBvbHlnb24uSWQsXG4gICAgICAgICAgICBjbGlja2FibGU6IHBvbHlnb24uQ2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwb2x5Z29uLkRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwb2x5Z29uLkVkaXRhYmxlLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBwb2x5Z29uLkZpbGxDb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBwb2x5Z29uLkZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBvbHlnb24uR2VvZGVzaWMsXG4gICAgICAgICAgICBsYWJlbE1heFpvb206IHBvbHlnb24uTGFiZWxNYXhab29tLFxuICAgICAgICAgICAgbGFiZWxNaW5ab29tOiBwb2x5Z29uLkxhYmVsTWluWm9vbSxcbiAgICAgICAgICAgIHBhdGhzOiBwb2x5Z29uLlBhdGhzLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBwb2x5Z29uLlNob3dMYWJlbCxcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBwb2x5Z29uLlNob3dUb29sdGlwLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHBvbHlnb24uU3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBwb2x5Z29uLlN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IHBvbHlnb24uU3Ryb2tlV2VpZ2h0LFxuICAgICAgICAgICAgdGl0bGU6IHBvbHlnb24uVGl0bGUsXG4gICAgICAgICAgICB2aXNpYmxlOiBwb2x5Z29uLlZpc2libGUsXG4gICAgICAgICAgICB6SW5kZXg6IHBvbHlnb24uekluZGV4LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9seWdvblByb21pc2U6IFByb21pc2U8UG9seWdvbj47XG4gICAgICAgIGlmIChwb2x5Z29uLkluQ3VzdG9tTGF5ZXIpIHtcbiAgICAgICAgICAgIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZVBvbHlnb24ocG9seWdvbi5MYXllcklkLCBvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVQb2x5Z29uKG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbHlnb25zLnNldChwb2x5Z29uLCBwb2x5Z29uUHJvbWlzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBwb2x5Z29uLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXG4gICAgICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxuICAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAgKlxuICAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXG4gICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgY29uc3QgYjogU3ViamVjdDxUPiA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncmlnaHRjbGljaycpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXG4gICAgICAgIC8vL1xuXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbikudGhlbigocDogUG9seWdvbikgPT4ge1xuICAgICAgICAgICAgICAgIHAuQWRkTGlzdGVuZXIoZXZlbnROYW1lLCAoZTogVCkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBEZWxldGVzIGEgcG9seWdvbi5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cbiAgICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICAqXG4gICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcbiAgICAgICovXG4gICAgcHVibGljIERlbGV0ZVBvbHlnb24ocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsLkRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zLmRlbGV0ZShwb2x5Z29uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgcG9seWdvbiBvbiB0aGUgY2xpY2sgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LiBFeHBlY3RlZCB0byBpbXBsZW1lbnQge0BsaW5rIE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJnc30uXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZyB7XG4gICAgICAgIGNvbnN0IHg6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyA9IDxNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3M+ZTtcbiAgICAgICAgcmV0dXJuIHsgbGF0aXR1ZGU6IHgubG9jYXRpb24ubGF0aXR1ZGUsIGxvbmdpdHVkZTogeC5sb2NhdGlvbi5sb25naXR1ZGUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBwb2x5Z29uIG1vZGVsIGZvciB0aGUgcG9seWdvbiBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIHBvbHlnb24gbW9kZWwuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5Z29ufSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TmF0aXZlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5Z29uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb2x5Z29uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElQb2x5Z29uT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFNldE9wdGlvbnMocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbikudGhlbigobDogUG9seWdvbikgPT4geyBsLlNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIFBvbHlnb24gcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVXBkYXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbik7XG4gICAgICAgIGlmIChtID09IG51bGwgfHwgcG9seWdvbi5QYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHMpIHx8IHBvbHlnb24uUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4gIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgbC5TZXRQYXRocyhwb2x5Z29uLlBhdGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGwuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+PnBvbHlnb24uUGF0aHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XG5pbXBvcnQgeyBNYXBQb2x5bGluZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lJztcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3BvbHlsaW5lLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBQb2x5bGluZSBTZXJ2aWNlIGFic3RyYWN0IGNsYXNzIGZvciBCaW5nIE1hcHMgVjguXG4gKlxuICogQGV4cG9ydFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQmluZ1BvbHlsaW5lU2VydmljZSBpbXBsZW1lbnRzIFBvbHlsaW5lU2VydmljZSB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfcG9seWxpbmVzOiBNYXA8TWFwUG9seWxpbmVEaXJlY3RpdmUsIFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4gPVxuICAgIG5ldyBNYXA8TWFwUG9seWxpbmVEaXJlY3RpdmUsIFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4oKTtcblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nUG9seWxpbmVTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS4gVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEJpbmdMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBpbnN0YW5jZSB0byBzdXBwb3J0IHpvbmUgYXdhcmUgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1lbWJlcnMgYW5kIE1hcmtlclNlcnZpY2UgaW1wbGVtZW50YXRpb25cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5bGluZSBjb250ZXh0LCB0aGUgcG9seWxpbmUgd2lsbCBlaXRoZXIgYnkgYWRkZWQgdG8gdGhlIG1hcCBvciBhXG4gICAgICogY29ycmVzcG9uZGluZyBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIFRoZSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG86IElQb2x5bGluZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpZDogcG9seWxpbmUuSWQsXG4gICAgICAgICAgICBjbGlja2FibGU6IHBvbHlsaW5lLkNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogcG9seWxpbmUuRHJhZ2dhYmxlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHBvbHlsaW5lLkVkaXRhYmxlLFxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBvbHlsaW5lLkdlb2Rlc2ljLFxuICAgICAgICAgICAgcGF0aDogcG9seWxpbmUuUGF0aCxcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBwb2x5bGluZS5TaG93VG9vbHRpcCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBwb2x5bGluZS5TdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBvbHlsaW5lLlN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IHBvbHlsaW5lLlN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHRpdGxlOiBwb2x5bGluZS5UaXRsZSxcbiAgICAgICAgICAgIHZpc2libGU6IHBvbHlsaW5lLlZpc2libGUsXG4gICAgICAgICAgICB6SW5kZXg6IHBvbHlsaW5lLnpJbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvbHlsaW5lUHJvbWlzZTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xuICAgICAgICBpZiAocG9seWxpbmUuSW5DdXN0b21MYXllcikge1xuICAgICAgICAgICAgcG9seWxpbmVQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZVBvbHlsaW5lKHBvbHlsaW5lLkxheWVySWQsIG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9seWxpbmVQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVQb2x5bGluZShvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb2x5bGluZXMuc2V0KHBvbHlsaW5lLCBwb2x5bGluZVByb21pc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbGluZS5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxuICAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSBUaGUge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxuICAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAgKlxuICAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxuICAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgY29uc3QgYjogU3ViamVjdDxUPiA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncmlnaHRjbGljaycpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXG4gICAgICAgIC8vL1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSkudGhlbihwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBBcnJheTxQb2x5bGluZT4gPSBBcnJheS5pc0FycmF5KHApID8gcCA6IFtwXTtcbiAgICAgICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiBsaW5lLkFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGU6IFQpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIERlbGV0ZXMgYSBwb2x5bGluZS5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSBkZWxldGVkLlxuICAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICAqXG4gICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXG4gICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWxpbmUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGxpbmUgPT4gIGxpbmUuRGVsZXRlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5kZWxldGUocG9seWxpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IElMYXRMb25nIHtcbiAgICAgICAgaWYgKCFlKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIGlmICghZS5sb2NhdGlvbikgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sb2NhdGlvbi5sYXRpdHVkZSwgbG9uZ2l0dWRlOiBlLmxvY2F0aW9uLmxvbmdpdHVkZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBtb2RlbCBmb3IgdGhlIG1hcmtlciBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5bGluZX1cbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS4gRm9yIGNvbXBsZXggcGF0aHMsIHJldHVybnMgYW4gYXJyYXkgb2YgcG9seWxpbmVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TmF0aXZlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9seWxpbmUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJUG9seWxpbmVPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqIG9wdGlvbnMgYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5bGluZSBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSkudGhlbihsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xuICAgICAgICAgICAgeC5mb3JFYWNoKGxpbmUgPT4gbGluZS5TZXRPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgUG9seWxpbmUgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZVBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGwgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID1cbiAgICAgICAgICAgICAgICBwb2x5bGluZS5QYXRoLmxlbmd0aCA+IDAgJiYgQXJyYXkuaXNBcnJheShwb2x5bGluZS5QYXRoWzBdKSA/IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBvbHlsaW5lLlBhdGggOlxuICAgICAgICAgICAgICAgIDxBcnJheTxBcnJheTxJTGF0TG9uZz4+Pltwb2x5bGluZS5QYXRoXTtcbiAgICAgICAgICAgICB4LmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IGluZGV4KSB7IGxpbmUuU2V0UGF0aChwW2luZGV4XSk7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobCkgJiYgbC5sZW5ndGggPiBwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGwuc3BsaWNlKHAubGVuZ3RoIC0gMSkuZm9yRWFjaChsaW5lID0+IGxpbmUuRGVsZXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4uL21hcHNlcnZpY2VmYWN0b3J5JztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBBUElMb2FkZXIsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYgfSBmcm9tICcuLi9tYXBhcGlsb2FkZXInO1xuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcbmltcG9ydCB7IEluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi4vaW5mb2JveC5zZXJ2aWNlJztcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9jbHVzdGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuLi9wb2x5Z29uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWxpbmUuc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nTWFwQVBJTG9hZGVyLCBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9iaW5nLW1hcC5hcGktbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ0luZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLWluZm9ib3guc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nTWFya2VyU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXJrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLWxheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ0NsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLWNsdXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL2JpbmctcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL2JpbmctcG9seWxpbmUuc2VydmljZSc7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIGZhY3RvcnkgdG8gY3JlYXRlIHRocmUgbmVjZXNzYXJ5IEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBzZXJ2aWNlIGluc3RhbmNlcy5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5nTWFwU2VydmljZUZhY3RvcnkgaW1wbGVtZW50cyBNYXBTZXJ2aWNlRmFjdG9yeSB7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5LlxuICAgICAqIEBwYXJhbSBfbG9hZGVyIC0ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBCaW5nIE1hcCBWOCBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgb2JqZWN0IHRvIGltcGxlbWVudCB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvYWRlcjogTWFwQVBJTG9hZGVyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzIGFuZCBNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1hcCBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGUoKTogTWFwU2VydmljZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZ01hcFNlcnZpY2UodGhpcy5fbG9hZGVyLCB0aGlzLl96b25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjbHVzdGVyIHNlcnZpY2UgZm9yIHRoZSBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBDbHVzdGVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0NsdXN0ZXJTZXJ2aWNlfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZUZhY3RvcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlclNlcnZpY2UoX21hcFNlcnZpY2U6IEJpbmdNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmdDbHVzdGVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGggaW5mbyBib3ggc2VydmljZSBmb3IgdGhlIEJpbmcgTWFwcyBWOCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBCaW5nSW5mb0JveFNlcnZpY2V9LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVJbmZvQm94U2VydmljZShfbWFwU2VydmljZTogQmluZ01hcFNlcnZpY2UpOiBJbmZvQm94U2VydmljZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZ0luZm9Cb3hTZXJ2aWNlKF9tYXBTZXJ2aWNlLCB0aGlzLl96b25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBsYXllciBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBCaW5nTWFwU2VydmljZX0uXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBCaW5nTGF5ZXJTZXJ2aWNlfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZUZhY3RvcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlTGF5ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlOiBCaW5nTWFwU2VydmljZSk6IExheWVyU2VydmljZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZ0xheWVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbWFya2VyIHNlcnZpY2UgZm9yIHRoZSBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0uXG4gICAgICogQHBhcmFtIGNsdXN0ZXJzICAtIHtAbGluayBDbHVzdGVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0NsdXN0ZXJTZXJ2aWNlfS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBNYXJrZXJTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBCaW5nTWFya2VyU2VydmljZX0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZU1hcmtlclNlcnZpY2UoX21hcFNlcnZpY2U6IEJpbmdNYXBTZXJ2aWNlLFxuICAgICAgICBfbGF5ZXJTZXJ2aWNlOiBCaW5nTGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2U6IEJpbmdDbHVzdGVyU2VydmljZSk6IE1hcmtlclNlcnZpY2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmdNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCBfbGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2UsIHRoaXMuX3pvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlnb24gc2VydmljZSBmb3IgdGhlIEJpbmcgTWFwcyBWOCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWdvblNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25TZXJ2aWNlKG1hcDogTWFwU2VydmljZSwgbGF5ZXJzOiBMYXllclNlcnZpY2UpOiBQb2x5Z29uU2VydmljZSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZ1BvbHlnb25TZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwb2x5bGluZSBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBQb2x5bGluZVNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lU2VydmljZShtYXA6IE1hcFNlcnZpY2UsIGxheWVyczogTGF5ZXJTZXJ2aWNlKTogUG9seWxpbmVTZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nUG9seWxpbmVTZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcGxhZm9ybSBzcGVjaWZpYyBNYXBTZXJ2aWNlRmFjdG9yeS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0gYXBpTG9hZGVyIC0gQW4ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuIFRoaXMgaXMgZXhwZWN0ZWQgdG8gdGhlIGEge0BsaW5rIEJpbmdNYXBBUElMb2FkZXJ9LlxuICogQHBhcmFtIHpvbmUgLSBBbiBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxuICpcbiAqIEByZXR1cm5zIC0gIEEge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkoYXBpTG9hZGVyOiBNYXBBUElMb2FkZXIsIHpvbmU6IE5nWm9uZSk6IE1hcFNlcnZpY2VGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IEJpbmdNYXBTZXJ2aWNlRmFjdG9yeShhcGlMb2FkZXIsIHpvbmUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBwbGFmb3JtIHNwZWNpZmljIE1hcExvYWRlckZhY3RvcnkuXG4gKlxuICogQGV4cG9ydFxuICogQHJldHVybnMgLSBBIHtAbGluayBNYXBBUElMb2FkZXJ9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQmluZ01hcExvYWRlckZhY3RvcnkoKTogTWFwQVBJTG9hZGVyIHtcbiAgICByZXR1cm4gbmV3IEJpbmdNYXBBUElMb2FkZXIobmV3IEJpbmdNYXBBUElMb2FkZXJDb25maWcoKSwgbmV3IFdpbmRvd1JlZigpLCBuZXcgRG9jdW1lbnRSZWYoKSk7XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2xheWVyJztcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL21hcC1sYXllcic7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZU1hcFNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4vZ29vZ2xlLWNvbnZlcnNpb25zJztcbmltcG9ydCB7IEdvb2dsZU1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLW1hcmtlcic7XG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xuXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcblxuLyoqXG4gKiBUaGlzIGFic3RyYWN0IHBhcnRpYWxseSBpbXBsZW1lbnRzIHRoZSBjb250cmFjdCBmb3IgdGhlIHtAbGluayBMYXllclNlcnZpY2V9XG4gKiBhbmQge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBmb3IgdGhlIEdvb2dsZSBNYXBzIGFyY2h0aWVjdHVyZS4gSXQgc2VydmVzXG4gKiBhcyB0aGUgYmFzZSBjbGFzcyBmb3IgYmFzaWMgbGF5ZXIgKHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9KSBhbmQgY2x1c3RlciBsYXllciAoe0BsaW5rIEdvb2dsZUNsdXN0ZXJMYXllcn0pLlxuICpcbiAqIEBleHBvcnRcbiAqIEBhYnN0cmFjdFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR29vZ2xlTGF5ZXJCYXNlIHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2xheWVyczogTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+O1xuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZUxheWVyQmFzZS5cbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBDb25jcmV0ZSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIEdvb2dsZSBNYXBzLlxuICAgICAqIEFuIGluc3RhbmNlIG9mIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfS5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyQmFzZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfbWFwU2VydmljZTogTWFwU2VydmljZSwgcHJvdGVjdGVkIF96b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3QuXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXG4gICAgICogTGF5ZXJTZXJ2aWNlIGFuZCB0aGVuIHNlbGYgcmVnaXN0ZXIgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExheWVyKGxheWVyOiBNYXBMYXllckRpcmVjdGl2ZSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBsYXllclxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVyIC0gTWFwTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYXllciBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyQmFzZVxuICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIuSWQpO1xuICAgICAgICBpZiAobCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGwudGhlbigobDE6IExheWVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGwxLkRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVycy5kZWxldGUobGF5ZXIuSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIExheWVyIG1vZGVsIHJlcHJlc2VudGVkIGJ5IHRoaXMgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IG9yIGxheWVyIGlkIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIgbW9kZWwuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIHRoZSBMYXllciBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TmF0aXZlTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlfG51bWJlcik6IFByb21pc2U8TGF5ZXI+IHtcbiAgICAgICAgbGV0IHA6IFByb21pc2U8TGF5ZXI+ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZihsYXllcikgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldCgoPE1hcExheWVyRGlyZWN0aXZlPmxheWVyKS5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcmtlciBpbiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgSWQgb2YgdGhlIGxheWVyIGluIHdoaWNoIHRvIGNyZWF0ZSB0aGUgbWFya2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBNYXJrZXJ9IG1vZGVsIGZvciB0aGUgY3JlYXRlZCBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPiB7XG4gICAgICAgIGNvbnN0IG1wOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4gPSB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2U7XG4gICAgICAgIGNvbnN0IGxwOiBQcm9taXNlPExheWVyPiA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbXAsIGxwXSkudGhlbigoW21hcCwgbF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoeDogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyk6IEdvb2dsZU1hcmtlciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih4KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gbWFya2VyLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcChtYXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgR29vZ2xlTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgbS5Jc0ZpcnN0ID0gb3B0aW9ucy5pc0ZpcnN0O1xuICAgICAgICAgICAgICAgIG0uSXNMYXN0ID0gb3B0aW9ucy5pc0xhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2YWw6IGFueSwga2V5OiBzdHJpbmcpID0+IG0uTWV0YWRhdGEuc2V0KGtleSwgdmFsKSk7IH1cbiAgICAgICAgICAgICAgICBsLkFkZEVudGl0eShtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmljb25JbmZvICYmIG9wdGlvbnMuaWNvbkluZm8ubWFya2VyVHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG9wdGlvbnMuaWNvbkluZm8pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkKG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHguaWNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkKG8pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZChvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIG1hcmtlcnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIG1hcmtlcnMgdG8gYmUgdXNlZCBpbiBidWxrXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlcnMuXG4gICAgICogQHBhcmFtIG1hcmtlckljb24gLSBPcHRpb25hbCBpbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBjdXN0b20gbWFya2Vycy4gVGhpcyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1hcmtlcnMuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgTWFya2VyIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcpOiBBcnJheTxHb29nbGVNYXJrZXI+ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlcnM6IEFycmF5PEdvb2dsZU1hcmtlcj4gPSBvcHRpb25zLm1hcChtbyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMobW8pO1xuICAgICAgICAgICAgICAgIGlmIChpY29uICYmIGljb24gIT09ICcnKSB7IG8uaWNvbiA9IGljb247IH1cbiAgICAgICAgICAgICAgICBjb25zdCBwdXNocGluID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXI6IEdvb2dsZU1hcmtlciA9IG5ldyBHb29nbGVNYXJrZXIocHVzaHBpbik7XG4gICAgICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBtby5pc0ZpcnN0O1xuICAgICAgICAgICAgICAgIG1hcmtlci5Jc0xhc3QgPSBtby5pc0xhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKG1vLm1ldGFkYXRhKSB7IG1vLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gbWFya2VyLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8QXJyYXk8TWFya2VyPj4gPSBuZXcgUHJvbWlzZTxBcnJheTxNYXJrZXI+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFya2VySWNvbiAmJiBtYXJrZXJJY29uLm1hcmtlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gTWFya2VyLkNyZWF0ZU1hcmtlcihtYXJrZXJJY29uKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHMpID09PSAnc3RyaW5nJykgeyByZXNvbHZlKHBheWxvYWQocykpOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHBheWxvYWQoeC5pY29uKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgKHBheWxvYWQobnVsbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXllciBiYXNlZCBvbiBpdHMgaWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIGlkIC0gTGF5ZXIgSWQuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBMYXllcn0gbW9kZWwgZm9yIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgR2V0TGF5ZXJCeUlkKGlkOiBudW1iZXIpOiBQcm9taXNlPExheWVyPiB7XG4gICAgICAgIGxldCBwOiBQcm9taXNlPExheWVyPjtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGw6IFByb21pc2U8TGF5ZXI+LCBrOiBudW1iZXIpID0+IHsgaWYgKGsgPT09IGlkKSB7IHAgPSBsOyB9IH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbn1cbiIsIsOvwrvCv2ltcG9ydCB7IElDbHVzdGVySWNvbkluZm8gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLWljb24taW5mbyc7XG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuLi9tYXJrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xuaW1wb3J0IHsgTWFya2VyVHlwZUlkIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlci10eXBlLWlkJztcbmltcG9ydCB7IENsdXN0ZXJDbGlja0FjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbic7XG5pbXBvcnQgeyBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXInO1xuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9jbHVzdGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZUxheWVyQmFzZSB9IGZyb20gJy4vZ29vZ2xlLWxheWVyLWJhc2UnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWdvbic7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgR29vZ2xlQ2x1c3RlclNlcnZpY2UgZXh0ZW5kcyBHb29nbGVMYXllckJhc2UgaW1wbGVtZW50cyBDbHVzdGVyU2VydmljZSB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJvdGVjdGVkIF9sYXllcnM6IE1hcDxudW1iZXIsIFByb21pc2U8TGF5ZXI+PiA9IG5ldyBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4oKTtcbiAgICBwcm90ZWN0ZWQgX2xheWVyU3R5bGVzOiBNYXA8bnVtYmVyLCBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+PiA9IG5ldyBNYXA8bnVtYmVyLCBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+PigpO1xuXG4gICAgLy8vXG4gICAgLy8vIFN0YXRpYyBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjbHVzdGVyIGljb24gZnJvbSB0aGUgc3R5bGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3R5bGVzXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHRoYXQgd2hlbiByZXNvbHZlZCBjb250YWlucyBhbiBBcnJheSBvZiBJQ2x1c3Rlckljb25JbmZvIG9iamVjdHNcbiAgICAgKiBjb250YWluaW5nIHRoZSBoeWRyYXRlZCBjbHVzdGVyIGljb25zLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgQ3JlYXRlQ2x1c3Rlckljb25zKHN0eWxlczogQXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4pOiBQcm9taXNlPEFycmF5PElDbHVzdGVySWNvbkluZm8+PiB7XG4gICAgICAgIGNvbnN0IGk6IFByb21pc2U8QXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4+ID0gbmV3IFByb21pc2U8QXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhID0gbmV3IEFycmF5PFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+PigpO1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goKHN0eWxlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pY29uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzOiBzdHJpbmd8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4gPSBNYXJrZXIuQ3JlYXRlTWFya2VyKHN0eWxlLmljb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnVybCA9IHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaWNvbkluZm8uc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5pY29uSW5mby5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbyAmJiBzdHlsZS5pY29uSW5mby5zaXplICYmIHN0eWxlLmFuY2hvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogSU1hcmtlckljb25JbmZvID0gc3R5bGUuaWNvbkluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuYW5jaG9yID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnNpemUud2lkdGggKiBvLm1hcmtlck9mZnNldFJhdGlvLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS5oZWlnaHQgKiBvLm1hcmtlck9mZnNldFJhdGlvLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlLmljb25JbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy50aGVuKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnVybCA9IHguaWNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHguaWNvbkluZm8uc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0geC5pY29uSW5mby5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8gJiYgeC5pY29uSW5mby5zaXplICYmIHN0eWxlLmFuY2hvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG86IElNYXJrZXJJY29uSW5mbyA9IHguaWNvbkluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmFuY2hvciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS53aWR0aCAqIG8ubWFya2VyT2Zmc2V0UmF0aW8ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS5oZWlnaHQgKiBvLm1hcmtlck9mZnNldFJhdGlvLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlLmljb25JbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYS5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGEubGVuZ3RoID09PSAwKSB7IHJlc29sdmUoc3R5bGVzKTsgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocGEpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZVxuICAgICAqIEBwYXJhbSBfem9uZVxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHN1cGVyKF9tYXBTZXJ2aWNlLCBfem9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY2x1c3RlciBsYXllciB0byB0aGUgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkTGF5ZXIobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvcHRpb25zOiBJQ2x1c3Rlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpZDogbGF5ZXIuSWQsXG4gICAgICAgICAgICB2aXNpYmxlOiBsYXllci5WaXNpYmxlLFxuICAgICAgICAgICAgY2x1c3RlcmluZ0VuYWJsZWQ6IGxheWVyLkNsdXN0ZXJpbmdFbmFibGVkLFxuICAgICAgICAgICAgem9vbU9uQ2xpY2s6IGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3RlclxuICAgICAgICB9O1xuICAgICAgICBpZiAobGF5ZXIuR3JpZFNpemUpIHsgb3B0aW9ucy5ncmlkU2l6ZSA9IGxheWVyLkdyaWRTaXplOyB9XG4gICAgICAgIGlmIChsYXllci5NaW5pbXVtQ2x1c3RlclNpemUpIHsgb3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUgPSBsYXllci5NaW5pbXVtQ2x1c3RlclNpemU7IH1cbiAgICAgICAgaWYgKGxheWVyLlN0eWxlcykgeyBvcHRpb25zLnN0eWxlcyA9IGxheWVyLlN0eWxlczsgfVxuICAgICAgICBpZiAobGF5ZXIuVXNlRHluYW1pY1NpemVNYXJrZXJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBkbyBub3QgdG8gYXR0ZW1wdCB0byBzZXR1cCBzdHlsZXMgaGVyZSBhcyB0aGUgZHluYW1pYyBjYWxsIGJhY2sgd2lsbCBnZW5lcmF0ZSB0aGVtLlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5zdHlsZXMgPSBbe1xuICAgICAgICAgICAgICAgIGhlaWdodDogMzAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDM1LFxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICB0ZXh0U2l6ZTogMTEsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBpY29uSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJUeXBlOiBNYXJrZXJUeXBlSWQuRm9udE1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgZm9udE5hbWU6ICdGb250QXdlc29tZScsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAzMCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXHVGMTExJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR5bmFtaWNDbHVzdGVyQ2FsbGJhY2sgPSAobWFya2VyczogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiwgbnVtU3R5bGVzOiBudW1iZXIsXG4gICAgICAgICAgICBjbHVzdGVyZXI6IEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlcikgPT4ge1xuICAgICAgICAgICAgLy8gZHluYW1pY2FsbHkgZW5zdXJlIHRoYXQgdGhlIG5lY2Vzc2FyeSBzdHlsZSBmb3IgdGhpcyBjbHVzdGVyIGljb24gZXhpc3RzIGFuZFxuICAgICAgICAgICAgLy8gdGhlIGNsdXN0ZXJlciBpcyBhbHJlYWR5IGhvb2tlZCB1cCB0byB0aGUgc3R5bGVzIGFycmF5IHZpYSBwb2ludGVyLCBzbyB3ZSBvbmx5XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHVwZGF0ZSB0aGUgc3R5bGUuIFNpbmNlIHRoZSBjbHVzdGVyZXIgcmUtcmVuZGVycyBhIGNsdXN0ZXIgaWNvbiBpcyB0aGVcbiAgICAgICAgICAgIC8vIHRoZSBtYXJrZXIgY291bnQgY2hhbmdlcywgd2Ugd2lsbCBvbmx5IG5lZWQgdG8gcmV0YWluIHRoZSBjdXJyZW50IGljb24gYXMgb3Bwb3NlZFxuICAgICAgICAgICAgLy8gdG8gYWxsIGNsdXN0ZXIgaWNvbi5cbiAgICAgICAgICAgIGNvbnN0IHN0eWxlczogQXJyYXk8R29vZ2xlTWFwVHlwZXMuQ2x1c3RlclN0eWxlPiA9IHRoaXMuX2xheWVyU3R5bGVzLmdldChsYXllci5JZCk7XG4gICAgICAgICAgICBjb25zdCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvID0ge1xuICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IE1hcmtlclR5cGVJZC5Ob25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaWNvbjogc3RyaW5nID0gbGF5ZXIuQ3VzdG9tTWFya2VyQ2FsbGJhY2soPGFueT5tYXJrZXJzLCBpY29uSW5mbyk7XG4gICAgICAgICAgICBzdHlsZXNbMF0gPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBgXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7aWNvbn1cXFwiYCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb25JbmZvLnNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uSW5mby5zaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICB0ZXh0U2l6ZTogMTEsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1hcmtlcnMubGVuZ3RoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc2V0U3R5bGVzID0gKGNsdXN0ZXJlcjogR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJTdHlsZXMuaGFzKGxheWVyLklkKSkgeyB0aGlzLl9sYXllclN0eWxlcy5nZXQobGF5ZXIuSWQpLnNwbGljZSgwKTsgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVzOiBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkNsdXN0ZXJTdHlsZT4oKTtcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7fSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJTdHlsZXMuc2V0KGxheWVyLklkLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJlci5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgc3R5bGVzIGFzIHRoZSBwb2ludGVyIHRvIHRoaXMgYXJyYXkgZ2V0cyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJvdW5kIGtleSBvYmplY3RzIGluIHRoZSBjbHVzdGVyZXIuIFRoZXJlZm9yZSwgaXQgbXVzdCBiZSBpbml0aWFsaXplZCBoZXJlIGluIG9yZGVyIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRvIHRoZSBzdHlsZXMgdG8gYmUgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbywgd2UgbmVlZCB0byBhZGQgYXQgbGVhc3Qgb25lIHN0eWxlIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgc3R5bGVzIGZyb20gYmVpbmcgcGlja2VkIHVwLlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGxheWVyUHJvbWlzZSA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlQ2x1c3RlckxheWVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9sYXllcnMuc2V0KGxheWVyLklkLCBsYXllclByb21pc2UpO1xuICAgICAgICBsYXllclByb21pc2UudGhlbihsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJlcjogR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyID0gPEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlcj5sLk5hdGl2ZVByaW1pdHZlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyAgPSBHb29nbGVDbHVzdGVyU2VydmljZS5DcmVhdGVDbHVzdGVySWNvbnMob3B0aW9ucy5zdHlsZXMpO1xuICAgICAgICAgICAgICAgIHMudGhlbih4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlcmVyLnNldFN0eWxlcyg8QXJyYXk8R29vZ2xlTWFwVHlwZXMuQ2x1c3RlclN0eWxlPj54KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc2V0U3R5bGVzKGNsdXN0ZXJlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5NYXBQcm9taXNlLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKCd6b29tX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0eWxlcyhjbHVzdGVyZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbHVzdGVyZXIuc2V0Q2FsY3VsYXRvcigobSwgbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHluYW1pY0NsdXN0ZXJDYWxsYmFjayhtLCBuLCBjbHVzdGVyZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYXJrZXIgaW4gdGhlIGNsdXN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPiB7XG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHRocm93IChuZXcgRXJyb3IoYExheWVyIHdpdGggaWQgJHtsYXllcn0gbm90IGZvdW5kIGluIExheWVyIE1hcGApKTsgfVxuXG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXJrZXIob3B0aW9ucylcbiAgICAgICAgICAgICAgICAudGhlbigobWFya2VyOiBNYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcbiAgICAgICAgICAgICAgICAgICAgbC5BZGRFbnRpdHkobWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBjbHVzdGVyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU3RhcnRDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBjbHVzdGVyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU3RvcENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBvbHlnb24gdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlnb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5Z29uIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlnb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5Z29uIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVQb2x5Z29ucyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWdvbk9wdGlvbnM+KTogUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4ge1xuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdQb2x5Z29ucyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjbHVzdGVyaW5nIGxheWVycy4gWW91IGNhbiBvbmx5IHVzZSBtYXJrZXJzLicpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5bGluZSBvcHRpb25zIGRlZmluaW5nIHRoZSBsaW5lLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWxpbmUgKG9yIGFuXG4gICAgICogYXJyYXkgb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdQb2x5bGluZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlsaW5lIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZXMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+IHtcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2luZm9ib3gnO1xuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2luZm8td2luZG93JztcbmltcG9ydCB7IEdvb2dsZUluZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1pbmZvLXdpbmRvdyc7XG5pbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXInO1xuaW1wb3J0IHsgR29vZ2xlTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHb29nbGVJbmZvQm94U2VydmljZSBleHRlbmRzIEluZm9Cb3hTZXJ2aWNlIHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cblxuICAgIHByaXZhdGUgX2JveGVzOiBNYXA8SW5mb0JveENvbXBvbmVudCwgUHJvbWlzZTxJbmZvV2luZG93Pj4gPSBuZXcgTWFwPEluZm9Cb3hDb21wb25lbnQsIFByb21pc2U8R29vZ2xlSW5mb1dpbmRvdz4+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZVxuICAgICAqIEBwYXJhbSBfbWFya2VyU2VydmljZVxuICAgICAqIEBwYXJhbSBfem9uZVxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfbWFya2VyU2VydmljZTogTWFya2VyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBpbmZvIHdpbmRvd1xuICAgICAqXG4gICAgICogQHBhcmFtIGluZm9cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBBZGRJbmZvV2luZG93KGluZm86IEluZm9Cb3hDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zID0ge307XG4gICAgICAgIGlmIChpbmZvLkh0bWxDb250ZW50ICE9PSAnJykge1xuICAgICAgICAgICAgb3B0aW9ucy5odG1sQ29udGVudCA9IGluZm8uSHRtbENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnRpdGxlID0gaW5mby5UaXRsZTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVzY3JpcHRpb24gPSBpbmZvLkRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvLnhPZmZzZXQgfHwgaW5mby55T2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5waXhlbE9mZnNldCA9PSBudWxsKSB7IG9wdGlvbnMucGl4ZWxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTsgfVxuICAgICAgICAgICAgaWYgKGluZm8ueE9mZnNldCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0LnggPSBpbmZvLnhPZmZzZXQ7IH1cbiAgICAgICAgICAgIGlmIChpbmZvLnlPZmZzZXQpIHsgb3B0aW9ucy5waXhlbE9mZnNldC55ID0gaW5mby55T2Zmc2V0OyB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5kaXNhYmxlQXV0b1BhbiA9IGluZm8uRGlzYWJsZUF1dG9QYW47XG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IGluZm8uVmlzaWJsZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluZm8uTGF0aXR1ZGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmZvLkxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSB7IGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLCBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mb1dpbmRvd1Byb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUluZm9XaW5kb3cob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2JveGVzLnNldChpbmZvLCBpbmZvV2luZG93UHJvbWlzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBpbmZvIHdpbmRvd1xuICAgICAqXG4gICAgICogQHBhcmFtIGluZm9cbiAgICAgKiBAcmV0dXJucyAtICBBIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBpbmZvIGJveCBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ2xvc2UoaW5mbzogSW5mb0JveENvbXBvbmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm94ZXMuZ2V0KGluZm8pLnRoZW4odyA9PiB7XG4gICAgICAgICAgICB3LkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYW4gaW5mbyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXG4gICAgICogQHBhcmFtIGluZm9Db21wb25lbnQgLSBUaGUge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIGluZm9Db21wb25lbnQ6IEluZm9Cb3hDb21wb25lbnQpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgY29uc3QgZ29vZ2xlRXZlbnROYW1lOiBzdHJpbmcgPSBHb29nbGVNYXBFdmVudHNMb29rdXBbZXZlbnROYW1lXTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2JveGVzLmdldChpbmZvQ29tcG9uZW50KS50aGVuKChiOiBJbmZvV2luZG93KSA9PiB7XG4gICAgICAgICAgICAgICAgYi5BZGRMaXN0ZW5lcihnb29nbGVFdmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgaW5mbyB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmZvXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgaW5mbyB3aW5kb3cuIFdpbmRvdyBvcGVucyBvbiBhIG1hcmtlciwgaWYgc3VwcGxpZWQsIG9yIGEgc3BlY2lmaWMgbG9jYXRpb24gaWYgZ2l2ZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmZvXG4gICAgICogQHBhcmFtIFtsb2NdXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgT3BlbihpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBsb2M/OiBJTGF0TG9uZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoaW5mby5DbG9zZUluZm9Cb3hlc09uT3BlbiB8fCBpbmZvLk1vZGFsKSB7XG4gICAgICAgICAgICAvLyBjbG9zZSBhbGwgb3BlbiBpbmZvIGJveGVzXG4gICAgICAgICAgICB0aGlzLl9ib3hlcy5mb3JFYWNoKChib3g6IFByb21pc2U8SW5mb1dpbmRvdz4sIGk6IEluZm9Cb3hDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5JZCAhPT0gaS5JZCkge1xuICAgICAgICAgICAgICAgICAgICBib3gudGhlbigodykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcuSXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdy5DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3OiBHb29nbGVJbmZvV2luZG93KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbmZvLkh0bWxDb250ZW50ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHRtbENvbnRlbnQgPSBpbmZvLkh0bWxDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IGluZm8uVGl0bGU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3LlNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoaW5mby5Ib3N0TWFya2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VyU2VydmljZS5HZXROYXRpdmVNYXJrZXIoaW5mby5Ib3N0TWFya2VyKS50aGVuKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcFNlcnZpY2UuTWFwUHJvbWlzZS50aGVuKChtYXApID0+ICg8R29vZ2xlSW5mb1dpbmRvdz53KS5PcGVuKCg8R29vZ2xlTWFya2VyPm1hcmtlcikuTmF0aXZlUHJpbWl0dmUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbigobWFwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYykgeyB3LlNldFBvc2l0aW9uKGxvYyk7IH1cbiAgICAgICAgICAgICAgICB3Lk9wZW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmZvIHdpbmRvdyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5mb1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3OiBHb29nbGVJbmZvV2luZG93KSA9PiB7XG4gICAgICAgICAgICB3LlNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5mb1xuICAgICAqIEBwYXJhbSBsYXRsbmdcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRQb3NpdGlvbihpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBsYXRsbmc6IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB7XG4gICAgICAgICAgICB3LlNldFBvc2l0aW9uKGxhdGxuZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBlYWNoU2VyaWVzLCBuZXh0VGljayB9IGZyb20gJ2FzeW5jJztcbmltcG9ydCB7IEdvb2dsZU1hcmtlciB9IGZyb20gJy4vZ29vZ2xlLW1hcmtlcic7XG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9sYXllcic7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tYXJrZXInO1xuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9wb2x5Z29uJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vcG9seWxpbmUnO1xuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcblxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGxheWVyIGZvciB0aGUgR29vZ2xlIE1hcCBQcm92aWRlci5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBHb29nbGVMYXllciBpbXBsZW1lbnRzIExheWVyIHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcbiAgICAvLy9cbiAgICBwcml2YXRlIF9lbnRpdGllczogQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4gPSBuZXcgQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4oKTtcbiAgICBwcml2YXRlIF92aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8vL1xuICAgIC8vLyBQcm9wZXJ0eSBkZWZpbml0aW9uc1xuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYXRpdmUgcHJpbWl0aXZlIHVuZGVybmVhdGggdGhlIGFic3RyYWN0aW9uIGxheWVyLiBHb29nbGUgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiBhIGN1c3RvbSBsYXllcixcbiAgICAgKiBzbyB3ZSBhcmUgcmV0dXJuaW5nIHRoZSBNYXAgYXMgdGhlIG5hdGl2ZSBvYmplY3QgYmVjYXVzZSBpdCBob3N0cyBhbGwgdGhlIG1hcmtlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcjtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEdvb2dsZU1hcmtlckNsdXN0ZXJlciBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfbGF5ZXIgR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyLiBOYXRpdmUgR29vZ2xlIE1hcHMgTWFya2VyIENsdXN0ZXJlciBzdXBwb3J0aW5nIHRoZSBjbHVzdGVyIGxheWVyLlxuICAgICAqIEBwYXJhbSBfbWFwcyBNYXBTZXJ2aWNlLiBNYXBTZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRvIGxldmVyYWdlIGZvciB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sYXllcjogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwLCBwcml2YXRlIF9tYXBzOiBNYXBTZXJ2aWNlLCBwcml2YXRlIF9pZDogbnVtYmVyKSB7IH1cblxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzLCBMYXllciBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgc3RyaW5nLiBUeXBlIG9mIGV2ZW50IHRvIGFkZCAoY2xpY2ssIG1vdXNlb3ZlciwgZXRjKS4gWW91IGNhbiB1c2UgYW55IGV2ZW50IHRoYXQgdGhlIHVuZGVybHlpbmcgbmF0aXZlXG4gICAgICogbGF5ZXIgc3VwcG9ydHMuXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXG4gICAgICovXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignRXZlbnRzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIEdvb2dsZSBMYXllcnMuIFlvdSBjYW4gc3RpbGwgYWRkIGV2ZW50cyB0byBpbmRpdmlkdWFsIG1hcmtlcnMuJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gVXNlIHRoaXMgbWV0aG9kIHdpdGggY2F1dGlvbiBhcyBpdCB3aWxsXG4gICAgICogdHJpZ2dlciBhIHJlY2FsdWF0aW9uIG9mIHRoZSBjbHVzdGVycyAoYW5kIGFzc29jaWF0ZWQgbWFya2VycyBpZiBhcHByb3ByaXRlKSBmb3JcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIElmIHlvdSB1c2UgdGhpcyBtZXRob2QgdG8gYWRkIG1hbnkgbWFya2VycyB0byB0aGUgY2x1c3RlciwgdXNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUuIEVudGl0eSB0byBhZGQgdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxBeWVyXG4gICAgICovXG4gICAgcHVibGljIEFkZEVudGl0eShlbnRpdHk6IE1hcmtlciB8IEluZm9XaW5kb3cgfCBQb2x5Z29uIHwgUG9seWxpbmUpOiB2b2lkIHtcbiAgICAgICAgaWYgKGVudGl0eS5OYXRpdmVQcmltaXR2ZSkge1xuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgZW50aXR5Lk5hdGl2ZVByaW1pdHZlLnNldFZpc2libGUodGhpcy5fdmlzaWJsZSk7XG4gICAgICAgICAgICBlbnRpdHkuTmF0aXZlUHJpbWl0dmUuc2V0TWFwKHRoaXMuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG51bWJlciBvZiBlbnRpdGllcyB0byB0aGUgbGF5ZXIuIEVudGl0aWVzIGluIHRoaXMgY29udGV4dCBzaG91bGQgYmUgbW9kZWwgYWJzdHJhY3Rpb25zIG9mIGNvbmNlcmVkIG1hcCBmdW5jdGlvbmFsaXR5IChzdWNoXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4uIEVudGl0aWVzIHRvIGFkZCB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTEF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkRW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+KTogdm9pZCB7XG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcbiAgICAgICAgICAgIHRoaXMuX2VudGl0aWVzLnB1c2goLi4uZW50aXRpZXMpO1xuICAgICAgICAgICAgZWFjaFNlcmllcyhbLi4uZW50aXRpZXNdLCAoZSwgbmV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGUuTmF0aXZlUHJpbWl0dmUuc2V0VmlzaWJsZSh0aGlzLl92aXNpYmxlKTtcbiAgICAgICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldE1hcCh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiBuZXh0KCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBsYXllciBhbmJkIHRoZSBtYXJrZXJzIGluIGl0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgZWFjaFNlcmllcyh0aGlzLl9lbnRpdGllcy5zcGxpY2UoMCksIChlLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IG5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9wdGlvbnMgZ292ZXJuaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJTGF5ZXJPcHRpb25zLiBUaGUgbGF5ZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRPcHRpb25zKCk6IElMYXllck9wdGlvbnMge1xuICAgICAgICBjb25zdCBvcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX2lkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudGl0eSBNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lIEVudGl0eSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXG4gICAgICovXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlciB8IEluZm9XaW5kb3cgfCBQb2x5Z29uIHwgUG9seWxpbmUpOiB2b2lkIHtcbiAgICAgICAgaWYgKGVudGl0eS5OYXRpdmVQcmltaXR2ZSkge1xuICAgICAgICAgICAgY29uc3QgajogbnVtYmVyID0gdGhpcy5fZW50aXRpZXMuaW5kZXhPZihlbnRpdHkpO1xuICAgICAgICAgICAgaWYgKGogPiAtMSkgeyB0aGlzLl9lbnRpdGllcy5zcGxpY2UoaiwgMSk7IH1cbiAgICAgICAgICAgIGVudGl0eS5OYXRpdmVQcmltaXR2ZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPnxBcnJheTxJbmZvV2luZG93PnxBcnJheTxQb2x5Z29uPnxBcnJheTxQb2x5bGluZT4gY29udGFpbmluZ1xuICAgICAqIHRoZSBlbnRpdGllcyB0byBhZGQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgcmVwbGFjZXMgYW55IGV4aXN0aW5nIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXG4gICAgICovXG4gICAgcHVibGljIFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+IHwgQXJyYXk8SW5mb1dpbmRvdz4gfCBBcnJheTxQb2x5Z29uPiB8IEFycmF5PFBvbHlsaW5lPik6IHZvaWQge1xuICAgICAgICB0aGlzLkRlbGV0ZSgpO1xuICAgICAgICB0aGlzLkFkZEVudGl0aWVzKGVudGl0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgY2x1c3RlciBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIElMYXllck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXG4gICAgICogYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0L2V4aXN0aW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJTGF5ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2lkID0gb3B0aW9ucy5pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBjbHVzdGVyIGxheWVyIHZpc2liaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSBCb29sZWFuIHRydWUgdG8gbWFrZSB0aGUgbGF5ZXIgdmlzaWJsZSwgZmFsc2UgdG8gaGlkZSB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBlYWNoU2VyaWVzKFsuLi50aGlzLl9lbnRpdGllc10sIChlLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiBuZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlsaW5lJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2xheWVyJztcbmltcG9ydCB7IEdvb2dsZUxheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtbGF5ZXInO1xuaW1wb3J0IHsgR29vZ2xlUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlnb24nO1xuaW1wb3J0IHsgR29vZ2xlUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5bGluZSc7XG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlTGF5ZXJCYXNlIH0gZnJvbSAnLi9nb29nbGUtbGF5ZXItYmFzZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlQ29udmVyc2lvbnMgfSBmcm9tICcuL2dvb2dsZS1jb252ZXJzaW9ucyc7XG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xuXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBjb250cmFjdCBmb3IgYSBHb29nbGUgTWFwcyBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHb29nbGVMYXllclNlcnZpY2UgZXh0ZW5kcyBHb29nbGVMYXllckJhc2UgaW1wbGVtZW50cyBMYXllclNlcnZpY2UgIHtcblxuICAgIC8vL1xuICAgIC8vLyBGaWVsZCBEZWNsYXJhdGlvbnMuXG4gICAgLy8vXG4gICAgcHJvdGVjdGVkIF9sYXllcnM6IE1hcDxudW1iZXIsIFByb21pc2U8TGF5ZXI+PiA9IG5ldyBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4oKTtcblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVMYXllclNlcnZpY2UuXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gSW5zdGFuY2Ugb2YgdGhlIEdvb2dsZSBNYXBzIFNlcnZpY2UuIFdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBpbnN0YW5jZSB0byBwcm92aWRlIHpvbmUgYXdhcmUgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIF96b25lOiBOZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoX21hcFNlcnZpY2UsIF96b25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3QuXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXG4gICAgICogTGF5ZXJTZXJ2aWNlIGFuZCB0aGVuIHNlbGYgcmVnaXN0ZXIgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEFkZExheWVyKGxheWVyOiBNYXBMYXllckRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBwOiBQcm9taXNlPExheWVyPiA9IG5ldyBQcm9taXNlPExheWVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbihtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsOiBHb29nbGVMYXllciA9IG5ldyBHb29nbGVMYXllcihtLCB0aGlzLl9tYXBTZXJ2aWNlLCBsYXllci5JZCk7XG4gICAgICAgICAgICAgICAgbC5TZXRWaXNpYmxlKGxheWVyLlZpc2libGUpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIuSWQsIHApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwb2x5Z29uIHRvIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29uLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWdvbiBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvbihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBQcm9taXNlPFBvbHlnb24+IHtcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxQb2x5Z29uPiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWdvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKTtcbiAgICAgICAgUHJvbWlzZS5hbGwoW3AsIGxdKS50aGVuKHggPT4geFsxXS5BZGRFbnRpdHkoeFswXSkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWdvbnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlnb25zIHRvIGJlIHVzZWQgaW4gYnVsa1xuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWdvbnMuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWdvbiBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IHdlIGF0dGVtcHRlZCB1c2luZyBkYXRhLlBvbHlnb25zIGluIGFuIGF0dGVtcHQgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IGVpdGhlciBkYXRhLlBvbHlnb25cbiAgICAgICAgLy8gb3IgZGF0YS5NdWx0aVBvbHlnb24gYWN0dWFsbHkgb3BlcmF0ZSBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIGdlbmVyYXRpbmcgdGhlIHBvbHlnb25zIHRoaXMgd2F5LlxuICAgICAgICAvLyB0aGUgc2xvd25lc3MgaW4gZ29vZ2xlIGFzIG9wcG9zZWQgdG8gYmluZyBwcm9iYWJseSBjb21lcyBmcm9tIHRoZSBwb2ludCByZWR1Y3Rpb24gYWxnb3JpdGhtIHVzZXMuXG4gICAgICAgIC8vIFNpZ25pZ2ljYW50IHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBtaWdodCBiZSBwb3NzaWJsZSBpbiBnb29nbGUgd2hlbiB1c2luZyBhIHBpeGVsIGJhc2VkIHJlZHVjdGlvbiBhbGdvcml0aG1cbiAgICAgICAgLy8gcHJpb3IgdG8gc2V0dGluZyB0aGUgcG9seWdvbiBwYXRoLiBUaGlzIHdpbGwgbG93ZXIgdG8gcHJvY2Vzc2luZyBvdmVyaGVhZCBvZiB0aGUgZ29vZ2xlIGFsZ29yaXRobSAod2l0aCBpcyBEb3VnbGFzLVBldWNrZXJcbiAgICAgICAgLy8gYW5kIHJhdGhlciBjb21wdXRlIGludGVuc2l2ZSlcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uczogUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4gPSBuZXcgUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlzOiBBcnJheTxHb29nbGVQb2x5Z29uPiA9IG9wdGlvbnMubWFwKG8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seTogR29vZ2xlTWFwVHlwZXMuUG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seWdvbjogR29vZ2xlUG9seWdvbiA9IG5ldyBHb29nbGVQb2x5Z29uKHBvbHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoby50aXRsZSAmJiBvLnRpdGxlICE9PSAnJykgeyBwb2x5Z29uLlRpdGxlID0gby50aXRsZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gcG9seWdvbi5NZXRhZGF0YS5zZXQoa2V5LCB2YWwpKTsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBvbHlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25zO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlsaW5lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmUuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5bGluZSAob3IgYW4gYXJyYXlcbiAgICAgKiBvZiBwb2x5Z29ucyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xuICAgICAgICBjb25zdCBwOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4gPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZVBvbHlsaW5lKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsOiBQcm9taXNlPExheWVyPiA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIpO1xuICAgICAgICBQcm9taXNlLmFsbChbcCwgbF0pLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwMTogQXJyYXk8UG9seWxpbmU+ID0gIEFycmF5LmlzQXJyYXkoeFswXSkgPyA8QXJyYXk8UG9seWxpbmU+PnhbMF0gOiBbPFBvbHlsaW5lPnhbMF1dO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwMiBvZiBwMSkge3hbMV0uQWRkRW50aXR5KHAyKTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlsaW5lIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmVzKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KTogUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PiB7XG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHRocm93IChuZXcgRXJyb3IoYExheWVyIHdpdGggaWQgJHtsYXllcn0gbm90IGZvdW5kIGluIExheWVyIE1hcGApKTsgfVxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9seWxpbmVzOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID0gbmV3IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlzOiBBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+ID0gb3B0aW9ucy5tYXAobyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMobyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnBhdGggJiYgby5wYXRoLmxlbmd0aCA+IDAgJiYgIUFycmF5LmlzQXJyYXkoby5wYXRoWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AucGF0aCA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG8ucGF0aClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5OiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZSA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZShvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogR29vZ2xlUG9seWxpbmUgPSBuZXcgR29vZ2xlUG9seWxpbmUocG9seSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby50aXRsZSAmJiBvLnRpdGxlICE9PSAnJykgeyBwb2x5bGluZS5UaXRsZSA9IG8udGl0bGU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcG9seWxpbmUuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aHM6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzOiBBcnJheTxQb2x5bGluZT4gPSBuZXcgQXJyYXk8UG9seWxpbmU+KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRocy5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBhdGggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlsaW5lOiBHb29nbGVQb2x5bGluZSA9IG5ldyBHb29nbGVQb2x5bGluZShwb2x5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby50aXRsZSAmJiBvLnRpdGxlICE9PSAnJykge3BvbHlsaW5lLlRpdGxlID0gby50aXRsZTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBvbHlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lcztcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcblxuLyoqXG4gKiBQcm90b2NvbCBlbnVtZXJhdGlvblxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBlbnVtIFNjcmlwdFByb3RvY29sIHtcbiAgICBIVFRQLFxuICAgIEhUVFBTLFxuICAgIEFVVE9cbn1cblxuLyoqXG4gKiBCaW5nIE1hcHMgVjggc3BlY2lmaWMgbG9hZGVyIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgR29vZ2xlTWFwQVBJTG9hZGVyfVxuICpcbiAqIEBleHBvcnRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEdvb2dsZU1hcEFQSUxvYWRlckNvbmZpZyB7XG4gICAgLyoqXG4gICAgICAgKiBUaGUgR29vZ2xlIE1hcHMgQVBJIEtleSAoc2VlOlxuICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvZ2V0LWFwaS1rZXkpXG4gICAgICAgKi9cbiAgICBhcGlLZXk/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgR29vZ2xlIE1hcHMgY2xpZW50IElEIChmb3IgcHJlbWl1bSBwbGFucykuXG4gICAgICogV2hlbiB5b3UgaGF2ZSBhIEdvb2dsZSBNYXBzIEFQSXMgUHJlbWl1bSBQbGFuIGxpY2Vuc2UsIHlvdSBtdXN0IGF1dGhlbnRpY2F0ZVxuICAgICAqIHlvdXIgYXBwbGljYXRpb24gd2l0aCBlaXRoZXIgYW4gQVBJIGtleSBvciBhIGNsaWVudCBJRC5cbiAgICAgKiBUaGUgR29vZ2xlIE1hcHMgQVBJIHdpbGwgZmFpbCB0byBsb2FkIGlmIGJvdGggYSBjbGllbnQgSUQgYW5kIGFuIEFQSSBrZXkgYXJlIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIGNsaWVudElkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEdvb2dsZSBNYXBzIGNoYW5uZWwgbmFtZSAoZm9yIHByZW1pdW0gcGxhbnMpLlxuICAgICAqIEEgY2hhbm5lbCBwYXJhbWV0ZXIgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgYWxsb3dzIHlvdSB0byB0cmFjayB1c2FnZSB1bmRlciB5b3VyIGNsaWVudFxuICAgICAqIElEIGJ5IGFzc2lnbmluZyBhIGRpc3RpbmN0IGNoYW5uZWwgdG8gZWFjaCBvZiB5b3VyIGFwcGxpY2F0aW9ucy5cbiAgICAgKi9cbiAgICBjaGFubmVsPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogR29vZ2xlIE1hcHMgQVBJIHZlcnNpb24uXG4gICAgICovXG4gICAgYXBpVmVyc2lvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxuICAgICAqL1xuICAgIGhvc3RBbmRQYXRoPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUHJvdG9jb2wgdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxuICAgICAqL1xuICAgIHByb3RvY29sPzogU2NyaXB0UHJvdG9jb2w7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHdoaWNoIEdvb2dsZSBNYXBzIGxpYnJhcmllcyBzaG91bGQgZ2V0IGxvYWRlZC5cbiAgICAgKi9cbiAgICBsaWJyYXJpZXM/OiBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGJpYXMgZm9yIHRoZSBtYXAgYmVoYXZpb3IgaXMgVVMuXG4gICAgICogSWYgeW91IHdpc2ggdG8gYWx0ZXIgeW91ciBhcHBsaWNhdGlvbiB0byBzZXJ2ZSBkaWZmZXJlbnQgbWFwIHRpbGVzIG9yIGJpYXMgdGhlXG4gICAgICogYXBwbGljYXRpb24sIHlvdSBjYW4gb3ZlcndyaXRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIChVUykgYnkgZGVmaW5pbmcgYSBgcmVnaW9uYC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvYmFzaWNzI1JlZ2lvblxuICAgICAqL1xuICAgIHJlZ2lvbj86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBHb29nbGUgTWFwcyBBUEkgdXNlcyB0aGUgYnJvd3NlcidzIHByZWZlcnJlZCBsYW5ndWFnZSB3aGVuIGRpc3BsYXlpbmdcbiAgICAgKiB0ZXh0dWFsIGluZm9ybWF0aW9uLiBJZiB5b3Ugd2lzaCB0byBvdmVyd3JpdGUgdGhpcyBiZWhhdmlvciBhbmQgZm9yY2UgdGhlIEFQSVxuICAgICAqIHRvIHVzZSBhIGdpdmVuIGxhbmd1YWdlLCB5b3UgY2FuIHVzZSB0aGlzIHNldHRpbmcuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2Jhc2ljcyNMYW5ndWFnZVxuICAgICAqL1xuICAgIGxhbmd1YWdlPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEdvb2dsZSBNYXBzIEFQSSByZXF1aXJlcyBhIHNlcGFyYXRlIGxpYnJhcnkgZm9yIGNsdXN0ZXJpbmcuIFNldCB0aGUgcHJvcGVydHlcbiAgICAgKiB0byB0cnVlIGluIG9yZGVyIHRvIGxvYWQgdGhpcyBsaWJyYXJ5LlxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9tYXJrZXItY2x1c3RlcmluZ1xuICAgICAqL1xuICAgIGVuYWJsZUNsdXN0ZXJpbmc/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSG9zdCBhbmQgUGF0aCB1c2VkIGZvciB0aGUgY2x1c3RlciBsaWJyYXJ5IGA8c2NyaXB0PmAgdGFnLlxuICAgICAqL1xuICAgIGNsdXN0ZXJIb3N0QW5kUGF0aD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGxvYWRlciBjb25maWd1cmF0aW9uLlxuICovXG5jb25zdCBERUZBVUxUX0NPTkZJR1VSQVRJT04gPSBuZXcgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnKCk7XG5cbi8qKlxuICogQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uIGZvciB0aGUge0BsaW5rIE1hcEFQSUxvYWRlcn0gc2VydmljZS5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBBUElMb2FkZXIgZXh0ZW5kcyBNYXBBUElMb2FkZXIge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlZmludGl0aW9ucy5cbiAgICAvLy9cbiAgICBwcml2YXRlIF9zY3JpcHRMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcblxuICAgIC8vL1xuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBBUElMb2FkZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IENvbmZpZygpOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWcgeyByZXR1cm4gdGhpcy5fY29uZmlnOyB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZU1hcEFQSUxvYWRlci5cbiAgICAgKiBAcGFyYW0gX2NvbmZpZyAtIFRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gX3dpbmRvd1JlZiAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBXaW5kb3dSZWZ9LiBOZWNlc3NhcnkgYmVjYXVzZSBCaW5nIE1hcCBWOCBpbnRlcmFjdHMgd2l0aCB0aGUgd2luZG93IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gX2RvY3VtZW50UmVmIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIERvY3VtZW50UmVmfS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZWNlc3NhcnkgYmVjYXVzZSBCaW5nIE1hcCBWOCBpbnRlcmFjdHMgd2l0aCB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBBUElMb2FkZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciggQE9wdGlvbmFsKCkgcHJpdmF0ZSBfY29uZmlnOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWcsIHByaXZhdGUgX3dpbmRvd1JlZjogV2luZG93UmVmLCBwcml2YXRlIF9kb2N1bWVudFJlZjogRG9jdW1lbnRSZWYpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZyA9PT0gbnVsbCB8fCB0aGlzLl9jb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnID0gREVGQVVMVF9DT05GSUdVUkFUSU9OO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzIGFuZCBNYXBBUElMb2FkZXIgaW1wbGVtZW50YXRpb24uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgQmluZyBNYXBzIFY4LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcEFQSUxvYWRlclxuICAgICAqL1xuICAgIHB1YmxpYyBMb2FkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAodGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTmFtZSA9IGBDcmVhdGVgO1xuICAgICAgICBzY3JpcHQuc3JjID0gdGhpcy5HZXRNYXBzU2NyaXB0U3JjKGNhbGxiYWNrTmFtZSk7XG5cbiAgICAgICAgdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZTogRnVuY3Rpb24sIHJlamVjdDogRnVuY3Rpb24pID0+IHtcbiAgICAgICAgICAgICg8YW55PnRoaXMuX3dpbmRvd1JlZi5HZXROYXRpdmVXaW5kb3coKSlbY2FsbGJhY2tOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmVuYWJsZUNsdXN0ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkIHRoZW4gZGVsYXkgdGhlIGxvYWRpbmcgdW50aWwgYWZ0ZXIgdGhlIGNsdXN0ZXIgbGlicmFyeSBpcyBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2x1c3RlclNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyU2NyaXB0LnNyYyA9IHRoaXMuR2V0Q2x1c3RlclNjcmlwdFNyYygpO1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyU2NyaXB0Lm9ubG9hZCA9IGNsdXN0ZXJTY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5HZXROYXRpdmVEb2N1bWVudCgpLmhlYWQuYXBwZW5kQ2hpbGQoY2x1c3RlclNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IChlcnJvcjogRXZlbnQpID0+IHsgcmVqZWN0KGVycm9yKTsgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBHb29nbGUgTWFwcyBzY3JpcHRzIHVybCBmb3IgaW5qZWN0aW9ucyBpbnRvIHRoZSBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tOYW1lIC0gTmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIEdvb2dsZSBNYXBzIHNjcmlwdHMgYXJlIGxvYWRlZC5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgdG8gYmUgdXNlZCB0byBsb2FkIHRoZSBHb29nbGUgTWFwIHNjcmlwdHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBHZXRNYXBzU2NyaXB0U3JjKGNhbGxiYWNrTmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGhvc3RBbmRQYXRoOiBzdHJpbmcgPSB0aGlzLl9jb25maWcuaG9zdEFuZFBhdGggfHwgJ21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanMnO1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IH0gPSB7XG4gICAgICAgICAgICB2OiB0aGlzLl9jb25maWcuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja05hbWUsXG4gICAgICAgICAgICBrZXk6IHRoaXMuX2NvbmZpZy5hcGlLZXksXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuX2NvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuX2NvbmZpZy5jaGFubmVsLFxuICAgICAgICAgICAgbGlicmFyaWVzOiB0aGlzLl9jb25maWcubGlicmFyaWVzLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLl9jb25maWcucmVnaW9uLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRoaXMuX2NvbmZpZy5sYW5ndWFnZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5HZXRTY3JpcHRTcmMoaG9zdEFuZFBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBHb29nbGUgTWFwcyBDbHVzdGVyIGxpYnJhcnkgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIHVybCB0byBiZSB1c2VkIHRvIGxvYWQgdGhlIEdvb2dsZSBNYXAgQ2x1c3RlciBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcEFQSUxvYWRlclxuICAgICAqL1xuICAgIHByaXZhdGUgR2V0Q2x1c3RlclNjcmlwdFNyYygpIHtcbiAgICAgICAgY29uc3QgaG9zdEFuZFBhdGg6IHN0cmluZyA9IHRoaXMuX2NvbmZpZy5jbHVzdGVySG9zdEFuZFBhdGggfHxcbiAgICAgICAgICAgICdkZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvZXhhbXBsZXMvbWFya2VyY2x1c3RlcmVyL21hcmtlcmNsdXN0ZXJlci5qcyc7XG4gICAgICAgIHJldHVybiB0aGlzLkdldFNjcmlwdFNyYyhob3N0QW5kUGF0aCwge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzY3JpcHRzIHVybCBmb3IgaW5qZWN0aW9ucyBpbnRvIHRoZSBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdEFuZFBhdGggLSBIb3N0IGFuZCBwYXRoIG5hbWUgb2YgdGhlIHNjcmlwdCB0byBsb2FkLlxuICAgICAqIEBwYXJhbSBxdWVyeVBhcmFtcyAtIFVybCBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAqIEByZXR1cm5zIC0gVGhlIHVybCB3aXRoIGNvcnJlY3QgcHJvdG9jb2wsIHBhdGgsIGFuZCBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcEFQSUxvYWRlclxuICAgICAqL1xuICAgIHByaXZhdGUgR2V0U2NyaXB0U3JjKGhvc3RBbmRQYXRoOiBzdHJpbmcsIHF1ZXJ5UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sVHlwZTogU2NyaXB0UHJvdG9jb2wgPVxuICAgICAgICAgICAgPFNjcmlwdFByb3RvY29sPigodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5wcm90b2NvbCkgfHwgU2NyaXB0UHJvdG9jb2wuSFRUUFMpO1xuICAgICAgICBsZXQgcHJvdG9jb2w6IHN0cmluZztcblxuICAgICAgICBzd2l0Y2ggKHByb3RvY29sVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5BVVRPOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjcmlwdFByb3RvY29sLkhUVFA6XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cDonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5IVFRQUzpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwczonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyYW1zOiBzdHJpbmcgPVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoazogc3RyaW5nKSA9PiBxdWVyeVBhcmFtc1trXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGs6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtc1trXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHF1ZXJ5UGFyYW1zW2tdKSAmJiBxdWVyeVBhcmFtc1trXS5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoKGs6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBqb2luIGFycmF5cyBhcyBjb21tYSBzZXBlcmF0ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gcXVlcnlQYXJhbXNba107XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBpLmpvaW4oJywnKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IHF1ZXJ5UGFyYW1zW2tdIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKChlbnRyeTogeyBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB9KSA9PiB7IHJldHVybiBgJHtlbnRyeS5rZXl9PSR7ZW50cnkudmFsdWV9YDsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RBbmRQYXRofT8ke3BhcmFtc31gO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcmtlcic7XG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL21hcC1tYXJrZXInO1xuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi9nb29nbGUtY29udmVyc2lvbnMnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBNYXJrZXJTZXJ2aWNlIGFic3RyYWN0IGNsYXNzIGZvciBHb29nbGUuXG4gKlxuICogQGV4cG9ydFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgR29vZ2xlTWFya2VyU2VydmljZSBpbXBsZW1lbnRzIE1hcmtlclNlcnZpY2Uge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX21hcmtlcnM6IE1hcDxNYXBNYXJrZXJEaXJlY3RpdmUsIFByb21pc2U8TWFya2VyPj4gPSBuZXcgTWFwPE1hcE1hcmtlckRpcmVjdGl2ZSwgUHJvbWlzZTxNYXJrZXI+PigpO1xuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZU1hcmtlclNlcnZpY2UuXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0ge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEdvb2dsZUxheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIF9jbHVzdGVyU2VydmljZSAtIHtAbGluayBDbHVzdGVyU2VydmljZX0gaW5zdGFuY2UuXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVDbHVzdGVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2NsdXN0ZXJTZXJ2aWNlOiBDbHVzdGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1hcmtlci4gRGVwZW5kaW5nIG9uIHRoZSBtYXJrZXIgY29udGV4dCwgdGhlIG1hcmtlciB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGEgY29ycmVjc3BvbmRpbmcgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEFkZE1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBJTWFya2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogbWFya2VyLkFuY2hvcixcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdGl0dWRlOiBtYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZSB9LFxuICAgICAgICAgICAgdGl0bGU6IG1hcmtlci5UaXRsZSxcbiAgICAgICAgICAgIGxhYmVsOiBtYXJrZXIuTGFiZWwsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IG1hcmtlci5EcmFnZ2FibGUsXG4gICAgICAgICAgICBpY29uOiBtYXJrZXIuSWNvblVybCxcbiAgICAgICAgICAgIGljb25JbmZvOiBtYXJrZXIuSWNvbkluZm8sXG4gICAgICAgICAgICB3aWR0aDogbWFya2VyLldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXJrZXIuSGVpZ2h0LFxuICAgICAgICAgICAgaXNGaXJzdDogbWFya2VyLklzRmlyc3RJblNldCxcbiAgICAgICAgICAgIGlzTGFzdDogbWFya2VyLklzTGFzdEluU2V0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3JlYXRlIG1hcmtlciB2aWEgcHJvbWlzZS5cbiAgICAgICAgbGV0IG1hcmtlclByb21pc2U6IFByb21pc2U8TWFya2VyPiA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrZXIuSW5DbHVzdGVyTGF5ZXIpIHtcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9jbHVzdGVyU2VydmljZS5DcmVhdGVNYXJrZXIobWFya2VyLkxheWVySWQsIG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmtlci5JbkN1c3RvbUxheWVyKSB7XG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZU1hcmtlcihtYXJrZXIuTGF5ZXJJZCwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXJrZXIobyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNldChtYXJrZXIsIG1hcmtlclByb21pc2UpO1xuICAgICAgICBpZiAobWFya2VyLkljb25JbmZvKSB7XG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlLnRoZW4oKG06IE1hcmtlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpY29uSW5mbyB0byBwcm92aWRlIGhvb2sgdG8gZG8gcG9zdCBpY29uIGNyZWF0aW9uIGFjdGl2aXRpZXMgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWxzbyByZS1hbmNob3IgdGhlIG1hcmtlclxuICAgICAgICAgICAgICAgIG1hcmtlci5EeW5hbWljTWFya2VyQ3JlYXRlZC5lbWl0KG8uaWNvbkluZm8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHA6IElQb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogKG8uaWNvbkluZm8uc2l6ZSAmJiBvLmljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvKSA/IChvLmljb25JbmZvLnNpemUud2lkdGggKiBvLmljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvLngpIDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogKG8uaWNvbkluZm8uc2l6ZSAmJiBvLmljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvKSA/IChvLmljb25JbmZvLnNpemUuaGVpZ2h0ICogby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby55KSA6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtLlNldEFuY2hvcihwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xuICAgICAgICAgICAgICAgIG0uQWRkTGlzdGVuZXIoZXZlbnROYW1lLCAoZTogVCkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0ge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcmtlciBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZU1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oKG1hOiBNYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIuSW5DbHVzdGVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrZXIuSW5DdXN0b21MYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWEuRGVsZXRlTWFya2VyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2Vycy5kZWxldGUobWFya2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNsaWNrZWQgbWFya2VyLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZyB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlLmxhdExuZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlLmxhdExuZy5sYXQgfHwgIWUubGF0TG5nLmxuZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGF0aXR1ZGU6IGUubGF0TG5nLmxhdCgpLCBsb25naXR1ZGU6IGUubGF0TG5nLmxuZygpIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIG1hcmtlciBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIE1hcmtlcn0gaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIHBpeGVsIGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIHBpeGVscyBvZiB0aGUgbWFya2VyIG9uIHRoZSBtYXAgY2FudmFzLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEdldFBpeGVsc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50IHwgYW55KTogSVBvaW50IHtcbiAgICAgICAgaWYgKCFlIHx8ICFlLmxhdExuZyB8fCAhZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNyb3NzZXNEYXRlTGluZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fbWFwU2VydmljZS5NYXBJbnN0YW5jZTtcbiAgICAgICAgY29uc3QgcCA9IG0uZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSBNYXRoLnBvdygyLCBtLmdldFpvb20oKSk7XG4gICAgICAgIGNvbnN0IGI6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0JvdW5kcyA9IG0uZ2V0Qm91bmRzKCk7XG4gICAgICAgIGlmIChiLmdldENlbnRlcigpLmxuZygpIDwgYi5nZXRTb3V0aFdlc3QoKS5sbmcoKSAgfHxcbiAgICAgICAgICAgIGIuZ2V0Q2VudGVyKCkubG5nKCkgPiBiLmdldE5vcnRoRWFzdCgpLmxuZygpKSB7IGNyb3NzZXNEYXRlTGluZSA9IHRydWU7IH1cblxuICAgICAgICBjb25zdCBvZmZzZXRZOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0Tm9ydGhFYXN0KCkpLnk7XG4gICAgICAgIGNvbnN0IG9mZnNldFg6IG51bWJlciA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoYi5nZXRTb3V0aFdlc3QoKSkueDtcbiAgICAgICAgY29uc3QgcG9pbnQ6IEdvb2dsZU1hcFR5cGVzLlBvaW50ID0gcC5mcm9tTGF0TG5nVG9Qb2ludChlLmxhdExuZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKChwb2ludC54IC0gb2Zmc2V0WCArICgoY3Jvc3Nlc0RhdGVMaW5lICYmIHBvaW50LnggPCBvZmZzZXRYKSA/IDI1NiA6IDApKSAqIHMpLFxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcigocG9pbnQueSAtIG9mZnNldFkpICogcylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGdlbyBsb2NhdGlvbiB0byBhIHBpeGVsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBtYXAgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCAtIEVpdGhlciBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9XG4gICAgICogb3IgYSB7QGxpbmsgSUxhdExvbmd9IGZvciB0aGUgYmFzaXMgb2YgdHJhbnNsYXRpb24uXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgYSB7QGxpbmsgSVBvaW50fVxuICAgICAqIHdpdGggdGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBNYXBNYXJrZXIgb3IgSUxhdExvbmcgcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KHRhcmdldDogTWFwTWFya2VyRGlyZWN0aXZlIHwgSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE1hcE1hcmtlckRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KHRhcmdldCkudGhlbigobTogTWFya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSBtLkxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHA6IFByb21pc2U8SVBvaW50PiA9IHRoaXMuX21hcFNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcFNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KHRhcmdldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGFuY2hvci5cbiAgICAgKiBBbmNob3IgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGFuY2hvciBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZUFuY2hvcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHtcbiAgICAgICAgICAgIG0uU2V0QW5jaG9yKG1hcmtlci5BbmNob3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSBkcmFnYWJpbGl0eS5cbiAgICAgKiBEcmFnYWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbWFya2VyIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVXBkYXRlRHJhZ2dhYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXREcmFnZ2FibGUobWFya2VyLkRyYWdnYWJsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIEljb24gb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBpY29uLiBJY29uIGluZm9ybWF0aW9uIGlzIHByZXNlbnRcbiAgICAgKiBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGljb24gaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBVcGRhdGVJY29uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlci5JY29uSW5mbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHg6IElNYXJrZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBsYXRpdHVkZTogbWFya2VyLkxhdGl0dWRlLCBsb25naXR1ZGU6IG1hcmtlci5Mb25naXR1ZGUgfSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkluZm86IG1hcmtlci5JY29uSW5mb1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMoeCk7XG4gICAgICAgICAgICAgICAgbS5TZXRJY29uKG8uaWNvbik7XG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoeC5pY29uSW5mbyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG0uU2V0SWNvbihtYXJrZXIuSWNvblVybCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBsYWJlbC5cbiAgICAgKiBMYWJlbCBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGFiZWwgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBVcGRhdGVMYWJlbChtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHsgbS5TZXRMYWJlbChtYXJrZXIuTGFiZWwpOyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICogQ29vcmRpbmF0ZSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgcG9zaXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBVcGRhdGVNYXJrZXJQb3NpdGlvbihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKFxuICAgICAgICAgICAgKG06IE1hcmtlcikgPT4gbS5TZXRQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IG1hcmtlci5MYXRpdHVkZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IG1hcmtlci5Mb25naXR1ZGVcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvbiB0aGUgbWFya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIHRpdGxlLlxuICAgICAqIFRpdGxlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB0aXRsZSBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZVRpdGxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXRUaXRsZShtYXJrZXIuVGl0bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2aXNpYmlsaXR5IG9uIHRoZSBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgdGl0bGUuXG4gICAgICogVGl0bGUgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHRpdGxlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVXBkYXRlVmlzaWJsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IG0uU2V0VmlzaWJsZShtYXJrZXIuVmlzaWJsZSkpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi9nb29nbGUtbWFya2VyJztcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9sYXllcic7XG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tYXJrZXInO1xuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcbmltcG9ydCB7IENsdXN0ZXJQbGFjZW1lbnRNb2RlIH0gZnJvbSAnLi4vY2x1c3Rlci1wbGFjZW1lbnQtbW9kZSc7XG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcyc7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlcmluZyBsYXllciBmb3IgdGhlIEdvb2dsZSBNYXAgUHJvdmlkZXIuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgR29vZ2xlTWFya2VyQ2x1c3RlcmVyIGltcGxlbWVudHMgTGF5ZXIge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX2lzQ2x1c3RlcmluZyA9IHRydWU7XG4gICAgcHJpdmF0ZSBfbWFya2VyTG9va3VwOiBNYXA8R29vZ2xlTWFwVHlwZXMuTWFya2VyLCBNYXJrZXI+ID0gbmV3IE1hcDxHb29nbGVNYXBUeXBlcy5NYXJrZXIsIE1hcmtlcj4oKTtcbiAgICBwcml2YXRlIF9tYXJrZXJzOiBBcnJheTxNYXJrZXI+ID0gbmV3IEFycmF5PE1hcmtlcj4oKTtcbiAgICBwcml2YXRlIF9wZW5kaW5nTWFya2VyczogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XG4gICAgcHJpdmF0ZSBfbWFwY2xpY2tzOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgX2N1cnJlbnRab29tOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLy8vXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hdGl2ZSBwcmltaXRpdmUgdW5kZXJuZWF0aCB0aGUgYWJzdHJhY3Rpb24gbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIENvbnN0cnVjdG9yXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBHb29nbGVNYXJrZXJDbHVzdGVyZXIgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2xheWVyIEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlci4gTmF0aXZlIEdvb2dsZSBNYXBzIE1hcmtlciBDbHVzdGVyZXIgc3VwcG9ydGluZyB0aGUgY2x1c3RlciBsYXllci5cbiAgICAgKiBAcGFyYW0gX21hcHMgTWFwU2VydmljZS4gTWFwU2VydmljZSBpbXBsZW1lbnRhdGlvbiB0byBsZXZlcmFnZSBmb3IgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xheWVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIpIHsgfVxuXG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHMsIExheWVyIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBzdHJpbmcuIFR5cGUgb2YgZXZlbnQgdG8gYWRkIChjbGljaywgbW91c2VvdmVyLCBldGMpLiBZb3UgY2FuIHVzZSBhbnkgZXZlbnQgdGhhdCB0aGUgdW5kZXJseWluZyBuYXRpdmVcbiAgICAgKiBsYXllciBzdXBwb3J0cy5cbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24uIEhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignRXZlbnRzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIEdvb2dsZSBDbHVzdGVyIExheWVycy4gWW91IGNhbiBzdGlsbCBhZGQgZXZlbnRzIHRvIGluZGl2aWR1YWwgbWFya2Vycy4nKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRpdHkgdG8gdGhlIGxheWVyLiBVc2UgdGhpcyBtZXRob2Qgd2l0aCBjYXV0aW9uIGFzIGl0IHdpbGxcbiAgICAgKiB0cmlnZ2VyIGEgcmVjYWx1YXRpb24gb2YgdGhlIGNsdXN0ZXJzIChhbmQgYXNzb2NpYXRlZCBtYXJrZXJzIGlmIGFwcHJvcHJpdGUpIGZvclxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gSWYgeW91IHVzZSB0aGlzIG1ldGhvZCB0byBhZGQgbWFueSBtYXJrZXJzIHRvIHRoZSBjbHVzdGVyLCB1c2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyLiBFbnRpdHkgdG8gYWRkIHRvIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgQWRkRW50aXR5KGVudGl0eTogTWFya2VyKTogdm9pZCB7XG4gICAgICAgIGxldCBpc01hcmtlcjogYm9vbGVhbiA9IGVudGl0eSBpbnN0YW5jZW9mIE1hcmtlcjtcbiAgICAgICAgaXNNYXJrZXIgPSBlbnRpdHkgaW5zdGFuY2VvZiBHb29nbGVNYXJrZXIgfHwgaXNNYXJrZXI7XG4gICAgICAgIGlmIChpc01hcmtlcikge1xuICAgICAgICAgICAgZW50aXR5Lk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXG4gICAgICAgICAgICBpZiAoZW50aXR5LklzRmlyc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0b3BDbHVzdGVyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudGl0eS5OYXRpdmVQcmltaXR2ZSAmJiBlbnRpdHkuTG9jYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcgJiYgdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLmFkZE1hcmtlcihlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLnNldChlbnRpdHkuTmF0aXZlUHJpbWl0dmUsIGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5LklzTGFzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhcnRDbHVzdGVyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIG1hcmtlcnMgdG8gdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj4uIEVudGl0aWVzIHRvIGFkZCB0byB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIEFkZEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+KTogdm9pZCB7XG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcbiAgICAgICAgICAgIGNvbnN0IGU6IEFycmF5PEdvb2dsZU1hcFR5cGVzLk1hcmtlcj4gPSBlbnRpdGllcy5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLnNldChwLk5hdGl2ZVByaW1pdHZlLCBwKTtcbiAgICAgICAgICAgICAgICBwLk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgbWFwIGFzIHRoZSBjbHVzdGVyZXIgd2lsbCBjb250cm9sIG1hcmtlciB2aXNpYmlsaXR5LlxuICAgICAgICAgICAgICAgIHJldHVybiBwLk5hdGl2ZVByaW1pdHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nICYmIHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5hZGRNYXJrZXJzKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBsYXllciBpcyBub3QgdmlzaWJsZSwgYWx3YXlzIGFkZCB0byBwZW5kaW5nTWFya2Vycy4gU2V0dGluZyB0aGUgbGF5ZXIgdG8gdmlzaWJsZSBsYXRlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmVuZGVyIHRoZSBtYXJrZXJzIGFwcHJvcHJpYXRlbHlcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5wdXNoKC4uLmVudGl0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGNsdXN0ZXJpbmcgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbGF5ZXIuZ2V0TWFya2VycygpLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgICBtLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sYXllci5jbGVhck1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zcGxpY2UoMCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLnNwbGljZSgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBtYXJrZXIgdXNlZCB0byB3cmFwIHRoZSBHb29nbGUgTWFya2VyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTWFya2VyLiBUaGUgYWJzdHJhY3QgbWFya2VyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHB1c2hwaW4uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIEdldE1hcmtlckZyb21Hb29nbGVNYXJrZXIocGluOiBHb29nbGVNYXBUeXBlcy5NYXJrZXIpOiBNYXJrZXIge1xuICAgICAgICBjb25zdCBtOiBNYXJrZXIgPSB0aGlzLl9tYXJrZXJMb29rdXAuZ2V0KHBpbik7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9wdGlvbnMgZ292ZXJuaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJQ2x1c3Rlck9wdGlvbnMuIFRoZSBsYXllciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRPcHRpb25zKCk6IElDbHVzdGVyT3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgZ3JpZFNpemU6IHRoaXMuX2xheWVyLmdldEdyaWRTaXplKCksXG4gICAgICAgICAgICBjbHVzdGVyaW5nRW5hYmxlZDogdGhpcy5fbGF5ZXIuZ2V0R3JpZFNpemUoKSA9PT0gMCxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMuX2xheWVyLmdldE1heFpvb20oKSxcbiAgICAgICAgICAgIG1pbmltdW1DbHVzdGVyU2l6ZTogdGhpcy5fbGF5ZXIuZ2V0TWluQ2x1c3RlclNpemUoKSxcbiAgICAgICAgICAgIHBsYWNlbWVudE1vZGU6IHRoaXMuX2xheWVyLmlzQXZlcmFnZUNlbnRlcigpID8gQ2x1c3RlclBsYWNlbWVudE1vZGUuTWVhblZhbHVlIDogQ2x1c3RlclBsYWNlbWVudE1vZGUuRmlyc3RQaW4sXG4gICAgICAgICAgICB2aXNpYmxlOiB0aGlzLl92aXNpYmxlLFxuICAgICAgICAgICAgem9vbU9uQ2xpY2s6IHRoaXMuX2xheWVyLmlzWm9vbU9uQ2xpY2soKSxcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5fbGF5ZXIuZ2V0U3R5bGVzKClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuLiBUcnVlIGlzIHRoZSBsYXllciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlciBFbnRpdHkgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgUmVtb3ZlRW50aXR5KGVudGl0eTogTWFya2VyKTogdm9pZCB7XG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBqOiBudW1iZXIgPSB0aGlzLl9tYXJrZXJzLmluZGV4T2YoZW50aXR5KTtcbiAgICAgICAgICAgIGNvbnN0IGs6IG51bWJlciA9IHRoaXMuX3BlbmRpbmdNYXJrZXJzLmluZGV4T2YoZW50aXR5KTtcbiAgICAgICAgICAgIGlmIChqID4gLTEpIHsgdGhpcy5fbWFya2Vycy5zcGxpY2UoaiwgMSk7IH1cbiAgICAgICAgICAgIGlmIChrID4gLTEpIHsgdGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKGssIDEpOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDbHVzdGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVtb3ZlTWFya2VyKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuZGVsZXRlKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPiBjb250YWluaW5nXG4gICAgICogdGhlIGVudGl0aWVzIHRvIGFkZCB0byB0aGUgY2x1c3Rlci4gVGhpcyByZXBsYWNlcyBhbnkgZXhpc3RpbmcgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2xheWVyLmdldE1hcmtlcnMoKS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgbS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sYXllci5jbGVhck1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zcGxpY2UoMCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLnNwbGljZSgwKTtcbiAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmNsZWFyKCk7XG5cbiAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+KCk7XG4gICAgICAgIGVudGl0aWVzLmZvckVhY2goKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGUuTmF0aXZlUHJpbWl0dmUuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQoZS5OYXRpdmVQcmltaXR2ZSwgZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFya2Vycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2goZS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVyLmFkZE1hcmtlcnMocCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJQ2x1c3Rlck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXG4gICAgICogYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0L2V4aXN0aW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgICAgIGlmIChvcHRpb25zLnBsYWNlbWVudE1vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdHb29nbGVNYXJrZXJDbHVzdGVyZXI6IFBsYWNlbWVudE1vZGUgb3B0aW9uIGNhbm5vdCBiZSBzZXQgYWZ0ZXIgaW5pdGlhbCBjcmVhdGlvbi4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuem9vbU9uQ2xpY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdHb29nbGVNYXJrZXJDbHVzdGVyZXI6IFpvb21PbkNsaWNrIG9wdGlvbiBjYW5ub3QgYmUgc2V0IGFmdGVyIGluaXRpYWwgY3JlYXRpb24uJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrICE9IG51bGwpIHt9XG4gICAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldE1pbkNsdXN0ZXJTaXplKG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQgPyAxIDogMTAwMDAwMDApO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVzZXRWaWV3cG9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZ3JpZFNpemUgIT0gbnVsbCAmJiAob3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCA9PSBudWxsIHx8IG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllci5zZXRHcmlkU2l6ZShvcHRpb25zLmdyaWRTaXplKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlc2V0Vmlld3BvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRNYXhab29tKG9wdGlvbnMubWF4Wm9vbSk7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWluaW11bUNsdXN0ZXJTaXplICE9IG51bGwpIHsgdGhpcy5fbGF5ZXIuc2V0TWluQ2x1c3RlclNpemUob3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUpOyB9XG4gICAgICAgIGlmIChvcHRpb25zLnN0eWxlcyAhPSBudWxsKSB7IHRoaXMuX2xheWVyLnNldFN0eWxlcyhvcHRpb25zLnN0eWxlcyk7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsKSB7IHRoaXMuU2V0VmlzaWJsZShvcHRpb25zLnZpc2libGUpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY2x1c3RlciBsYXllciB2aXNpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgPSB2aXNpYmxlID8gdGhpcy5fbGF5ZXIuZ2V0TWFwKCkgOiBudWxsO1xuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlc2V0Vmlld3BvcnQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLk1hcmtlcj4oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5wdXNoKDxHb29nbGVNYXBUeXBlcy5NYXJrZXI+ZS5OYXRpdmVQcmltaXR2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5hZGRNYXJrZXJzKHApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLmNvbmNhdCh0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdG8gYWN0dWFsbHkgY2x1c3RlciB0aGUgZW50aXRpZXMgaW4gYSBjbHVzdGVyIGxheWVyLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBpbml0aWFsIHNldCBvZiBlbnRpdGllc1xuICAgICAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcbiAgICAgKiBjb21wbGV0ZSB0byByZWNhbGN1bGF0ZSB0aGUgY2x1c3RlcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIFN0YXJ0Q2x1c3RlcmluZygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+KCk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2goPEdvb2dsZU1hcFR5cGVzLk1hcmtlcj5lLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2goPEdvb2dsZU1hcFR5cGVzLk1hcmtlcj5lLk5hdGl2ZVByaW1pdHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLmFkZE1hcmtlcnMocCk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzID0gdGhpcy5fbWFya2Vycy5jb25jYXQodGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gb25seSBhZGQgdGhlIG1hcmtlcnMgaWYgdGhlIGxheWVyIGlzIHZpc2libGUuIE90aGVyd2lzZSwga2VlcCB0aGVtIHBlbmRpbmcuIFRoZXkgd291bGQgYmUgYWRkZWQgb25jZSB0aGVcbiAgICAgICAgICAgIC8vIGxheWVyIGlzIHNldCB0byB2aXNpYmxlLlxuICAgICAgICAgICAgdGltZXIoMCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllci5yZXNldFZpZXdwb3J0KHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNDbHVzdGVyaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGFzIGFkZGluZyBhbiBlbnRpdGl5IHdpbGwgcmVjYWxjdWxhdGUgYWxsIGNsdXN0ZXJzLlxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXG4gICAgICovXG4gICAgcHVibGljIFN0b3BDbHVzdGVyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5faXNDbHVzdGVyaW5nID0gZmFsc2U7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgR29vZ2xlTWFya2VyQ2x1c3RlcmVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyLWNsdXN0ZXJlcic7XG5pbXBvcnQgeyBHb29nbGVJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtaW5mby13aW5kb3cnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcEFQSUxvYWRlciB9IGZyb20gJy4uL21hcGFwaWxvYWRlcic7XG5pbXBvcnQgeyBHb29nbGVNYXBBUElMb2FkZXIsIEdvb2dsZU1hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vZ29vZ2xlLW1hcC1hcGktbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1jbHVzdGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xuaW1wb3J0IHsgTWFwVHlwZUlkIH0gZnJvbSAnLi4vLi4vbW9kZWxzL21hcC10eXBlLWlkJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlsaW5lJztcbmltcG9ydCB7IE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYWJlbCc7XG5pbXBvcnQgeyBNaXhpbkNhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1jYW52YXMtb3ZlcmxheSc7XG5pbXBvcnQgeyBHb29nbGVDYW52YXNPdmVybGF5IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtY2FudmFzLW92ZXJsYXknO1xuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2luZm8td2luZG93JztcbmltcG9ydCB7IEdvb2dsZVBvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uJztcbmltcG9ydCB7IEdvb2dsZVBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWxpbmUnO1xuaW1wb3J0IHsgR29vZ2xlQ29udmVyc2lvbnMgfSBmcm9tICcuL2dvb2dsZS1jb252ZXJzaW9ucyc7XG5pbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXInO1xuaW1wb3J0IHsgR29vZ2xlTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYXllcic7XG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pYm94JztcbmltcG9ydCB7IEdvb2dsZU1hcEV2ZW50c0xvb2t1cCB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWV2ZW50cy1sb29rdXAnO1xuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi9nb29nbGUtbWFwLXR5cGVzJztcblxuZGVjbGFyZSBjb25zdCBnb29nbGU6IGFueTtcbmRlY2xhcmUgY29uc3QgTWFya2VyQ2x1c3RlcmVyOiBhbnk7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE1hcFNlcnZpY2UgYWJzdHJhY3QgaW1wbGVtZW50aW5nIGEgR29vZ2xlIE1hcHMgcHJvdmlkZXJcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBTZXJ2aWNlIGltcGxlbWVudHMgTWFwU2VydmljZSB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgRGVjbGFyYXRpb25zXG4gICAgLy8vXG5cbiAgICBwcml2YXRlIF9tYXA6IFByb21pc2U8R29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwPjtcbiAgICBwcml2YXRlIF9tYXBJbnN0YW5jZTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwO1xuICAgIHByaXZhdGUgX21hcFJlc29sdmVyOiAodmFsdWU/OiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBfY29uZmlnOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWc7XG5cbiAgICAvLy9cbiAgICAvLy8gUHJvcGVydHkgRGVmaW5pdGlvbnNcbiAgICAvLy9cblxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgR29vZ2xlIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWFwSW5zdGFuY2UoKTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwIHsgcmV0dXJuIHRoaXMuX21hcEluc3RhbmNlOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgUHJvbWlzZSBmb3IgYSBHb29nbGUgTWFwIGNvbnRyb2wgaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgaW1wbGVtZW50YXRpb24uIFVzZSB0aGlzIGluc3RlYWQgb2Yge0BsaW5rIE1hcEluc3RhbmNlfSBpZiB5b3VcbiAgICAgKiBhcmUgbm90IHN1cmUgaWYgYW5kIHdoZW4gdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgTWFwUHJvbWlzZSgpOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4geyByZXR1cm4gdGhpcy5fbWFwOyB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXBzIHBoeXNpY2FsIHNpemUuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IE1hcFNpemUoKTogSVNpemUge1xuICAgICAgICBpZiAodGhpcy5NYXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZWw6IEhUTUxEaXZFbGVtZW50ID0gdGhpcy5NYXBJbnN0YW5jZS5nZXREaXYoKTtcbiAgICAgICAgICAgIGNvbnN0IHM6IElTaXplID0geyB3aWR0aDogZWwub2Zmc2V0V2lkdGgsIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0IH07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlTWFwU2VydmljZS5cbiAgICAgKiBAcGFyYW0gX2xvYWRlciBNYXBBUElMb2FkZXIgaW5zdGFuY2UgaW1wbGVtZW50ZWQgZm9yIEdvb2dsZSBNYXBzLiBUaGlzIGluc3RhbmNlIHdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxuICAgICAqIEBwYXJhbSBfem9uZSBOZ1pvbmUgb2JqZWN0IHRvIGVuYWJsZSB6b25lIGF3YXJlIHByb21pc2VzLiBUaGlzIHdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IE1hcEFQSUxvYWRlciwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4oXG4gICAgICAgICAgICAocmVzb2x2ZTogKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB2b2lkKSA9PiB7IHRoaXMuX21hcFJlc29sdmVyID0gcmVzb2x2ZTsgfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9jb25maWcgPSAoPEdvb2dsZU1hcEFQSUxvYWRlcj50aGlzLl9sb2FkZXIpLkNvbmZpZztcbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gUHVibGljIG1ldGhvZHMgYW5kIE1hcFNlcnZpY2UgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzIG92ZXJsYXkgbGF5ZXIgdG8gcGVyZm9ybSBjdXN0b20gZHJhd2luZyBvdmVyIHRoZSBtYXAgd2l0aCBvdXRcbiAgICAgKiBzb21lIG9mIHRoZSBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggZ29pbmcgdGhyb3VnaCB0aGUgTWFwIG9iamVjdHMuXG4gICAgICogQHBhcmFtIGRyYXdDYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZVxuICAgICAqIHJlbmRlcmVkIGZvciB0aGUgY3VycmVudCBtYXAgdmlldy5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgQ2FudmFzT3ZlcmxheX0gb2JqZWN0LlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5OiBHb29nbGVDYW52YXNPdmVybGF5ID0gbmV3IEdvb2dsZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrKTtcbiAgICAgICAgICAgIG92ZXJsYXkuU2V0TWFwKG1hcCk7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIG1hcCBjbHVzdGVyIGxheWVyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElDbHVzdGVyT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIExheWVyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlckxheWVyKG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZU9wdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlckNsdXN0ZXJlcjogR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyID0gbmV3IE1hcmtlckNsdXN0ZXJlcihtYXAsIFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJMYXllciA9IG5ldyBHb29nbGVNYXJrZXJDbHVzdGVyZXIobWFya2VyQ2x1c3RlcmVyKTtcbiAgICAgICAgICAgIGNvbnN0IG86IElDbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBpZDogb3B0aW9ucy5pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgby52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBvLmNsdXN0ZXJpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJMYXllci5TZXRPcHRpb25zKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXJMYXllcjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZvcm1hdGlvbiB3aW5kb3cgZm9yIGEgbWFwIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgSW5mb1dpbmRvd30gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgTWljcm9zb2Z0Lk1hcHMuSW5mb2JveCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVJbmZvV2luZG93KG9wdGlvbnM/OiBJSW5mb1dpbmRvd09wdGlvbnMpOiBQcm9taXNlPEdvb2dsZUluZm9XaW5kb3c+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvd09wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVJbmZvV2luZG93T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9XaW5kb3c6IEdvb2dsZU1hcFR5cGVzLkluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhvKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlSW5mb1dpbmRvdyhpbmZvV2luZG93LCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBsYXllciB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci4gU2VlIHtAbGluayBJTGF5ZXJPcHRpb25zfVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBMYXllcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlTGF5ZXIob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlTGF5ZXIobWFwLCB0aGlzLCBvcHRpb25zLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cbiAgICAgKiBAcGFyYW0gbWFwT3B0aW9ucyAtIE1hcCBvcHRpb25zXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgbWFwIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVNYXAoZWw6IEhUTUxFbGVtZW50LCBtYXBPcHRpb25zOiBJTWFwT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLkxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGx5IG1peGluc1xuICAgICAgICAgICAgTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldygpO1xuICAgICAgICAgICAgTWl4aW5DYW52YXNPdmVybGF5KCk7XG5cbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgbWFwIHN0YXJ0dXBcbiAgICAgICAgICAgIGlmICghbWFwT3B0aW9ucy5tYXBUeXBlSWQgPT0gbnVsbCkgeyBtYXBPcHRpb25zLm1hcFR5cGVJZCA9IE1hcFR5cGVJZC5oeWJyaWQ7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXBJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5EaXNwb3NlTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXBPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlT3B0aW9ucyhtYXBPcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChlbCwgbyk7XG4gICAgICAgICAgICBpZiAobWFwT3B0aW9ucy5ib3VuZHMpIHtcbiAgICAgICAgICAgICAgICBtYXAuZml0Qm91bmRzKEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUJvdW5kcyhtYXBPcHRpb25zLmJvdW5kcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UgPSBtYXA7XG4gICAgICAgICAgICB0aGlzLl9tYXBSZXNvbHZlcihtYXApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIG1hcCBtYXJrZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxuICAgICAqXG4gICAgICogQHBhcmFtIFtvcHRpb25zPTxJTWFya2VyT3B0aW9ucz57fV0gLSBPcHRpb25zIGZvciB0aGUgbWFya2VyLiBTZWUge0BsaW5rIElNYXJrZXJPcHRpb25zfS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTWFya2VyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5QdXNoUGluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyA9IDxJTWFya2VyT3B0aW9ucz57fSk6IFByb21pc2U8TWFya2VyPiB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAoeDogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucywgbWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApOiBHb29nbGVNYXJrZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih4KTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgR29vZ2xlTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICBtLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XG4gICAgICAgICAgICBtLklzTGFzdCA9IG9wdGlvbnMuaXNMYXN0O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2YWw6IGFueSwga2V5OiBzdHJpbmcpID0+IG0uTWV0YWRhdGEuc2V0KGtleSwgdmFsKSk7IH1cbiAgICAgICAgICAgIG1hcmtlci5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmljb25JbmZvICYmIG9wdGlvbnMuaWNvbkluZm8ubWFya2VyVHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG9wdGlvbnMuaWNvbkluZm8pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkKG8sIG1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy50aGVuKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5pY29uID0geC5pY29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobywgbWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobywgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBvbHlnb24gd2l0aGluIHRoZSBHb29nbGUgTWFwIG1hcCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBwb2x5Z29uLiBTZWUge0BsaW5rIElQb2x5Z29uT3B0aW9uc30uXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlnb259IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5Z29uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvbihvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBQcm9taXNlPFBvbHlnb24+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb246IEdvb2dsZU1hcFR5cGVzLlBvbHlnb24gPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWdvbihvKTtcbiAgICAgICAgICAgIHBvbHlnb24uc2V0TWFwKG1hcCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHA6IEdvb2dsZVBvbHlnb24gPSBuZXcgR29vZ2xlUG9seWdvbihwb2x5Z29uKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBwLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0xhYmVsICE9IG51bGwpIHsgcC5TaG93TGFiZWwgPSBvcHRpb25zLnNob3dMYWJlbDsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcC5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNaW5ab29tICE9IG51bGwpIHsgcC5MYWJlbE1pblpvb20gPSBvcHRpb25zLmxhYmVsTWluWm9vbTsgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwb2x5bGluZSB3aXRoaW4gdGhlIEdvb2dsZSBNYXAgbWFwIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHBvbHlsaW5lLiBTZWUge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9LlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBQb2x5bGluZX0gb2JqZWN0IChvciBhbiBhcnJheSB0aGVyZWZvcmUgZm9yIGNvbXBsZXggcGF0aHMpXG4gICAgICogd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5bGluZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xuICAgICAgICBsZXQgcG9seWxpbmU6IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aFswXSkpIHtcbiAgICAgICAgICAgICAgICBvLnBhdGggPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpWzBdO1xuICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG8pO1xuICAgICAgICAgICAgICAgIHBvbHlsaW5lLnNldE1hcChtYXApO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGwgPSBuZXcgR29vZ2xlUG9seWxpbmUocG9seWxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBwbC5NZXRhZGF0YS5zZXQoa2V5LCB2YWwpKTsgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7IHBsLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcGwuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aHM6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMob3B0aW9ucy5wYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lczogQXJyYXk8UG9seWxpbmU+ID0gbmV3IEFycmF5PFBvbHlsaW5lPigpO1xuICAgICAgICAgICAgICAgIHBhdGhzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG8ucGF0aCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG8pO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bGluZS5zZXRNYXAobWFwKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbCA9IG5ldyBHb29nbGVQb2x5bGluZShwb2x5bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBwbC5NZXRhZGF0YS5zZXQoa2V5LCB2YWwpKTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwbC5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwbC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChwbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVyIC0gTGF5ZXIgdG8gZGVsZXRlLiBTZWUge0BsaW5rIExheWVyfS4gVGhpcyBtZXRob2QgZXhwZWN0cyB0aGUgR29vZ2xlIHNwZWNpZmljIExheWVyIG1vZGVsIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIHdoZW4gdGhlIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTGF5ZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gcmV0dXJuIHJlc29sdmVkIHByb21pc2UgYXMgdGhlcmUgaXMgbm8gY29uZXB0IG9mIGEgY3VzdG9tIGxheWVyIGluIEdvb2dsZS5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3Bhb3NlIHRoZSBtYXAgYW5kIGFzc29jaWF0ZWQgcmVzb3VyZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBEaXNwb3NlTWFwKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fbWFwID09IG51bGwgJiYgdGhpcy5fbWFwSW5zdGFuY2UgPT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKHRoaXMuX21hcEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgbWFwIGNlbnRlclxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGdvZSBsb2NhdGlvbiBvZiB0aGUgY2VudGVyLiBTZWUge0BsaW5rIElMYXRMb25nfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEdldENlbnRlcigpOiBQcm9taXNlPElMYXRMb25nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlcjogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgcmV0dXJuIDxJTGF0TG9uZz57XG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGNlbnRlci5sYXQoKSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGNlbnRlci5sbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXAgYm91bmRpbmcgYm94XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ2VvIGxvY2F0aW9uIG9mIHRoZSBib3VuZGluZyBib3guIFNlZSB7QGxpbmsgSUJveH0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRCb3VuZHMoKTogUHJvbWlzZTxJQm94PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiA8SUJveD57XG4gICAgICAgICAgICAgICAgbWF4TGF0aXR1ZGU6IGJveC5nZXROb3J0aEVhc3QoKS5sYXQoKSxcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IE1hdGgubWF4KGJveC5nZXROb3J0aEVhc3QoKS5sbmcoKSwgYm94LmdldFNvdXRoV2VzdCgpLmxuZygpKSxcbiAgICAgICAgICAgICAgICBtaW5MYXRpdHVkZTogYm94LmdldFNvdXRoV2VzdCgpLmxhdCgpLFxuICAgICAgICAgICAgICAgIG1pbkxvbmdpdHVkZTogTWF0aC5taW4oYm94LmdldE5vcnRoRWFzdCgpLmxuZygpLCBib3guZ2V0U291dGhXZXN0KCkubG5nKCkpLFxuICAgICAgICAgICAgICAgIGNlbnRlcjogeyBsYXRpdHVkZTogYm94LmdldENlbnRlcigpLmxhdCgpLCBsb25naXR1ZGU6IGJveC5nZXRDZW50ZXIoKS5sbmcoKSB9LFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHpvb20gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRab29tKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IG1hcC5nZXRab29tKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLiBUaGlzIHByb21pc2UgcmVzb2x2ZXMgdG8gbnVsbFxuICAgICAqIGlmIHRoZSBnb2UgY29vcmRpbmF0ZXMgYXJlIG5vdCBpbiB0aGUgdmlldyBwb3J0LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KGxvYzogSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNyb3NzZXNEYXRlTGluZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobG9jKTtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBtLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHM6IG51bWJlciA9IE1hdGgucG93KDIsIG0uZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGI6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0JvdW5kcyA9IG0uZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBpZiAoYi5nZXRDZW50ZXIoKS5sbmcoKSA8IGIuZ2V0U291dGhXZXN0KCkubG5nKCkgIHx8XG4gICAgICAgICAgICAgICAgYi5nZXRDZW50ZXIoKS5sbmcoKSA+IGIuZ2V0Tm9ydGhFYXN0KCkubG5nKCkpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxuXG5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFk6IG51bWJlciA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoYi5nZXROb3J0aEVhc3QoKSkueTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFg6IG51bWJlciA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoYi5nZXRTb3V0aFdlc3QoKSkueDtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHAuZnJvbUxhdExuZ1RvUG9pbnQobCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoKHBvaW50LnggLSBvZmZzZXRYICsgKChjcm9zc2VzRGF0ZUxpbmUgJiYgcG9pbnQueCA8IG9mZnNldFgpID8gMjU2IDogMCkpICogcyksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcigocG9pbnQueSAtIG9mZnNldFkpICogcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIExvY2F0aW9uc1RvUG9pbnRzKGxvY3M6IEFycmF5PElMYXRMb25nPik6IFByb21pc2U8QXJyYXk8SVBvaW50Pj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNyb3NzZXNEYXRlTGluZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcCA9IG0uZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgczogbnVtYmVyID0gTWF0aC5wb3coMiwgbS5nZXRab29tKCkpO1xuICAgICAgICAgICAgY29uc3QgYjogR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzID0gbS5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGlmIChiLmdldENlbnRlcigpLmxuZygpIDwgYi5nZXRTb3V0aFdlc3QoKS5sbmcoKSAgfHxcbiAgICAgICAgICAgICAgICBiLmdldENlbnRlcigpLmxuZygpID4gYi5nZXROb3J0aEVhc3QoKS5sbmcoKSkgeyBjcm9zc2VzRGF0ZUxpbmUgPSB0cnVlOyB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFg6IG51bWJlciA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoYi5nZXRTb3V0aFdlc3QoKSkueDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFk6IG51bWJlciA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoYi5nZXROb3J0aEVhc3QoKSkueTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBsb2NzLm1hcChsbCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbDE6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludDogR29vZ2xlTWFwVHlwZXMuUG9pbnQgPSBwLmZyb21MYXRMbmdUb1BvaW50KGwxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKChwb2ludC54IC0gb2Zmc2V0WCArICgoY3Jvc3Nlc0RhdGVMaW5lICYmIHBvaW50LnggPCBvZmZzZXRYKSA/IDI1NiA6IDApKSAqIHMpLFxuICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLmZsb29yKChwb2ludC55IC0gb2Zmc2V0WSkgKiBzKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIHRoZSBtYXAgb24gYSBnZW8gbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvQ29vcmRpbmF0ZXMgYXJvdW5kIHdoaWNoIHRvIGNlbnRlciB0aGUgbWFwLiBTZWUge0BsaW5rIElMYXRMb25nfVxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgY2VudGVyIG9wZXJhdGlvbnMgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VudGVyOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdChsYXRMbmcpO1xuICAgICAgICAgICAgbWFwLnNldENlbnRlcihjZW50ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnZW5lcmljIG1hcCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFNldE1hcE9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBtLnNldE9wdGlvbnMobyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpZXcgb3B0aW9ucyBvZiB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFNldFZpZXdPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJvdW5kcykge1xuICAgICAgICAgICAgICAgIG0uZml0Qm91bmRzKEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUJvdW5kcyhvcHRpb25zLmJvdW5kcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBtLnNldE9wdGlvbnMobyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB6b29tIC0gWm9vbSBsZXZlbCB0byBzZXQuXG4gICAgICogQHJldHVybnMgLSBBIFByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIG9uY2UgdGhlIHpvb20gb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0Wm9vbSh6b29tOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4gbWFwLnNldFpvb20oem9vbSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgc3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChlLmcuICdjbGljaycpXG4gICAgICogQHJldHVybnMgLSBBbiBvYnNlcnZhYmxlIG9mIHR5cGUgRSB0aGF0IGZpcmVzIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFN1YnNjcmliZVRvTWFwRXZlbnQ8RT4oZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEU+IHtcbiAgICAgICAgY29uc3QgZ29vZ2xlRXZlbnROYW1lOiBzdHJpbmcgPSBHb29nbGVNYXBFdmVudHNMb29rdXBbZXZlbnROYW1lXTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGdvb2dsZUV2ZW50TmFtZSwgKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIEV2ZW50IHRvIHRyaWdnZXIuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFRyaWdnZXJNYXBFdmVudChldmVudE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG0pID0+IGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobSwgZXZlbnROYW1lLCBudWxsKSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWdvbic7XG5pbXBvcnQgeyBNYXBQb2x5Z29uRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtcG9seWdvbic7XG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4uL3BvbHlnb24uc2VydmljZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XG4vKipcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBQb2x5Z29uIFNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEdvb2dsZSBNYXBzLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlnb25TZXJ2aWNlIGltcGxlbWVudHMgUG9seWdvblNlcnZpY2Uge1xuXG4gICAgLy8vXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xuICAgIC8vL1xuICAgIHByaXZhdGUgX3BvbHlnb25zOiBNYXA8TWFwUG9seWdvbkRpcmVjdGl2ZSwgUHJvbWlzZTxQb2x5Z29uPj4gPSBuZXcgTWFwPE1hcFBvbHlnb25EaXJlY3RpdmUsIFByb21pc2U8UG9seWdvbj4+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlUG9seWdvblNlcnZpY2UuXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0ge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLiBUaGUgY29uY3JldGUge0BsaW5rIEdvb2dsZU1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0ge0BsaW5rIEdvb2dsZUxheWVyU2VydmljZX0gaW5zdGFuY2UuXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBpbnN0YW5jZSB0byBzdXBwb3J0IHpvbmUgYXdhcmUgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZW1iZXJzIGFuZCBNYXJrZXJTZXJ2aWNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5Z29uIGNvbnRleHQsIHRoZSBwb2x5Z29uIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxuICAgICAqIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEFkZFBvbHlnb24ocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBJUG9seWdvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpZDogcG9seWdvbi5JZCxcbiAgICAgICAgICAgIGNsaWNrYWJsZTogcG9seWdvbi5DbGlja2FibGUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHBvbHlnb24uRHJhZ2dhYmxlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHBvbHlnb24uRWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHBvbHlnb24uRmlsbENvbG9yLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHBvbHlnb24uRmlsbE9wYWNpdHksXG4gICAgICAgICAgICBnZW9kZXNpYzogcG9seWdvbi5HZW9kZXNpYyxcbiAgICAgICAgICAgIGxhYmVsTWF4Wm9vbTogcG9seWdvbi5MYWJlbE1heFpvb20sXG4gICAgICAgICAgICBsYWJlbE1pblpvb206IHBvbHlnb24uTGFiZWxNaW5ab29tLFxuICAgICAgICAgICAgcGF0aHM6IHBvbHlnb24uUGF0aHMsXG4gICAgICAgICAgICBzaG93TGFiZWw6IHBvbHlnb24uU2hvd0xhYmVsLFxuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IHBvbHlnb24uU2hvd1Rvb2x0aXAsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcG9seWdvbi5TdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBvbHlnb24uU3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogcG9seWdvbi5TdHJva2VXZWlnaHQsXG4gICAgICAgICAgICB0aXRsZTogcG9seWdvbi5UaXRsZSxcbiAgICAgICAgICAgIHZpc2libGU6IHBvbHlnb24uVmlzaWJsZSxcbiAgICAgICAgICAgIHpJbmRleDogcG9seWdvbi56SW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvbHlnb25Qcm9taXNlOiBQcm9taXNlPFBvbHlnb24+ID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVQb2x5Z29uKG8pO1xuICAgICAgICB0aGlzLl9wb2x5Z29ucy5zZXQocG9seWdvbiwgcG9seWdvblByb21pc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgcG9seWdvbi5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxuICAgICAgKiBAcGFyYW0gcG9seWdvbiAtIFRoZSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cbiAgICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgICpcbiAgICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXG4gICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKS50aGVuKChwOiBQb2x5Z29uKSA9PiB7XG4gICAgICAgICAgICAgICAgcC5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIERlbGV0ZXMgYSBwb2x5Z29uLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSBkZWxldGVkLlxuICAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgICpcbiAgICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXG4gICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oKGw6IFBvbHlnb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbC5EZWxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5Z29ucy5kZWxldGUocG9seWdvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIHBvbHlnb24gb24gdGhlIGNsaWNrIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50IHwgYW55KTogSUxhdExvbmcge1xuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sYXRMbmcubGF0KCksIGxvbmdpdHVkZTogZS5sYXRMbmcubG5nKCkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBwb2x5Z29uIG1vZGVsIGZvciB0aGUgcG9seWdvbiBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIHBvbHlnb24gbW9kZWwuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5Z29ufSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXROYXRpdmVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPFBvbHlnb24+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlnb25PcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqIG9wdGlvbnMgYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBTZXRPcHRpb25zKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pLnRoZW4oKGw6IFBvbHlnb24pID0+IHsgbC5TZXRPcHRpb25zKG9wdGlvbnMpOyB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBQb2x5Z29uIHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgVXBkYXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbik7XG4gICAgICAgIGlmIChtID09IG51bGwgfHwgcG9seWdvbi5QYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHMpIHx8IHBvbHlnb24uUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9seWdvbi5QYXRoc1swXSkpIHtcbiAgICAgICAgICAgICAgICBsLlNldFBhdGhzKHBvbHlnb24uUGF0aHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbC5TZXRQYXRoKDxBcnJheTxJTGF0TG9uZz4+cG9seWdvbi5QYXRocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlsaW5lJztcbmltcG9ydCB7IE1hcFBvbHlsaW5lRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtcG9seWxpbmUnO1xuaW1wb3J0IHsgUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWxpbmUuc2VydmljZSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XG5cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlsaW5lIFNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEdvb2dsZSBNYXBzLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlsaW5lU2VydmljZSBpbXBsZW1lbnRzIFBvbHlsaW5lU2VydmljZSB7XG5cbiAgICAvLy9cbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXG4gICAgLy8vXG4gICAgcHJpdmF0ZSBfcG9seWxpbmVzOiBNYXA8TWFwUG9seWxpbmVEaXJlY3RpdmUsIFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4gPVxuICAgICAgICBuZXcgTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+KCk7XG5cbiAgICAvLy9cbiAgICAvLy8gQ29uc3RydWN0b3JcbiAgICAvLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS4gVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gc3VwcG9ydCB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLy8vXG4gICAgLy8vIFB1YmxpYyBtZW1iZXJzIGFuZCBNYXJrZXJTZXJ2aWNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWxpbmUgY29udGV4dCwgdGhlIHBvbHlsaW5lIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxuICAgICAqIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIEFkZFBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvOiBJUG9seWxpbmVPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IHBvbHlsaW5lLklkLFxuICAgICAgICAgICAgY2xpY2thYmxlOiBwb2x5bGluZS5DbGlja2FibGUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHBvbHlsaW5lLkRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwb2x5bGluZS5FZGl0YWJsZSxcbiAgICAgICAgICAgIGdlb2Rlc2ljOiBwb2x5bGluZS5HZW9kZXNpYyxcbiAgICAgICAgICAgIHBhdGg6IHBvbHlsaW5lLlBhdGgsXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogcG9seWxpbmUuU2hvd1Rvb2x0aXAsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcG9seWxpbmUuU3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBwb2x5bGluZS5TdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwb2x5bGluZS5TdHJva2VXZWlnaHQsXG4gICAgICAgICAgICB0aXRsZTogcG9seWxpbmUuVGl0bGUsXG4gICAgICAgICAgICB2aXNpYmxlOiBwb2x5bGluZS5WaXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBwb2x5bGluZS56SW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvbHlsaW5lUHJvbWlzZTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+ID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVQb2x5bGluZShvKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChwb2x5bGluZSwgcG9seWxpbmVQcm9taXNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhIGxpbmUuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcbiAgICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cbiAgICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgICpcbiAgICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxuICAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpLnRoZW4ocCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShwKSA/IHAgOiBbcF07XG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGxpbmUgPT4gbGluZS5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBEZWxldGVzIGEgcG9seWxpbmUuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cbiAgICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5bGluZSBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAgKlxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXG4gICAgICAqL1xuICAgIHB1YmxpYyBEZWxldGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihsID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGxpbmUgPT4gIGxpbmUuRGVsZXRlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5kZWxldGUocG9seWxpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBsaW5lIG9uIHRoZSBjbGljayBsb2NhdGlvblxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBsaW5lLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXRDb29yZGluYXRlc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50IHwgYW55KTogSUxhdExvbmcge1xuICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZS5sYXRMbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIHBvbHlsaW5lIG1vZGVsIGZvciB0aGUgbGluZSBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5bGluZX1cbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS4gRm9yIGNvbXBsZXggcGF0aHMsIHJldHVybnMgYW4gYXJyYXkgb2YgcG9seWxpbmVzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxuICAgICAqL1xuICAgIHB1YmxpYyBHZXROYXRpdmVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb2x5bGluZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXG4gICAgICogb3B0aW9ucyBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpLnRoZW4obCA9PiB7XG4gICAgICAgICAgICBjb25zdCB4OiBBcnJheTxQb2x5bGluZT4gPSBBcnJheS5pc0FycmF5KGwpID8gbCA6IFtsXTtcbiAgICAgICAgICAgIHguZm9yRWFjaChsaW5lID0+IGxpbmUuU2V0T3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIFBvbHlsaW5lIHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIFVwZGF0ZVBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGwgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID1cbiAgICAgICAgICAgICAgICBwb2x5bGluZS5QYXRoLmxlbmd0aCA+IDAgJiYgQXJyYXkuaXNBcnJheShwb2x5bGluZS5QYXRoWzBdKSA/IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBvbHlsaW5lLlBhdGggOlxuICAgICAgICAgICAgICAgIDxBcnJheTxBcnJheTxJTGF0TG9uZz4+Pltwb2x5bGluZS5QYXRoXTtcbiAgICAgICAgICAgIHguZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPiBpbmRleCkgeyBsaW5lLlNldFBhdGgocFtpbmRleF0pOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGwpICYmIGwubGVuZ3RoID4gcC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsLnNwbGljZShwLmxlbmd0aCAtIDEpLmZvckVhY2gobGluZSA9PiBsaW5lLkRlbGV0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWFwU2VydmljZUZhY3RvcnkgfSBmcm9tICcuLi9tYXBzZXJ2aWNlZmFjdG9yeSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuLi9tYXJrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBJbmZvQm94U2VydmljZSB9IGZyb20gJy4uL2luZm9ib3guc2VydmljZSc7XG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3BvbHlsaW5lLnNlcnZpY2UnO1xuXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xuXG5pbXBvcnQgeyBHb29nbGVNYXBBUElMb2FkZXIsIEdvb2dsZU1hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vZ29vZ2xlLW1hcC1hcGktbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1pbmZvYm94LnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlTWFya2VyU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLW1hcmtlci5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZU1hcFNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBHb29nbGVMYXllclNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZVBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZVBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLXBvbHlsaW5lLnNlcnZpY2UnO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSBmYWN0b3J5IHRvIGNyZWF0ZSB0aHJlZSBuZWNlc3NhcnkgR29vZ2xlIE1hcHMgc3BlY2lmaWMgc2VydmljZSBpbnN0YW5jZXMuXG4gKlxuICogQGV4cG9ydFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgR29vZ2xlTWFwU2VydmljZUZhY3RvcnkgaW1wbGVtZW50cyBNYXBTZXJ2aWNlRmFjdG9yeSB7XG4gICAgcHJpdmF0ZSBfbWFwOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD47XG4gICAgcHJpdmF0ZSBfbWFwUmVzb2x2ZXI6ICh2YWx1ZT86IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4gdm9pZDtcblxuICAgIC8vL1xuICAgIC8vLyBDb25zdHJ1Y3RvclxuICAgIC8vL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gX2xvYWRlciAtIHtAbGluayBNYXBBUElMb2FkZXJ9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgR29vZ2xlIE1hcCBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgb2JqZWN0IHRvIGltcGxlbWVudCB6b25lIGF3YXJlIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbG9hZGVyOiBNYXBBUElMb2FkZXIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xuICAgICAgICB0aGlzLl9tYXAgPVxuICAgICAgICAgICAgbmV3IFByb21pc2U8R29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwPigocmVzb2x2ZTogKCkgPT4gdm9pZCkgPT4geyB0aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwU2VydmljZUZhY3RvcnkgaW1wbGVtZW50YXRpb24uXG4gICAgLy8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXAgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZUZhY3RvcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlKCk6IE1hcFNlcnZpY2Uge1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZU1hcFNlcnZpY2UodGhpcy5fbG9hZGVyLCB0aGlzLl96b25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjbHVzdGVyIHNlcnZpY2UgZm9yIHRoZSBHb29nbGUgTWFwcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVDbHVzdGVyU2VydmljZShfbWFwU2VydmljZTogTWFwU2VydmljZSk6IENsdXN0ZXJTZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbHVzdGVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGggaW5mbyBib3ggc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfS5cbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcmtlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcmtlclNlcnZpY2V9LlxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVJbmZvQm94U2VydmljZX0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZUZhY3RvcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlSW5mb0JveFNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIF9tYXJrZXJTZXJ2aWNlOiBNYXJrZXJTZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgR29vZ2xlSW5mb0JveFNlcnZpY2UoX21hcFNlcnZpY2UsIF9tYXJrZXJTZXJ2aWNlLCB0aGlzLl96b25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBsYXllciBzZXJ2aWNlIGZvciB0aGUgR29vZ2xlIE1hcHMgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcFNlcnZpY2V9LlxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIExheWVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTGF5ZXJTZXJ2aWNlfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVMYXllclNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVMYXllclNlcnZpY2UoX21hcFNlcnZpY2UsIHRoaXMuX3pvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1hcmtlciBzZXJ2aWNlIGZvciB0aGUgR29vZ2xlIE1hcHMgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcFNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9LlxuICAgICAqIEBwYXJhbSBjbHVzdGVycyAgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlfS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBNYXJrZXJTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVNYXJrZXJTZXJ2aWNlfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxuICAgICAqL1xuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfbGF5ZXJTZXJ2aWNlOiBHb29nbGVMYXllclNlcnZpY2UsIF9jbHVzdGVyU2VydmljZTogR29vZ2xlQ2x1c3RlclNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCBfbGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2UsIHRoaXMuX3pvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlnb24gc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBQb2x5Z29uU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZUZhY3RvcnlcbiAgICAgKi9cbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVQb2x5Z29uU2VydmljZShtYXAsIGxheWVycywgdGhpcy5fem9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcG9seWxpbmUgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBQb2x5bGluZVNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XG4gICAgICovXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lU2VydmljZShtYXA6IE1hcFNlcnZpY2UsIGxheWVyczogTGF5ZXJTZXJ2aWNlKTogUG9seWxpbmVTZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVQb2x5bGluZVNlcnZpY2UobWFwLCBsYXllcnMsIHRoaXMuX3pvbmUpO1xuICAgIH1cblxufVxuXG4vKipcbiAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcGxhZm9ybSBzcGVjaWZpYyBNYXBTZXJ2aWNlRmFjdG9yeS5cbiAqXG4gKiBAcGFyYW0gYXBpTG9hZGVyIC0gQW4ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuIFRoaXMgaXMgZXhwZWN0ZWQgdG8gdGhlIGEge0BsaW5rIEdvb2dsZU1hcEFQSUxvYWRlcn0uXG4gKiBAcGFyYW0gem9uZSAtIEFuIE5nWm9uZSBpbnN0YW5jZSB0byBwcm92aWRlIHpvbmUgYXdhcmUgcHJvbWlzZXMuXG4gKlxuICogQHJldHVybnMgLSBBIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkoYXBpTG9hZGVyOiBNYXBBUElMb2FkZXIsIHpvbmU6IE5nWm9uZSk6IE1hcFNlcnZpY2VGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5KGFwaUxvYWRlciwgem9uZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHBsYWZvcm0gc3BlY2lmaWMgTWFwTG9hZGVyRmFjdG9yeS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcmV0dXJucyAtIEEge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHb29nbGVNYXBMb2FkZXJGYWN0b3J5KCk6IE1hcEFQSUxvYWRlciB7XG4gICAgcmV0dXJuIG5ldyBHb29nbGVNYXBBUElMb2FkZXIobmV3IEdvb2dsZU1hcEFQSUxvYWRlckNvbmZpZygpLCBuZXcgV2luZG93UmVmKCksIG5ldyBEb2N1bWVudFJlZigpKTtcbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgJ2JpbmdtYXBzJztcblxuLy8vXG4vLy8gaW1wb3J0IG1vZHVsZSBpbnRlcmZhY2VzXG4vLy9cbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGF0bG9uZyc7XG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcbmltcG9ydCB7IElJbmZvV2luZG93QWN0aW9uIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9paW5mby13aW5kb3ctYWN0aW9uJztcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XG5pbXBvcnQgeyBJU2l6ZSB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaXNpemUnO1xuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pcG9pbnQnO1xuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWJveCc7XG5pbXBvcnQgeyBJTWFya2VyRXZlbnQgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2ltYXJrZXItZXZlbnQnO1xuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVNwaWRlckNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pc3BpZGVyLWNsdXN0ZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBJTGluZU9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lsaW5lLW9wdGlvbnMnO1xuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcbmltcG9ydCB7IElQb2x5bGluZUV2ZW50IH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pcG9seWxpbmUtZXZlbnQnO1xuaW1wb3J0IHsgSU1hcEV2ZW50TG9va3VwIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbWFwLWV2ZW50LWxvb2t1cCc7XG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XG5pbXBvcnQgeyBJQ3VzdG9tTWFwU3R5bGV9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWN1c3RvbS1tYXAtc3R5bGUnO1xuXG4vLy9cbi8vLyBpbXBvcnQgbW9kdWxlIG1vZGVsc1xuLy8vXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2luZm8td2luZG93JztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4vc3JjL21vZGVscy9tYXJrZXInO1xuaW1wb3J0IHsgTWFya2VyVHlwZUlkIH0gZnJvbSAnLi9zcmMvbW9kZWxzL21hcmtlci10eXBlLWlkJztcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4vc3JjL21vZGVscy9tYXAtdHlwZS1pZCc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4vc3JjL21vZGVscy9sYXllcic7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9zcmMvbW9kZWxzL3BvbHlnb24nO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3NyYy9tb2RlbHMvcG9seWxpbmUnO1xuaW1wb3J0IHsgU3BpZGVyQ2x1c3Rlck1hcmtlciB9IGZyb20gJy4vc3JjL21vZGVscy9zcGlkZXItY2x1c3Rlci1tYXJrZXInO1xuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuL3NyYy9tb2RlbHMvY2x1c3Rlci1wbGFjZW1lbnQtbW9kZSc7XG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuL3NyYy9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheX0gZnJvbSAnLi9zcmMvbW9kZWxzL2NhbnZhcy1vdmVybGF5JztcbmltcG9ydCB7IEJpbmdMYXllciB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctbGF5ZXInO1xuaW1wb3J0IHsgQmluZ0NsdXN0ZXJMYXllciB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctY2x1c3Rlci1sYXllcic7XG5pbXBvcnQgeyBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2Jpbmctc3BpZGVyLWNsdXN0ZXItbWFya2VyJztcbmltcG9ydCB7IEJpbmdJbmZvV2luZG93IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1pbmZvLXdpbmRvdyc7XG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xuaW1wb3J0IHsgQmluZ1BvbHlnb24gfSBmcm9tICcuL3NyYy9tb2RlbHMvYmluZy9iaW5nLXBvbHlnb24nO1xuaW1wb3J0IHsgQmluZ1BvbHlsaW5lIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1wb2x5bGluZSc7XG5pbXBvcnQgeyBCaW5nTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1ldmVudHMtbG9va3VwJztcbmltcG9ydCB7IEJpbmdDYW52YXNPdmVybGF5IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1jYW52YXMtb3ZlcmxheSc7XG5pbXBvcnQgeyBHb29nbGVJbmZvV2luZG93IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtaW5mby13aW5kb3cnO1xuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyJztcbmltcG9ydCB7IEdvb2dsZVBvbHlnb24gfSBmcm9tICcuL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uJztcbmltcG9ydCB7IEdvb2dsZVBvbHlsaW5lIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWxpbmUnO1xuaW1wb3J0IHsgR29vZ2xlTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cCc7XG5pbXBvcnQgeyBHb29nbGVDYW52YXNPdmVybGF5IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtY2FudmFzLW92ZXJsYXknO1xuXG4vLy9cbi8vLyBpbXBvcnQgbW9kdWxlIGNvbXBvbmVudHNcbi8vL1xuaW1wb3J0IHsgTWFwQ29tcG9uZW50IH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9tYXAnO1xuaW1wb3J0IHsgTWFwTWFya2VyRGlyZWN0aXZlIH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9tYXAtbWFya2VyJztcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL2luZm9ib3gnO1xuaW1wb3J0IHsgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvaW5mb2JveC1hY3Rpb24nO1xuaW1wb3J0IHsgTWFwTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1sYXllcic7XG5pbXBvcnQgeyBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXInO1xuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xuaW1wb3J0IHsgTWFwUG9seWxpbmVEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1wb2x5bGluZSc7XG5pbXBvcnQgeyBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLW1hcmtlci1sYXllcic7XG5pbXBvcnQgeyBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1wb2x5Z29uLWxheWVyJztcbmltcG9ydCB7IE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1wb2x5bGluZS1sYXllcic7XG5cbi8vL1xuLy8vIGltcG9ydCBtb2R1bGUgc2VydmljZXNcbi8vL1xuaW1wb3J0IHsgTWFwU2VydmljZUZhY3RvcnkgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXBzZXJ2aWNlZmFjdG9yeSc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvbWFwYXBpbG9hZGVyJztcbmltcG9ydCB7IEluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvaW5mb2JveC5zZXJ2aWNlJztcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL21hcmtlci5zZXJ2aWNlJztcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvcG9seWdvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL3BvbHlsaW5lLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2VGYWN0b3J5LFxuICAgIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnksIEJpbmdNYXBMb2FkZXJGYWN0b3J5IH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlLmZhY3RvcnknO1xuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ01hcEFQSUxvYWRlciwgQmluZ01hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuYXBpLWxvYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdJbmZvQm94U2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1pbmZvYm94LnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ01hcmtlclNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFya2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ0xheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci5zZXJ2aWNlJztcbmltcG9ydCB7IEJpbmdDbHVzdGVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1jbHVzdGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmluZ1BvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLXBvbHlnb24uc2VydmljZSc7XG5pbXBvcnQgeyBCaW5nUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLXBvbHlsaW5lLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNsdXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBHb29nbGVJbmZvQm94U2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtaW5mb2JveC5zZXJ2aWNlJztcbmltcG9ydCB7IEdvb2dsZUxheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbGF5ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBHb29nbGVNYXBBUElMb2FkZXIsIEdvb2dsZU1hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZSc7XG5pbXBvcnQge1xuICAgIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LCBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnksXG4gICAgR29vZ2xlTWFwTG9hZGVyRmFjdG9yeVxufSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC5zZXJ2aWNlLmZhY3RvcnknO1xuaW1wb3J0IHsgR29vZ2xlTWFwU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlTWFya2VyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFya2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgR29vZ2xlUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlnb24uc2VydmljZSc7XG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnNlcnZpY2UnO1xuXG4vLy9cbi8vLyBleHBvcnQgcHVibGljcyBjb21wb25lbnRzLCBtb2RlbHMsIGludGVyZmFjZXMgZXRjIGZvciBleHRlcm5hbCByZXVzZS5cbi8vL1xuZXhwb3J0IHtcbiAgICBJTGF0TG9uZywgSUluZm9XaW5kb3dPcHRpb25zLCBJSW5mb1dpbmRvd0FjdGlvbiwgSVNpemUsIElNYXJrZXJPcHRpb25zLCBJQm94LCBJTWFwT3B0aW9ucywgSVBvaW50LCBJTWFya2VyRXZlbnQsIElQb2x5Z29uRXZlbnQsXG4gICAgSVBvbHlsaW5lRXZlbnQsIElNYXBFdmVudExvb2t1cCwgSU1hcmtlckljb25JbmZvLCBJTGF5ZXJPcHRpb25zLCBJQ2x1c3Rlck9wdGlvbnMsIElTcGlkZXJDbHVzdGVyT3B0aW9ucywgSUxpbmVPcHRpb25zLFxuICAgIElQb2x5Z29uT3B0aW9ucywgSVBvbHlsaW5lT3B0aW9ucywgSUxhYmVsT3B0aW9ucywgSUN1c3RvbU1hcFN0eWxlLCBNYXBDb21wb25lbnQsIEluZm9Cb3hDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZSwgTWFwUG9seWdvbkRpcmVjdGl2ZSxcbiAgICBNYXBQb2x5bGluZURpcmVjdGl2ZSwgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSwgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUsIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZSwgTWFwTGF5ZXJEaXJlY3RpdmUsXG4gICAgQ2x1c3RlckxheWVyRGlyZWN0aXZlLCBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlLCBNYXBUeXBlSWQsIE1hcmtlciwgTWFya2VyVHlwZUlkLCBJbmZvV2luZG93LCBMYXllciwgQ2x1c3RlclBsYWNlbWVudE1vZGUsXG4gICAgQ2x1c3RlckNsaWNrQWN0aW9uLCBTcGlkZXJDbHVzdGVyTWFya2VyLCBQb2x5Z29uLCBQb2x5bGluZSwgQ2FudmFzT3ZlcmxheSwgTWFwU2VydmljZSwgTWFwU2VydmljZUZhY3RvcnksIE1hcmtlclNlcnZpY2UsXG4gICAgSW5mb0JveFNlcnZpY2UsIE1hcEFQSUxvYWRlciwgV2luZG93UmVmLCBEb2N1bWVudFJlZiwgTGF5ZXJTZXJ2aWNlLCBQb2x5Z29uU2VydmljZSwgUG9seWxpbmVTZXJ2aWNlLCBDbHVzdGVyU2VydmljZVxufTtcbmV4cG9ydCB7XG4gICAgQmluZ01hcFNlcnZpY2VGYWN0b3J5LCBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnLCBCaW5nTWFwU2VydmljZSwgQmluZ0luZm9Cb3hTZXJ2aWNlLFxuICAgIEJpbmdNYXJrZXJTZXJ2aWNlLCBCaW5nUG9seWdvblNlcnZpY2UsIEJpbmdQb2x5bGluZVNlcnZpY2UsIEJpbmdNYXBBUElMb2FkZXIsXG4gICAgQmluZ0xheWVyU2VydmljZSwgQmluZ0NsdXN0ZXJTZXJ2aWNlLCBCaW5nTGF5ZXIsIEJpbmdNYXJrZXIsIEJpbmdQb2x5bGluZSwgQmluZ01hcEV2ZW50c0xvb2t1cCwgQmluZ1BvbHlnb24sXG4gICAgQmluZ0luZm9XaW5kb3csIEJpbmdDbHVzdGVyTGF5ZXIsIEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyLCBCaW5nQ2FudmFzT3ZlcmxheVxufTtcbmV4cG9ydCB7XG4gICAgR29vZ2xlQ2x1c3RlclNlcnZpY2UsIEdvb2dsZUluZm9Cb3hTZXJ2aWNlLCBHb29nbGVMYXllclNlcnZpY2UsIEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnLFxuICAgIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LCBHb29nbGVNYXBTZXJ2aWNlLCBHb29nbGVNYXJrZXJTZXJ2aWNlLCBHb29nbGVQb2x5Z29uU2VydmljZSwgR29vZ2xlUG9seWxpbmVTZXJ2aWNlLFxuICAgIEdvb2dsZU1hcmtlciwgR29vZ2xlSW5mb1dpbmRvdywgR29vZ2xlUG9seWdvbiwgR29vZ2xlUG9seWxpbmUsIEdvb2dsZU1hcEV2ZW50c0xvb2t1cCwgR29vZ2xlQ2FudmFzT3ZlcmxheVxufTtcblxuLy8vXG4vLy8gZGVmaW5lIG1vZHVsZVxuLy8vXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBNYXBMYXllckRpcmVjdGl2ZSxcbiAgICAgICAgTWFwQ29tcG9uZW50LFxuICAgICAgICBNYXBNYXJrZXJEaXJlY3RpdmUsXG4gICAgICAgIEluZm9Cb3hDb21wb25lbnQsXG4gICAgICAgIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUsXG4gICAgICAgIE1hcFBvbHlnb25EaXJlY3RpdmUsXG4gICAgICAgIE1hcFBvbHlsaW5lRGlyZWN0aXZlLFxuICAgICAgICBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUsXG4gICAgICAgIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLFxuICAgICAgICBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUsXG4gICAgICAgIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXBDb21wb25lbnQsXG4gICAgICAgIE1hcE1hcmtlckRpcmVjdGl2ZSxcbiAgICAgICAgTWFwUG9seWdvbkRpcmVjdGl2ZSxcbiAgICAgICAgTWFwUG9seWxpbmVEaXJlY3RpdmUsXG4gICAgICAgIEluZm9Cb3hDb21wb25lbnQsXG4gICAgICAgIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUsXG4gICAgICAgIE1hcExheWVyRGlyZWN0aXZlLFxuICAgICAgICBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUsXG4gICAgICAgIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLFxuICAgICAgICBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUsXG4gICAgICAgIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE1hcE1vZHVsZSB7XG5cbiAgICBzdGF0aWMgZm9yUm9vdChtYXBTZXJ2aWNlRmFjdG9yeT86IE1hcFNlcnZpY2VGYWN0b3J5LCBsb2FkZXI/OiBNYXBBUElMb2FkZXIpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNYXBNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBtYXBTZXJ2aWNlRmFjdG9yeSA/IHsgcHJvdmlkZTogTWFwU2VydmljZUZhY3RvcnksIHVzZVZhbHVlOiBtYXBTZXJ2aWNlRmFjdG9yeSB9IDpcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBNYXBTZXJ2aWNlRmFjdG9yeSwgZGVwczogW01hcEFQSUxvYWRlciwgTmdab25lXSwgdXNlRmFjdG9yeTogQmluZ01hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgIGxvYWRlciA/IHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VWYWx1ZTogbG9hZGVyIH0gOiB7IHByb3ZpZGU6IE1hcEFQSUxvYWRlciwgdXNlRmFjdG9yeTogQmluZ01hcExvYWRlckZhY3RvcnkgfSxcbiAgICAgICAgICAgICAgICBEb2N1bWVudFJlZixcbiAgICAgICAgICAgICAgICBXaW5kb3dSZWZcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZm9yUm9vdEJpbmcoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWFwTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBNYXBTZXJ2aWNlRmFjdG9yeSwgZGVwczogW01hcEFQSUxvYWRlciwgTmdab25lXSwgdXNlRmFjdG9yeTogQmluZ01hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VGYWN0b3J5OiBCaW5nTWFwTG9hZGVyRmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgIERvY3VtZW50UmVmLFxuICAgICAgICAgICAgICAgIFdpbmRvd1JlZlxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JSb290R29vZ2xlKCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1hcE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwU2VydmljZUZhY3RvcnksIGRlcHM6IFtNYXBBUElMb2FkZXIsIE5nWm9uZV0sIHVzZUZhY3Rvcnk6IEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VGYWN0b3J5OiBHb29nbGVNYXBMb2FkZXJGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgRG9jdW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgV2luZG93UmVmXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIiwiZWFjaFNlcmllcyIsIm5leHRUaWNrIiwiaWQiLCJHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWQiLCJJbmplY3RhYmxlIiwiRXZlbnRFbWl0dGVyIiwiRGlyZWN0aXZlIiwiSW5wdXQiLCJPdXRwdXQiLCJDb21wb25lbnQiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIlZpZXdDaGlsZCIsIkNvbnRlbnRDaGlsZHJlbiIsInRpbWVyIiwiVmlld0NvbnRhaW5lclJlZiIsIkNvbnRlbnRDaGlsZCIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiTmdab25lIiwiSG9zdEJpbmRpbmciLCJsYXllcklkIiwiT3B0aW9uYWwiLCJPYnNlcnZhYmxlIiwiU3ViamVjdCIsInRzbGliXzEuX192YWx1ZXMiLCJERUZBVUxUX0NPTkZJR1VSQVRJT04iLCJTY3JpcHRQcm90b2NvbCIsIk1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXciLCJNaXhpbkNhbnZhc092ZXJsYXkiLCJOZ01vZHVsZSIsIkNvbW1vbk1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUdBOztRQUFBOzs7eUJBSEE7UUFpRkM7Ozs7Ozs7O1FDaEZHLE9BQVE7UUFDUixhQUFVO1FBQ1YsZUFBWTtRQUNaLHNCQUFtQjtRQUNuQixxQkFBa0I7UUFDbEIscUJBQWtCO1FBQ2xCLG9CQUFpQjtRQUNqQixTQUFNOzs4QkFQTixJQUFJOzhCQUNKLFVBQVU7OEJBQ1YsWUFBWTs4QkFDWixtQkFBbUI7OEJBQ25CLGtCQUFrQjs4QkFDbEIsa0JBQWtCOzhCQUNsQixpQkFBaUI7OEJBQ2pCLE1BQU07Ozs7OztBQ0hWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUE2RGtCLG1CQUFZOzs7Ozs7Ozs7OztzQkFBQyxRQUF5QjtnQkFDaEQsUUFBUSxRQUFRLENBQUMsVUFBVTtvQkFDdkIsS0FBSyxZQUFZLENBQUMsWUFBWSxFQUFFLE9BQU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMzRSxLQUFLLFlBQVksQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDekYsS0FBSyxZQUFZLENBQUMsVUFBVSxFQUFFLE9BQU8sTUFBTSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUM1RSxLQUFLLFlBQVksQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDdkYsS0FBSyxZQUFZLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxNQUFNLENBQUMsd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQ3ZGLEtBQUssWUFBWSxDQUFDLGlCQUFpQixFQUFFLE9BQU8sTUFBTSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUNyRixLQUFLLFlBQVksQ0FBQyxNQUFNLEVBQUUsTUFBTSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztpQkFDaEc7Z0JBQ0QsTUFBTSxLQUFLLENBQUMsMkJBQTJCLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDOzs7Ozs7Ozs7UUFVckQsd0JBQWlCOzs7Ozs7O3NCQUFDLElBQVk7Z0JBQ3hDLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssRUFBRyxFQUFFO29CQUFFLE9BQVEsSUFBSSxDQUFDO2lCQUFFOztnQkFFbkQsSUFBSSxHQUFHLEdBQXFCLElBQUksQ0FBQztnQkFDakMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3pDLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtvQkFBRSxPQUFPLEdBQUcsQ0FBQztpQkFBRTtnQkFFaEMsSUFBSSxRQUFPLFFBQVEsQ0FBQyxLQUFLLFdBQVcsSUFBSSxRQUFRLElBQUksSUFBSSxFQUFFO29CQUN0RCxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDcEMsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7b0JBQ2YsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQzNDO2dCQUNELE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQVlFLHlCQUFrQjs7Ozs7Ozs7O1lBQW5DLFVBQW9DLFFBQXlCO2dCQUN6RCxJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUU7b0JBQUUsTUFBTSxLQUFLLENBQUMsb0VBQW9FLENBQUMsQ0FBQztpQkFBRTtnQkFDNUcsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxJQUFJLFFBQVEsQ0FBQyxNQUFNLElBQUksSUFBSSxFQUFFO29CQUN0RSxNQUFNLEtBQUssQ0FBQyxtRkFBbUYsQ0FBQyxDQUFDO2lCQUNwRztnQkFDRCxJQUFJLFFBQVEsQ0FBQyxFQUFFLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRTs7b0JBQzVELElBQU0sRUFBRSxHQUEwQixNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7b0JBQ3RFLFFBQVEsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQztvQkFDOUIsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLENBQUM7aUJBQzlCOztnQkFFRCxJQUFNLENBQUMsR0FBc0IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7Z0JBQzlELElBQU0sR0FBRyxHQUE2QixDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN6RCxDQUFDLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUM5QixDQUFDLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUNoQyxJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7O29CQUVuQixHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUM7O29CQUU3QyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQzs7b0JBRTlDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUM7aUJBQ2xEO2dCQUVELEdBQUcsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUM7O2dCQUd4QyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2hCLElBQUksUUFBUSxDQUFDLGFBQWEsRUFBRTtvQkFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQUU7Z0JBQy9GLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBUyxJQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2xFLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDaEIsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNYLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7Z0JBRWIsSUFBTSxDQUFDLEdBQVcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUNoQyxJQUFJLFFBQVEsQ0FBQyxFQUFFLElBQUksSUFBSSxFQUFFO29CQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2lCQUFFO2dCQUNySCxPQUFPLENBQUMsQ0FBQzthQUNaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBV2dCLGdDQUF5Qjs7Ozs7Ozs7O1lBQTFDLFVBQTJDLFFBQXlCO2dCQUNoRSxJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUU7b0JBQUUsTUFBTSxLQUFLLENBQUMsNEVBQTRFLENBQUMsQ0FBQztpQkFBRTtnQkFDcEgsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFO29CQUFFLE1BQU0sS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7aUJBQUU7Z0JBQy9ILElBQUksUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFOztvQkFDNUQsSUFBTSxFQUFFLEdBQTBCLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDdEUsUUFBUSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDO29CQUM5QixPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztpQkFDOUI7O2dCQUVELElBQU0sV0FBVyxHQUFXLFFBQVEsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDOztnQkFFdEQsSUFBTSxHQUFHLEdBQWtCO29CQUN2QixpREFBaUQ7b0JBQ2pELFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtvQkFDOUIsWUFBWTtvQkFDWixRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7b0JBQzlCLGdCQUFnQjtvQkFDaEIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsUUFBUSxFQUFFO29CQUNwQyxRQUFRO29CQUNSLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLFFBQVEsRUFBRTtvQkFDcEMsT0FBTztvQkFDUCxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLFdBQVcsRUFBRSxRQUFRLEVBQUU7b0JBQ3BELFlBQVk7b0JBQ1osUUFBUSxDQUFDLEtBQUssSUFBSSxLQUFLO29CQUN2QixrQkFBa0I7b0JBQ2xCLFdBQVcsQ0FBQyxRQUFRLEVBQUU7b0JBQ3RCLFVBQVU7b0JBQ1YsUUFBUSxDQUFDLEtBQUssSUFBSSxLQUFLO29CQUN2QixXQUFXO2lCQUNkLENBQUM7O2dCQUVGLElBQU0sQ0FBQyxHQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQy9CLElBQUksUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQUU7b0JBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLGdCQUFnQixFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7aUJBQUU7Z0JBQ3JILE9BQU8sQ0FBQyxDQUFDO2FBQ1o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFXZ0IsNEJBQXFCOzs7Ozs7Ozs7WUFBdEMsVUFBdUMsUUFBeUI7Z0JBQzVELElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtvQkFBRSxNQUFNLEtBQUssQ0FBQyx1RUFBdUUsQ0FBQyxDQUFDO2lCQUFFO2dCQUMvRyxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLFFBQVEsSUFBSSxJQUFJLEVBQUU7b0JBQzVFLE1BQU0sS0FBSyxDQUFDLGtIQUFrSCxDQUFDLENBQUM7aUJBQ25JO2dCQUNELElBQUksUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFOztvQkFDNUQsSUFBTSxFQUFFLEdBQTBCLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDdEUsUUFBUSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDO29CQUM5QixPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztpQkFDOUI7O2dCQUVELElBQU0sQ0FBQyxHQUFzQixRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztnQkFDOUQsSUFBTSxHQUFHLEdBQTZCLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7O2dCQUN6RCxJQUFNLElBQUksR0FBVyxRQUFRLENBQUMsUUFBUSxHQUFHLEtBQUssR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO2dCQUNuRSxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7Z0JBR2hCLElBQU0sSUFBSSxHQUFnQixHQUFHLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDekQsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNyQixDQUFDLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUM7Z0JBRTdCLElBQUksUUFBUSxDQUFDLFFBQVEsRUFBRTs7b0JBRW5CLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQzs7b0JBRTdDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDOztvQkFFOUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQztpQkFDbEQ7O2dCQUdELEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO2dCQUNoQixHQUFHLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztnQkFDekIsR0FBRyxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQztnQkFFeEMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDbEMsUUFBUSxDQUFDLElBQUksR0FBRyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7O2dCQUNyRCxJQUFNLENBQUMsR0FBVyxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2hDLElBQUksUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQUU7b0JBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLGdCQUFnQixFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7aUJBQUU7Z0JBQ3JILE9BQU8sQ0FBQyxDQUFDO2FBQ1o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQVlnQiwrQkFBd0I7Ozs7Ozs7Ozs7WUFBekMsVUFBMEMsUUFBeUI7Z0JBQy9ELElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtvQkFBRSxNQUFNLEtBQUssQ0FBQywwRUFBMEUsQ0FBQyxDQUFDO2lCQUFFO2dCQUNsSCxJQUFJLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLFFBQVEsSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQUU7b0JBQ3ZFLE1BQU0sS0FBSyxDQUFDLHVGQUF1RixDQUFDLENBQUM7aUJBQ3hHO2dCQUNELElBQUksUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFOztvQkFDNUQsSUFBTSxFQUFFLEdBQTBCLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDdEUsUUFBUSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDO29CQUM5QixPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztpQkFDOUI7O2dCQUVELElBQU0sS0FBSyxHQUFxQixJQUFJLEtBQUssRUFBRSxDQUFDOztnQkFDNUMsSUFBTSxPQUFPLEdBQ1QsSUFBSSxPQUFPLENBQTRDLFVBQUMsT0FBTyxFQUFFLE1BQU07O29CQUV2RSxLQUFLLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztvQkFDaEMsS0FBSyxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDO29CQUN6QixJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUU7d0JBQ2YsS0FBSyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQzt3QkFDbEMsS0FBSyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztxQkFDdkM7b0JBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRzs7d0JBQ1gsSUFBTSxDQUFDLEdBQXNCLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7O3dCQUM5RCxJQUFNLEdBQUcsR0FBNkIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7d0JBQ3pELElBQU0sSUFBSSxHQUFXLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUM7O3dCQUd2RCxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3RHLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7d0JBR3ZHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQzs7d0JBRXpDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7O3dCQUVqQixHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQ3JGLFFBQVEsQ0FBQyxJQUFJLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDOzt3QkFFckQsSUFBTSxDQUFDLEdBQVcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO3dCQUNoQyxJQUFJLFFBQVEsQ0FBQyxFQUFFLElBQUksSUFBSSxFQUFFOzRCQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxJ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